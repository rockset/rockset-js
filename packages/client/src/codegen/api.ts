// tslint:disable
/**
 * REST API
 * Rockset's REST API allows for creating and managing all resources in Rockset. Each supported endpoint is documented below.  All requests must be authorized with a Rockset API key, which can be created in the [Rockset console](https://console.rockset.com). The API key must be provided as `ApiKey <api_key>` in the `Authorization` request header. For example: ``` Authorization: ApiKey aB35kDjg93J5nsf4GjwMeErAVd832F7ad4vhsW1S02kfZiab42sTsfW5Sxt25asT ```  All endpoints are only accessible via https.  Build something awesome!
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import { Configuration } from "./configuration";
const fetchPonyfill = require("fetch-ponyfill")();

const BASE_PATH = "https://api.use1a1.rockset.com".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;
    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = fetchPonyfill.fetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AddDocumentsRequest
 */
export interface AddDocumentsRequest {
    /**
     * Array of documents to be added to the collection.
     * @type {Array<any>}
     * @memberof AddDocumentsRequest
     */
    data: Array<any>;
}

/**
 * 
 * @export
 * @interface AddDocumentsResponse
 */
export interface AddDocumentsResponse {
    /**
     * Information about the added documents.
     * @type {Array<DocumentStatus>}
     * @memberof AddDocumentsResponse
     */
    data?: Array<DocumentStatus>;
    /**
     * A string representing the collection offset after completing the write.
     * @type {string}
     * @memberof AddDocumentsResponse
     */
    last_offset?: string;
}

/**
 * 
 * @export
 * @interface Alias
 */
export interface Alias {
    /**
     * List of fully qualified collection names referenced by alias.
     * @type {Array<string>}
     * @memberof Alias
     */
    collections?: Array<string>;
    /**
     * ISO-8601 date.
     * @type {string}
     * @memberof Alias
     */
    created_at?: string;
    /**
     * Name of the API key that was used to create this object if one was used.
     * @type {string}
     * @memberof Alias
     */
    created_by_apikey_name?: string;
    /**
     * Email of the creator.
     * @type {string}
     * @memberof Alias
     */
    creator_email?: string;
    /**
     * Alias description.
     * @type {string}
     * @memberof Alias
     */
    description?: string;
    /**
     * ISO-8601 date.
     * @type {string}
     * @memberof Alias
     */
    modified_at?: string;
    /**
     * Name of the alias.
     * @type {string}
     * @memberof Alias
     */
    name?: string;
    /**
     * State of the alias.
     * @type {string}
     * @memberof Alias
     */
    state?: Alias.StateEnum;
    /**
     * Name of the workspace.
     * @type {string}
     * @memberof Alias
     */
    workspace?: string;
}

/**
 * @export
 * @namespace Alias
 */
export namespace Alias {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        CREATED = <any> 'CREATED',
        DELETED = <any> 'DELETED'
    }
}

/**
 * API keys are used to authenticate requests to Rockset's API. An API key is tied to the user who creates it.
 * @export
 * @interface ApiKey
 */
export interface ApiKey {
    /**
     * Date that API key was created (ISO-8601 format).
     * @type {string}
     * @memberof ApiKey
     */
    created_at?: string;
    /**
     * Email of API key owner.
     * @type {string}
     * @memberof ApiKey
     */
    created_by?: string;
    /**
     * Name of the API key that was used to create this object if one was used.
     * @type {string}
     * @memberof ApiKey
     */
    created_by_apikey_name?: string;
    /**
     * The expiration date of this API key.
     * @type {string}
     * @memberof ApiKey
     */
    expiry_time?: string;
    /**
     * This field will only be populated with the full key when creating an API key. Otherwise, it will be an API key identifier of 6 characters.
     * @type {string}
     * @memberof ApiKey
     */
    key: string;
    /**
     * Date that API key was most recently used (ISO-8601 format).
     * @type {string}
     * @memberof ApiKey
     */
    last_access_time?: string;
    /**
     * Name of the API key.
     * @type {string}
     * @memberof ApiKey
     */
    name: string;
    /**
     * Role specifying access control. If not specified, API key will have access to all of the associated user's roles.
     * @type {string}
     * @memberof ApiKey
     */
    role?: string;
    /**
     * Current state of this key.
     * @type {string}
     * @memberof ApiKey
     */
    state?: ApiKey.StateEnum;
}

/**
 * @export
 * @namespace ApiKey
 */
export namespace ApiKey {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        ACTIVE = <any> 'ACTIVE',
        SUSPENDED = <any> 'SUSPENDED'
    }
}

/**
 * 
 * @export
 * @interface AsyncQueryOptions
 */
export interface AsyncQueryOptions {
    /**
     * If the query completes before the client timeout, the results are returned. Otherwise if the client timeout is exceeded, the query id will be returned, and the query will continue to run in the background for up to 30 minutes. (The 30 minute timeout can be configured lower with timeout_ms.) `async_options.client_timeout_ms` only applies when `async` is true. The default value of `client_timeout_ms` is 0, so async query requests will immediately return with a query id by default. 
     * @type {number}
     * @memberof AsyncQueryOptions
     */
    client_timeout_ms?: number;
    /**
     * [DEPRECATED] Use the query request `max_initial_results` instead. The maximum number of results you will receive as a client. If the query exceeds this limit, the remaining results can be requested using a returned pagination cursor. In addition, there is a maximum response size of 100MiB so fewer than `max_results` may be returned.
     * @type {number}
     * @memberof AsyncQueryOptions
     */
    max_initial_results?: number;
    /**
     * [DEPRECATED] Use the query request `timeout_ms` instead. The maximum amount of time that the system will attempt to complete query execution before aborting the query and returning an error. This must be set to a value that is greater than or equal to the client timeout, and the maximum value of this timeout is 30 minutes.
     * @type {number}
     * @memberof AsyncQueryOptions
     */
    timeout_ms?: number;
}

/**
 * 
 * @export
 * @interface AutoScalingPolicy
 */
export interface AutoScalingPolicy {
    /**
     * Whether auto scaling policy is enabled.
     * @type {boolean}
     * @memberof AutoScalingPolicy
     */
    enabled?: boolean;
    /**
     * Maximum size Rockset can auto scale the Virtual Instance to. This value should be one of the dedicated sizes greater than or same as the min_size and lower than or same as the current size.
     * @type {string}
     * @memberof AutoScalingPolicy
     */
    max_size?: AutoScalingPolicy.MaxSizeEnum;
    /**
     * Minimum size Rockset can auto scale the Virtual Instance to. This value should be one of the dedicated sizes lower than or same as the max_size and greater than or same as the current size.
     * @type {string}
     * @memberof AutoScalingPolicy
     */
    min_size?: AutoScalingPolicy.MinSizeEnum;
}

/**
 * @export
 * @namespace AutoScalingPolicy
 */
export namespace AutoScalingPolicy {
    /**
     * @export
     * @enum {string}
     */
    export enum MaxSizeEnum {
        FREE = <any> 'FREE',
        NANO = <any> 'NANO',
        SHARED = <any> 'SHARED',
        MILLI = <any> 'MILLI',
        XSMALL = <any> 'XSMALL',
        SMALL = <any> 'SMALL',
        MEDIUM = <any> 'MEDIUM',
        LARGE = <any> 'LARGE',
        XLARGE = <any> 'XLARGE',
        XLARGE2 = <any> 'XLARGE2',
        XLARGE4 = <any> 'XLARGE4',
        XLARGE8 = <any> 'XLARGE8',
        XLARGE16 = <any> 'XLARGE16'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum MinSizeEnum {
        FREE = <any> 'FREE',
        NANO = <any> 'NANO',
        SHARED = <any> 'SHARED',
        MILLI = <any> 'MILLI',
        XSMALL = <any> 'XSMALL',
        SMALL = <any> 'SMALL',
        MEDIUM = <any> 'MEDIUM',
        LARGE = <any> 'LARGE',
        XLARGE = <any> 'XLARGE',
        XLARGE2 = <any> 'XLARGE2',
        XLARGE4 = <any> 'XLARGE4',
        XLARGE8 = <any> 'XLARGE8',
        XLARGE16 = <any> 'XLARGE16'
    }
}

/**
 * 
 * @export
 * @interface AvroParams
 */
export interface AvroParams {
}

/**
 * 
 * @export
 * @interface AwsAccessKey
 */
export interface AwsAccessKey {
    /**
     * AWS access key ID.
     * @type {string}
     * @memberof AwsAccessKey
     */
    aws_access_key_id: string;
    /**
     * AWS secret access key.
     * @type {string}
     * @memberof AwsAccessKey
     */
    aws_secret_access_key: string;
}

/**
 * 
 * @export
 * @interface AwsRole
 */
export interface AwsRole {
    /**
     * External id used for integration.
     * @type {string}
     * @memberof AwsRole
     */
    aws_external_id?: string;
    /**
     * ARN of rockset-role created in your account.
     * @type {string}
     * @memberof AwsRole
     */
    aws_role_arn: string;
}

/**
 * 
 * @export
 * @interface AzureBlobStorageIntegration
 */
export interface AzureBlobStorageIntegration {
    /**
     * Credentials for the Azure Blob Service.
     * @type {string}
     * @memberof AzureBlobStorageIntegration
     */
    connection_string: string;
}

/**
 * 
 * @export
 * @interface AzureEventHubsIntegration
 */
export interface AzureEventHubsIntegration {
    /**
     * Credentials for the Azure Event Hubs.
     * @type {string}
     * @memberof AzureEventHubsIntegration
     */
    connection_string?: string;
}

/**
 * 
 * @export
 * @interface AzureServiceBusIntegration
 */
export interface AzureServiceBusIntegration {
    /**
     * Credentials for the Azure Service Bus.
     * @type {string}
     * @memberof AzureServiceBusIntegration
     */
    connection_string: string;
}

/**
 * 
 * @export
 * @interface BulkStats
 */
export interface BulkStats {
    /**
     * Size in bytes of documents downloaded from source during an ongoing or completed bulk ingest. This includes documents that are dropped and reingested.
     * @type {number}
     * @memberof BulkStats
     */
    data_downloaded_bytes?: number;
    /**
     * Size in bytes of documents indexed. This is the total size of documents after transformations and dropping before indexes are built.
     * @type {number}
     * @memberof BulkStats
     */
    data_indexed_bytes?: number;
    /**
     * Throughput of documents indexed in the last minute measured in bytes/s. This is based off the data_indexed_bytes size. Throughput during the download stage is shown on a per-source granularity in the sources field of the Collection response.
     * @type {number}
     * @memberof BulkStats
     */
    data_indexed_throughput_bytes?: number;
    /**
     * Number of documents downloaded from source during an ongoing or completed bulk ingest. This includes documents that are dropped and reingested.
     * @type {number}
     * @memberof BulkStats
     */
    documents_downloaded?: number;
    /**
     * Bulk ingest compute units in milliseconds used for downloading documents.
     * @type {number}
     * @memberof BulkStats
     */
    download_compute_ms?: number;
    /**
     * ISO-8601 date of when the downloading stage was completed.
     * @type {string}
     * @memberof BulkStats
     */
    downloading_stage_done_at?: string;
    /**
     * ISO-8601 date of when the finalizing stage was completed.
     * @type {string}
     * @memberof BulkStats
     */
    finalizing_stage_done_at?: string;
    /**
     * Bulk ingest compute units in milliseconds used for indexing documents.
     * @type {number}
     * @memberof BulkStats
     */
    index_compute_ms?: number;
    /**
     * ISO-8601 date of when the indexing stage was completed.
     * @type {string}
     * @memberof BulkStats
     */
    indexing_stage_done_at?: string;
    /**
     * ISO-8601 date of when the initializing stage was completed.
     * @type {string}
     * @memberof BulkStats
     */
    initializing_stage_done_at?: string;
    /**
     * Size in bytes of documents before being indexed. This is the total size of documents after decompression, transformations, and dropping. This is equal to data_indexed_bytes after the indexing stage is done unless there are retries during indexing the data.
     * @type {number}
     * @memberof BulkStats
     */
    pre_index_size_bytes?: number;
    /**
     * ISO-8601 date of when the provisioning stage was completed.
     * @type {string}
     * @memberof BulkStats
     */
    provisioning_stage_done_at?: string;
    /**
     * ISO-8601 date of when the bulk ingest was started.
     * @type {string}
     * @memberof BulkStats
     */
    started_at?: string;
    /**
     * Total size of indexes after the completed bulk ingest. This is the same as collection size.
     * @type {number}
     * @memberof BulkStats
     */
    total_index_size_bytes?: number;
    /**
     * Bulk ingest compute units in milliseconds used for ingest transformation.
     * @type {number}
     * @memberof BulkStats
     */
    transformation_compute_ms?: number;
}

/**
 * 
 * @export
 * @interface CancelQueryResponse
 */
export interface CancelQueryResponse {
    /**
     * 
     * @type {QueryInfo}
     * @memberof CancelQueryResponse
     */
    data?: QueryInfo;
}

/**
 * 
 * @export
 * @interface Cluster
 */
export interface Cluster {
    /**
     * Api server url for cluster.
     * @type {string}
     * @memberof Cluster
     */
    apiserver_url?: string;
    /**
     * Aws region.
     * @type {string}
     * @memberof Cluster
     */
    aws_region?: string;
    /**
     * Cluster type.
     * @type {string}
     * @memberof Cluster
     */
    cluster_type?: Cluster.ClusterTypeEnum;
    /**
     * Domain of org using cluster.
     * @type {string}
     * @memberof Cluster
     */
    domain?: string;
    /**
     * Unique identifier for the cluster.
     * @type {string}
     * @memberof Cluster
     */
    id?: string;
    /**
     * Top level domain of org using cluster.
     * @type {string}
     * @memberof Cluster
     */
    top_level_domain?: string;
}

/**
 * @export
 * @namespace Cluster
 */
export namespace Cluster {
    /**
     * @export
     * @enum {string}
     */
    export enum ClusterTypeEnum {
        PUBLIC = <any> 'PUBLIC'
    }
}

/**
 * 
 * @export
 * @interface Collection
 */
export interface Collection {
    /**
     * List of aliases for a collection.
     * @type {Array<Alias>}
     * @memberof Collection
     */
    aliases?: Array<Alias>;
    /**
     * 
     * @type {Array<BulkStats>}
     * @memberof Collection
     */
    bulk_stats?: Array<BulkStats>;
    /**
     * List of clustering fields for a collection.
     * @type {Array<FieldPartition>}
     * @memberof Collection
     */
    clustering_key?: Array<FieldPartition>;
    /**
     * ISO-8601 date.
     * @type {string}
     * @memberof Collection
     */
    created_at?: string;
    /**
     * Email of user who created the collection.
     * @type {string}
     * @memberof Collection
     */
    created_by?: string;
    /**
     * Name of the API key that was used to create this collection if one was used.
     * @type {string}
     * @memberof Collection
     */
    created_by_apikey_name?: string;
    /**
     * Text describing the collection.
     * @type {string}
     * @memberof Collection
     */
    description?: string;
    /**
     * Field mapping for a collection.
     * @type {FieldMappingQuery}
     * @memberof Collection
     */
    field_mapping_query?: FieldMappingQuery;
    /**
     * List of mappings applied on all documents in a collection.
     * @type {Array<FieldMappingV2>}
     * @memberof Collection
     */
    field_mappings?: Array<FieldMappingV2>;
    /**
     * Whether the collection is insert only or not.
     * @type {boolean}
     * @memberof Collection
     */
    insert_only?: boolean;
    /**
     * Unique identifer for collection, can contain alphanumeric or dash characters.
     * @type {string}
     * @memberof Collection
     */
    name?: string;
    /**
     * Whether the collection is read-only or not.
     * @type {boolean}
     * @memberof Collection
     */
    read_only?: boolean;
    /**
     * Number of seconds after which data is purged based on event time.
     * @type {number}
     * @memberof Collection
     */
    retention_secs?: number;
    /**
     * Collection RRN.
     * @type {string}
     * @memberof Collection
     */
    rrn?: string;
    /**
     * List of sources from which collection ingests.
     * @type {Array<Source>}
     * @memberof Collection
     */
    sources?: Array<Source>;
    /**
     * Metrics about the collection.
     * @type {CollectionStats}
     * @memberof Collection
     */
    stats?: CollectionStats;
    /**
     * Current status of collection.
     * @type {string}
     * @memberof Collection
     */
    status?: Collection.StatusEnum;
    /**
     * RocksDB storage compression type.
     * @type {string}
     * @memberof Collection
     */
    storage_compression_type?: Collection.StorageCompressionTypeEnum;
    /**
     * Name of the workspace that the collection is in.
     * @type {string}
     * @memberof Collection
     */
    workspace?: string;
}

/**
 * @export
 * @namespace Collection
 */
export namespace Collection {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        INITIALIZED = <any> 'INITIALIZED',
        CREATED = <any> 'CREATED',
        READY = <any> 'READY',
        PAUSED = <any> 'PAUSED',
        DELETED = <any> 'DELETED',
        PAUSING = <any> 'PAUSING',
        RESUMING = <any> 'RESUMING',
        PREPARINGBULK = <any> 'PREPARING_BULK',
        BULKINGESTMODE = <any> 'BULK_INGEST_MODE',
        EXITINGBULKINGESTMODE = <any> 'EXITING_BULK_INGEST_MODE',
        ENCRYPTIONKEYERROR = <any> 'ENCRYPTION_KEY_ERROR',
        UNKNOWN = <any> 'UNKNOWN'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StorageCompressionTypeEnum {
        LZ4 = <any> 'LZ4',
        ZSTD = <any> 'ZSTD',
        UNKNOWN = <any> 'UNKNOWN'
    }
}

/**
 * 
 * @export
 * @interface CollectionMount
 */
export interface CollectionMount {
    /**
     * Collection path.
     * @type {string}
     * @memberof CollectionMount
     */
    collection_path?: string;
    /**
     * ISO-8601 date.
     * @type {string}
     * @memberof CollectionMount
     */
    created_at?: string;
    /**
     * Mount ID.
     * @type {string}
     * @memberof CollectionMount
     */
    id?: string;
    /**
     * Unix timestamp of most recent refresh. Not applicable for live mounts.
     * @type {number}
     * @memberof CollectionMount
     */
    last_refresh_time_millis?: number;
    /**
     * Mount RRN.
     * @type {string}
     * @memberof CollectionMount
     */
    rrn?: string;
    /**
     * Time in millis at which the snapshot expires.
     * @type {number}
     * @memberof CollectionMount
     */
    snapshot_expiration_time_millis?: number;
    /**
     * Mount type.
     * @type {string}
     * @memberof CollectionMount
     */
    state?: CollectionMount.StateEnum;
    /**
     * Stats about this Collection Mount
     * @type {CollectionMountStats}
     * @memberof CollectionMount
     */
    stats?: CollectionMountStats;
    /**
     * Virtual instance ID.
     * @type {string}
     * @memberof CollectionMount
     */
    virtual_instance_id?: string;
    /**
     * Virtual Instance RRN.
     * @type {string}
     * @memberof CollectionMount
     */
    virtual_instance_rrn?: string;
}

/**
 * @export
 * @namespace CollectionMount
 */
export namespace CollectionMount {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        CREATING = <any> 'CREATING',
        ACTIVE = <any> 'ACTIVE',
        REFRESHING = <any> 'REFRESHING',
        EXPIRED = <any> 'EXPIRED',
        DELETING = <any> 'DELETING',
        SWITCHINGREFRESHTYPE = <any> 'SWITCHING_REFRESH_TYPE',
        SUSPENDED = <any> 'SUSPENDED',
        SUSPENDING = <any> 'SUSPENDING'
    }
}

/**
 * 
 * @export
 * @interface CollectionMountResponse
 */
export interface CollectionMountResponse {
    /**
     * Resource mount object.
     * @type {CollectionMount}
     * @memberof CollectionMountResponse
     */
    data?: CollectionMount;
}

/**
 * 
 * @export
 * @interface CollectionMountStats
 */
export interface CollectionMountStats {
    /**
     * Milliseconds since Unix epoch Jan 1, 1970.
     * @type {number}
     * @memberof CollectionMountStats
     */
    last_queried_ms?: number;
}

/**
 * 
 * @export
 * @interface CollectionStats
 */
export interface CollectionStats {
    /**
     * Total number of bytes inserted into the collection during bulk.
     * @type {number}
     * @memberof CollectionStats
     */
    bulk_bytes_inserted?: number;
    /**
     * Total number of bytes overwritten in writing into the collection during bulk.
     * @type {number}
     * @memberof CollectionStats
     */
    bulk_bytes_overwritten?: number;
    /**
     * Total number of bytes inserted into the collection.
     * @type {number}
     * @memberof CollectionStats
     */
    bytes_inserted?: number;
    /**
     * Total number of bytes overwritten in writing into the collection.
     * @type {number}
     * @memberof CollectionStats
     */
    bytes_overwritten?: number;
    /**
     * Total collection column index size in bytes.
     * @type {number}
     * @memberof CollectionStats
     */
    column_index_size?: number;
    /**
     * Number of documents in the collection.
     * @type {number}
     * @memberof CollectionStats
     */
    doc_count?: number;
    /**
     * Number between 0 and 1 that indicates progress of collection creation.
     * @type {number}
     * @memberof CollectionStats
     */
    fill_progress?: number;
    /**
     * Total collection inverted index size in bytes.
     * @type {number}
     * @memberof CollectionStats
     */
    inverted_index_size?: number;
    /**
     * Milliseconds since Unix epoch Jan 1, 1970.
     * @type {number}
     * @memberof CollectionStats
     */
    last_queried_ms?: number;
    /**
     * Milliseconds since Unix epoch Jan 1, 1970.
     * @type {number}
     * @memberof CollectionStats
     */
    last_updated_ms?: number;
    /**
     * Number of documents purged from the collection.
     * @type {number}
     * @memberof CollectionStats
     */
    purged_doc_count?: number;
    /**
     * Total size of bytes purged in bytes.
     * @type {number}
     * @memberof CollectionStats
     */
    purged_doc_size?: number;
    /**
     * Total collection range index size in bytes.
     * @type {number}
     * @memberof CollectionStats
     */
    range_index_size?: number;
    /**
     * Total collection row index size in bytes.
     * @type {number}
     * @memberof CollectionStats
     */
    row_index_size?: number;
    /**
     * Total collection index size in bytes.
     * @type {number}
     * @memberof CollectionStats
     */
    total_index_size?: number;
    /**
     * Total collection size in bytes.
     * @type {number}
     * @memberof CollectionStats
     */
    total_size?: number;
}

/**
 * 
 * @export
 * @interface CreateAliasRequest
 */
export interface CreateAliasRequest {
    /**
     * List of fully qualified collection names referenced by alias.
     * @type {Array<string>}
     * @memberof CreateAliasRequest
     */
    collections: Array<string>;
    /**
     * Optional description.
     * @type {string}
     * @memberof CreateAliasRequest
     */
    description?: string;
    /**
     * Alias name.
     * @type {string}
     * @memberof CreateAliasRequest
     */
    name: string;
}

/**
 * 
 * @export
 * @interface CreateAliasResponse
 */
export interface CreateAliasResponse {
    /**
     * Alias that was created.
     * @type {Alias}
     * @memberof CreateAliasResponse
     */
    data?: Alias;
}

/**
 * 
 * @export
 * @interface CreateApiKeyRequest
 */
export interface CreateApiKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateApiKeyRequest
     */
    created_by?: string;
    /**
     * If provided, the API key will automatically expire at this time (ISO-8601 format). Requires premium.
     * @type {string}
     * @memberof CreateApiKeyRequest
     */
    expiry_time?: string;
    /**
     * Name for this API key.
     * @type {string}
     * @memberof CreateApiKeyRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateApiKeyRequest
     */
    role?: string;
}

/**
 * 
 * @export
 * @interface CreateApiKeyResponse
 */
export interface CreateApiKeyResponse {
    /**
     * The API key that was created.
     * @type {ApiKey}
     * @memberof CreateApiKeyResponse
     */
    data?: ApiKey;
}

/**
 * 
 * @export
 * @interface CreateCollectionMountRequest
 */
export interface CreateCollectionMountRequest {
    /**
     * Collections to mount.
     * @type {Array<string>}
     * @memberof CreateCollectionMountRequest
     */
    collection_paths?: Array<string>;
}

/**
 * 
 * @export
 * @interface CreateCollectionMountsResponse
 */
export interface CreateCollectionMountsResponse {
    /**
     * Mounts created.
     * @type {Array<CollectionMount>}
     * @memberof CreateCollectionMountsResponse
     */
    data?: Array<CollectionMount>;
}

/**
 * 
 * @export
 * @interface CreateCollectionRequest
 */
export interface CreateCollectionRequest {
    /**
     * Deprecated. List of clustering fields. Use CLUSTER BY clause in `field_mapping_query` instead.
     * @type {Array<FieldPartition>}
     * @memberof CreateCollectionRequest
     */
    clustering_key?: Array<FieldPartition>;
    /**
     * Text describing the collection.
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    description?: string;
    /**
     * Deprecated. Configuration for event data. Use an _event_time mapping in `field_mapping_query` instead.
     * @type {EventTimeInfo}
     * @memberof CreateCollectionRequest
     */
    event_time_info?: EventTimeInfo;
    /**
     * Ingest transformation query.
     * @type {FieldMappingQuery}
     * @memberof CreateCollectionRequest
     */
    field_mapping_query?: FieldMappingQuery;
    /**
     * Unique identifier for collection, can contain alphanumeric or dash characters.
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    name?: string;
    /**
     * Number of seconds after which data is purged, based on event time. Minimum allowable value is 3600s/1 hour. The maximum value is strictly less than 10 years.
     * @type {number}
     * @memberof CreateCollectionRequest
     */
    retention_secs?: number;
    /**
     * Soft ingest limit for this collection.
     * @type {number}
     * @memberof CreateCollectionRequest
     */
    source_download_soft_limit_bytes?: number;
    /**
     * List of sources from which to ingest data.
     * @type {Array<Source>}
     * @memberof CreateCollectionRequest
     */
    sources?: Array<Source>;
    /**
     * RocksDB storage compression type.
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    storage_compression_type?: CreateCollectionRequest.StorageCompressionTypeEnum;
}

/**
 * @export
 * @namespace CreateCollectionRequest
 */
export namespace CreateCollectionRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum StorageCompressionTypeEnum {
        LZ4 = <any> 'LZ4',
        ZSTD = <any> 'ZSTD'
    }
}

/**
 * 
 * @export
 * @interface CreateCollectionResponse
 */
export interface CreateCollectionResponse {
    /**
     * Collection that was created.
     * @type {Collection}
     * @memberof CreateCollectionResponse
     */
    data?: Collection;
}

/**
 * 
 * @export
 * @interface CreateIntegrationRequest
 */
export interface CreateIntegrationRequest {
    /**
     * Azure Blob Storage details.
     * @type {AzureBlobStorageIntegration}
     * @memberof CreateIntegrationRequest
     */
    azure_blob_storage?: AzureBlobStorageIntegration;
    /**
     * Azure Event Hubs details.
     * @type {AzureEventHubsIntegration}
     * @memberof CreateIntegrationRequest
     */
    azure_event_hubs?: AzureEventHubsIntegration;
    /**
     * Azure Service Bus details.
     * @type {AzureServiceBusIntegration}
     * @memberof CreateIntegrationRequest
     */
    azure_service_bus?: AzureServiceBusIntegration;
    /**
     * Longer explanation for the integration.
     * @type {string}
     * @memberof CreateIntegrationRequest
     */
    description?: string;
    /**
     * Amazon DynamoDB details, must have one of aws_access_key or aws_role.
     * @type {DynamodbIntegration}
     * @memberof CreateIntegrationRequest
     */
    dynamodb?: DynamodbIntegration;
    /**
     * GCS details.
     * @type {GcsIntegration}
     * @memberof CreateIntegrationRequest
     */
    gcs?: GcsIntegration;
    /**
     * is write access enabled for this integration.
     * @type {boolean}
     * @memberof CreateIntegrationRequest
     */
    is_write_enabled?: boolean;
    /**
     * 
     * @type {KafkaIntegration}
     * @memberof CreateIntegrationRequest
     */
    kafka?: KafkaIntegration;
    /**
     * Amazon Kinesis details, must have one of aws_access_key or aws_role.
     * @type {KinesisIntegration}
     * @memberof CreateIntegrationRequest
     */
    kinesis?: KinesisIntegration;
    /**
     * MongoDb details.
     * @type {MongoDbIntegration}
     * @memberof CreateIntegrationRequest
     */
    mongodb?: MongoDbIntegration;
    /**
     * Descriptive label.
     * @type {string}
     * @memberof CreateIntegrationRequest
     */
    name: string;
    /**
     * Amazon S3 details, must have one of aws_access_key or aws_role.
     * @type {S3Integration}
     * @memberof CreateIntegrationRequest
     */
    s3?: S3Integration;
    /**
     * Snowflake details.
     * @type {SnowflakeIntegration}
     * @memberof CreateIntegrationRequest
     */
    snowflake?: SnowflakeIntegration;
}

/**
 * 
 * @export
 * @interface CreateIntegrationResponse
 */
export interface CreateIntegrationResponse {
    /**
     * Integration object that was created.
     * @type {Integration}
     * @memberof CreateIntegrationResponse
     */
    data?: Integration;
}

/**
 * 
 * @export
 * @interface CreateQueryLambdaRequest
 */
export interface CreateQueryLambdaRequest {
    /**
     * Optional description.
     * @type {string}
     * @memberof CreateQueryLambdaRequest
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateQueryLambdaRequest
     */
    is_public?: boolean;
    /**
     * Query Lambda name.
     * @type {string}
     * @memberof CreateQueryLambdaRequest
     */
    name: string;
    /**
     * Query Lambda SQL query.
     * @type {QueryLambdaSql}
     * @memberof CreateQueryLambdaRequest
     */
    sql: QueryLambdaSql;
}

/**
 * 
 * @export
 * @interface CreateQueryLambdaTagRequest
 */
export interface CreateQueryLambdaTagRequest {
    /**
     * Name of Query Lambda tag.
     * @type {string}
     * @memberof CreateQueryLambdaTagRequest
     */
    tag_name: string;
    /**
     * Hash identifying a Query Lambda tag.
     * @type {string}
     * @memberof CreateQueryLambdaTagRequest
     */
    version: string;
}

/**
 * 
 * @export
 * @interface CreateRoleRequest
 */
export interface CreateRoleRequest {
    /**
     * Description for the role.
     * @type {string}
     * @memberof CreateRoleRequest
     */
    description?: string;
    /**
     * List of privileges that will be associated with the role.
     * @type {Array<Privilege>}
     * @memberof CreateRoleRequest
     */
    privileges?: Array<Privilege>;
    /**
     * Unique identifier for the role.
     * @type {string}
     * @memberof CreateRoleRequest
     */
    role_name?: string;
}

/**
 * 
 * @export
 * @interface CreateScheduledLambdaRequest
 */
export interface CreateScheduledLambdaRequest {
    /**
     * The apikey to use when triggering execution of the associated query lambda.
     * @type {string}
     * @memberof CreateScheduledLambdaRequest
     */
    apikey?: string;
    /**
     * The UNIX-formatted cron string for this scheduled query lambda.
     * @type {string}
     * @memberof CreateScheduledLambdaRequest
     */
    cron_string: string;
    /**
     * The name of the QL to use for scheduled execution.
     * @type {string}
     * @memberof CreateScheduledLambdaRequest
     */
    ql_name: string;
    /**
     * The QL tag to use for scheduled execution.
     * @type {string}
     * @memberof CreateScheduledLambdaRequest
     */
    tag?: string;
    /**
     * The number of times to execute this scheduled query lambda. Once this scheduled query lambda has been executed this many times, it will no longer be executed.
     * @type {number}
     * @memberof CreateScheduledLambdaRequest
     */
    total_times_to_execute?: number;
    /**
     * The version of the QL to use for scheduled execution.
     * @type {string}
     * @memberof CreateScheduledLambdaRequest
     */
    version?: string;
    /**
     * The value to use as the authorization header when hitting the webhook.
     * @type {string}
     * @memberof CreateScheduledLambdaRequest
     */
    webhook_auth_header?: string;
    /**
     * The payload that should be sent to the webhook. JSON format.
     * @type {string}
     * @memberof CreateScheduledLambdaRequest
     */
    webhook_payload?: string;
    /**
     * The URL of the webhook that should be triggered after this scheduled query lambda completes.
     * @type {string}
     * @memberof CreateScheduledLambdaRequest
     */
    webhook_url?: string;
}

/**
 * 
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     * User email, must be unique.
     * @type {string}
     * @memberof CreateUserRequest
     */
    email: string;
    /**
     * User first name.
     * @type {string}
     * @memberof CreateUserRequest
     */
    first_name?: string;
    /**
     * User last name.
     * @type {string}
     * @memberof CreateUserRequest
     */
    last_name?: string;
    /**
     * List of roles for a given user.
     * @type {Array<string>}
     * @memberof CreateUserRequest
     */
    roles: Array<string>;
}

/**
 * 
 * @export
 * @interface CreateUserResponse
 */
export interface CreateUserResponse {
    /**
     * User that was created.
     * @type {User}
     * @memberof CreateUserResponse
     */
    data?: User;
}

/**
 * 
 * @export
 * @interface CreateViewRequest
 */
export interface CreateViewRequest {
    /**
     * Optional description.
     * @type {string}
     * @memberof CreateViewRequest
     */
    description?: string;
    /**
     * View name.
     * @type {string}
     * @memberof CreateViewRequest
     */
    name: string;
    /**
     * SQL for this view.
     * @type {string}
     * @memberof CreateViewRequest
     */
    query: string;
}

/**
 * 
 * @export
 * @interface CreateViewResponse
 */
export interface CreateViewResponse {
    /**
     * View that was updated.
     * @type {View}
     * @memberof CreateViewResponse
     */
    data?: View;
}

/**
 * 
 * @export
 * @interface CreateVirtualInstanceRequest
 */
export interface CreateVirtualInstanceRequest {
    /**
     * Number of seconds without queries after which the VI is suspended
     * @type {number}
     * @memberof CreateVirtualInstanceRequest
     */
    auto_suspend_seconds?: number;
    /**
     * Description of requested virtual instance.
     * @type {string}
     * @memberof CreateVirtualInstanceRequest
     */
    description?: string;
    /**
     * When a Virtual Instance is resumed, it will remount all collections that were mounted when the Virtual Instance was suspended.
     * @type {boolean}
     * @memberof CreateVirtualInstanceRequest
     */
    enable_remount_on_resume?: boolean;
    /**
     * Virtual Instance Class. Use `MO_IL` for Memory Optimized and `GP_IL` for General Purpose instance class.
     * @type {string}
     * @memberof CreateVirtualInstanceRequest
     */
    instance_class?: CreateVirtualInstanceRequest.InstanceClassEnum;
    /**
     * DEPRECATED. Use `mount_type` instead. Number of seconds between data refreshes for mounts on this Virtual Instance. The only valid values are 0 and null. 0 means the data will be refreshed continuously and null means the data will never refresh.
     * @type {number}
     * @memberof CreateVirtualInstanceRequest
     */
    mount_refresh_interval_seconds?: number;
    /**
     * The mount type of collections that this Virtual Instance will query. Live mounted collections stay up-to-date with the underlying collection in real-time. Static mounted collections do not stay up-to-date. See https://docs.rockset.com/documentation/docs/using-virtual-instances#virtual-instance-configuration
     * @type {string}
     * @memberof CreateVirtualInstanceRequest
     */
    mount_type?: CreateVirtualInstanceRequest.MountTypeEnum;
    /**
     * Unique identifier for virtual instance, can contain alphanumeric or dash characters.
     * @type {string}
     * @memberof CreateVirtualInstanceRequest
     */
    name: string;
    /**
     * Requested virtual instance type.
     * @type {string}
     * @memberof CreateVirtualInstanceRequest
     */
    type?: CreateVirtualInstanceRequest.TypeEnum;
}

/**
 * @export
 * @namespace CreateVirtualInstanceRequest
 */
export namespace CreateVirtualInstanceRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum InstanceClassEnum {
        MOIL = <any> 'MO_IL',
        GPIL = <any> 'GP_IL'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum MountTypeEnum {
        LIVE = <any> 'LIVE',
        STATIC = <any> 'STATIC'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        FREE = <any> 'FREE',
        NANO = <any> 'NANO',
        SHARED = <any> 'SHARED',
        MILLI = <any> 'MILLI',
        XSMALL = <any> 'XSMALL',
        SMALL = <any> 'SMALL',
        MEDIUM = <any> 'MEDIUM',
        LARGE = <any> 'LARGE',
        XLARGE = <any> 'XLARGE',
        XLARGE2 = <any> 'XLARGE2',
        XLARGE4 = <any> 'XLARGE4',
        XLARGE8 = <any> 'XLARGE8',
        XLARGE16 = <any> 'XLARGE16'
    }
}

/**
 * 
 * @export
 * @interface CreateVirtualInstanceResponse
 */
export interface CreateVirtualInstanceResponse {
    /**
     * Virtual instance object.
     * @type {VirtualInstance}
     * @memberof CreateVirtualInstanceResponse
     */
    data?: VirtualInstance;
}

/**
 * 
 * @export
 * @interface CreateWorkspaceRequest
 */
export interface CreateWorkspaceRequest {
    /**
     * Longer explanation for the workspace.
     * @type {string}
     * @memberof CreateWorkspaceRequest
     */
    description?: string;
    /**
     * Descriptive label and unique identifier.
     * @type {string}
     * @memberof CreateWorkspaceRequest
     */
    name: string;
}

/**
 * 
 * @export
 * @interface CreateWorkspaceResponse
 */
export interface CreateWorkspaceResponse {
    /**
     * The workspace that was created.
     * @type {Workspace}
     * @memberof CreateWorkspaceResponse
     */
    data?: Workspace;
}

/**
 * 
 * @export
 * @interface CsvParams
 */
export interface CsvParams {
    /**
     * Names of columns.
     * @type {Array<string>}
     * @memberof CsvParams
     */
    columnNames?: Array<string>;
    /**
     * Names of columns.
     * @type {Array<string>}
     * @memberof CsvParams
     */
    columnTypes?: Array<CsvParams.ColumnTypesEnum>;
    /**
     * One of: UTF-8, ISO_8859_1, UTF-16.
     * @type {string}
     * @memberof CsvParams
     */
    encoding?: string;
    /**
     * escape character removes any special meaning from the following character,default is '\\'
     * @type {string}
     * @memberof CsvParams
     */
    escapeChar?: string;
    /**
     * If the first line in every object specifies the column names.
     * @type {boolean}
     * @memberof CsvParams
     */
    firstLineAsColumnNames?: boolean;
    /**
     * character within which a cell value is enclosed,null character if no such character, default is '\"'
     * @type {string}
     * @memberof CsvParams
     */
    quoteChar?: string;
    /**
     * A single character that is the column separator.
     * @type {string}
     * @memberof CsvParams
     */
    separator?: string;
}

/**
 * @export
 * @namespace CsvParams
 */
export namespace CsvParams {
    /**
     * @export
     * @enum {string}
     */
    export enum ColumnTypesEnum {
        UNKNOWN = <any> 'UNKNOWN',
        BOOLEAN = <any> 'BOOLEAN',
        BOOL = <any> 'BOOL',
        INTEGER = <any> 'INTEGER',
        INT = <any> 'INT',
        FLOAT = <any> 'FLOAT',
        TIME = <any> 'TIME',
        DATE = <any> 'DATE',
        DATETIME = <any> 'DATETIME',
        TIMESTAMP = <any> 'TIMESTAMP',
        STRING = <any> 'STRING'
    }
}

/**
 * 
 * @export
 * @interface DeleteAliasResponse
 */
export interface DeleteAliasResponse {
    /**
     * Alias that was deleted.
     * @type {Alias}
     * @memberof DeleteAliasResponse
     */
    data?: Alias;
}

/**
 * 
 * @export
 * @interface DeleteApiKeyResponse
 */
export interface DeleteApiKeyResponse {
    /**
     * The API key that was deleted.
     * @type {ApiKey}
     * @memberof DeleteApiKeyResponse
     */
    data?: ApiKey;
}

/**
 * 
 * @export
 * @interface DeleteCollectionResponse
 */
export interface DeleteCollectionResponse {
    /**
     * Collection that was deleted.
     * @type {Collection}
     * @memberof DeleteCollectionResponse
     */
    data?: Collection;
}

/**
 * 
 * @export
 * @interface DeleteDocumentsRequest
 */
export interface DeleteDocumentsRequest {
    /**
     * Array of IDs of documents to be deleted.
     * @type {Array<DeleteDocumentsRequestData>}
     * @memberof DeleteDocumentsRequest
     */
    data: Array<DeleteDocumentsRequestData>;
}

/**
 * 
 * @export
 * @interface DeleteDocumentsRequestData
 */
export interface DeleteDocumentsRequestData {
    /**
     * Unique document ID.
     * @type {string}
     * @memberof DeleteDocumentsRequestData
     */
    _id: string;
}

/**
 * 
 * @export
 * @interface DeleteDocumentsResponse
 */
export interface DeleteDocumentsResponse {
    /**
     * Information about deleted documents.
     * @type {Array<DocumentStatus>}
     * @memberof DeleteDocumentsResponse
     */
    data?: Array<DocumentStatus>;
    /**
     * A string representing the collection offset after completing the deletes.
     * @type {string}
     * @memberof DeleteDocumentsResponse
     */
    last_offset?: string;
}

/**
 * 
 * @export
 * @interface DeleteIntegrationResponse
 */
export interface DeleteIntegrationResponse {
    /**
     * Integration object that was deleted.
     * @type {Integration}
     * @memberof DeleteIntegrationResponse
     */
    data?: Integration;
}

/**
 * 
 * @export
 * @interface DeleteQueryLambdaResponse
 */
export interface DeleteQueryLambdaResponse {
    /**
     * Query Lambda details.
     * @type {QueryLambda}
     * @memberof DeleteQueryLambdaResponse
     */
    data?: QueryLambda;
}

/**
 * 
 * @export
 * @interface DeleteSourceResponse
 */
export interface DeleteSourceResponse {
    /**
     * source that was deleted
     * @type {Source}
     * @memberof DeleteSourceResponse
     */
    data?: Source;
}

/**
 * 
 * @export
 * @interface DeleteUserResponse
 */
export interface DeleteUserResponse {
    /**
     * User object that was deleted.
     * @type {User}
     * @memberof DeleteUserResponse
     */
    data?: User;
}

/**
 * 
 * @export
 * @interface DeleteViewResponse
 */
export interface DeleteViewResponse {
    /**
     * View that was deleted.
     * @type {View}
     * @memberof DeleteViewResponse
     */
    data?: View;
}

/**
 * 
 * @export
 * @interface DeleteVirtualInstanceResponse
 */
export interface DeleteVirtualInstanceResponse {
    /**
     * Virtual instance that was deleted.
     * @type {VirtualInstance}
     * @memberof DeleteVirtualInstanceResponse
     */
    data?: VirtualInstance;
}

/**
 * 
 * @export
 * @interface DeleteWorkspaceResponse
 */
export interface DeleteWorkspaceResponse {
    /**
     * The workspace that was deleted.
     * @type {Workspace}
     * @memberof DeleteWorkspaceResponse
     */
    data?: Workspace;
}

/**
 * 
 * @export
 * @interface DeploymentSettings
 */
export interface DeploymentSettings {
    /**
     * RRN of the Virtual Instance that all queries will be routed to by default
     * @type {VirtualInstanceRrn}
     * @memberof DeploymentSettings
     */
    default_query_vi?: VirtualInstanceRrn;
}

/**
 * 
 * @export
 * @interface DeploymentSettingsResponse
 */
export interface DeploymentSettingsResponse {
    /**
     * Deployment settings
     * @type {DeploymentSettings}
     * @memberof DeploymentSettingsResponse
     */
    data?: DeploymentSettings;
}

/**
 * 
 * @export
 * @interface DocumentStatus
 */
export interface DocumentStatus {
    /**
     * Collection name.
     * @type {string}
     * @memberof DocumentStatus
     */
    _collection?: string;
    /**
     * Unique document ID.
     * @type {string}
     * @memberof DocumentStatus
     */
    _id?: string;
    /**
     * Error message, if any.
     * @type {ErrorModel}
     * @memberof DocumentStatus
     */
    error?: ErrorModel;
    /**
     * Unique id used to represent each patch request.
     * @type {string}
     * @memberof DocumentStatus
     */
    patch_id?: string;
    /**
     * Status of the document.
     * @type {string}
     * @memberof DocumentStatus
     */
    status?: DocumentStatus.StatusEnum;
}

/**
 * @export
 * @namespace DocumentStatus
 */
export namespace DocumentStatus {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        ADDED = <any> 'ADDED',
        REPLACED = <any> 'REPLACED',
        DELETED = <any> 'DELETED',
        PATCHED = <any> 'PATCHED',
        ERROR = <any> 'ERROR'
    }
}

/**
 * 
 * @export
 * @interface DynamodbIntegration
 */
export interface DynamodbIntegration {
    /**
     * Credentials for an AWS access key integration.
     * @type {AwsAccessKey}
     * @memberof DynamodbIntegration
     */
    aws_access_key?: AwsAccessKey;
    /**
     * Role used for external id type authentication.
     * @type {AwsRole}
     * @memberof DynamodbIntegration
     */
    aws_role?: AwsRole;
    /**
     * S3 bucket used for export during collection initial dump.
     * @type {string}
     * @memberof DynamodbIntegration
     */
    s3_export_bucket_name?: string;
}

/**
 * Describes details about an error
 * @export
 * @interface ErrorModel
 */
export interface ErrorModel {
    /**
     * Column where the error happened (if applicable).
     * @type {number}
     * @memberof ErrorModel
     */
    column?: number;
    /**
     * ID of the error.
     * @type {string}
     * @memberof ErrorModel
     */
    error_id?: string;
    /**
     * Line where the error happened (if applicable).
     * @type {number}
     * @memberof ErrorModel
     */
    line?: number;
    /**
     * Descriptive message about the error.
     * @type {string}
     * @memberof ErrorModel
     */
    message?: string;
    /**
     * ID of the query (if applicable).
     * @type {string}
     * @memberof ErrorModel
     */
    query_id?: string;
    /**
     * Internal trace ID to help with debugging.
     * @type {string}
     * @memberof ErrorModel
     */
    trace_id?: string;
    /**
     * Category of the error.
     * @type {string}
     * @memberof ErrorModel
     */
    type?: ErrorModel.TypeEnum;
}

/**
 * @export
 * @namespace ErrorModel
 */
export namespace ErrorModel {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        AUTHEXCEPTION = <any> 'AUTHEXCEPTION',
        VERSIONEXCEPTION = <any> 'VERSIONEXCEPTION',
        INTERNALERROR = <any> 'INTERNALERROR',
        INVALIDINPUT = <any> 'INVALIDINPUT',
        NOTIMPLEMENTEDYET = <any> 'NOTIMPLEMENTEDYET',
        RESOURCEEXCEEDED = <any> 'RESOURCEEXCEEDED',
        ALREADYEXISTS = <any> 'ALREADYEXISTS',
        METHODNOTALLOWED = <any> 'METHODNOTALLOWED',
        NOTACCEPTABLE = <any> 'NOTACCEPTABLE',
        UNSUPPORTEDMEDIATYPE = <any> 'UNSUPPORTEDMEDIATYPE',
        NOTFOUND = <any> 'NOTFOUND',
        DEPENDENTRESOURCES = <any> 'DEPENDENTRESOURCES',
        QUERYERROR = <any> 'QUERY_ERROR',
        NOTREADY = <any> 'NOT_READY',
        FORBIDDEN = <any> 'FORBIDDEN',
        QUERYTIMEOUT = <any> 'QUERY_TIMEOUT',
        CONNECTIONERROR = <any> 'CONNECTION_ERROR',
        CONTENTTOOLARGE = <any> 'CONTENTTOOLARGE',
        CREATING = <any> 'CREATING',
        BADREQUEST = <any> 'BADREQUEST',
        SERVICEUNAVAILABLE = <any> 'SERVICEUNAVAILABLE',
        CONFLICT = <any> 'CONFLICT',
        RATELIMITEXCEEDED = <any> 'RATELIMITEXCEEDED',
        QUERYCANCELLED = <any> 'QUERY_CANCELLED',
        CLIENTCONNECTIONERROR = <any> 'CLIENT_CONNECTION_ERROR'
    }
}

/**
 * 
 * @export
 * @interface EventTimeInfo
 */
export interface EventTimeInfo {
    /**
     * Name of the field containing event time.
     * @type {string}
     * @memberof EventTimeInfo
     */
    field: string;
    /**
     * Format of time field, can be one of: milliseconds_since_epoch, seconds_since_epoch.
     * @type {string}
     * @memberof EventTimeInfo
     */
    format?: string;
    /**
     * Default time zone, in standard IANA format.
     * @type {string}
     * @memberof EventTimeInfo
     */
    time_zone?: string;
}

/**
 * 
 * @export
 * @interface ExecutePublicQueryLambdaRequest
 */
export interface ExecutePublicQueryLambdaRequest {
    /**
     * Row limit to use if no limit specified in the SQL query text.
     * @type {number}
     * @memberof ExecutePublicQueryLambdaRequest
     */
    default_row_limit?: number;
    /**
     * List of named parameters.
     * @type {Array<QueryParameter>}
     * @memberof ExecutePublicQueryLambdaRequest
     */
    parameters?: Array<QueryParameter>;
}

/**
 * 
 * @export
 * @interface ExecuteQueryLambdaRequest
 */
export interface ExecuteQueryLambdaRequest {
    /**
     * If true, the query will run asynchronously for up to 30 minutes. The query request will immediately return with a query id that can be used to retrieve the query status and results. If false or not specified, the query will return with results once completed or timeout after 2 minutes. (To return results directly for shorter queries while still allowing a timeout of up to 30 minutes, set `async_options.client_timeout_ms`.) 
     * @type {boolean}
     * @memberof ExecuteQueryLambdaRequest
     */
    async?: boolean;
    /**
     * Options for configuring Asynchronous Query Mode.
     * @type {AsyncQueryOptions}
     * @memberof ExecuteQueryLambdaRequest
     */
    async_options?: AsyncQueryOptions;
    /**
     * If query execution takes longer than this value, debug information will be logged. If the query text includes the DEBUG hint and this parameter is also provided, only this value will be used and the DEBUG hint will be ignored.
     * @type {number}
     * @memberof ExecuteQueryLambdaRequest
     */
    debug_threshold_ms?: number;
    /**
     * Row limit to use if no limit specified in the SQL query text.
     * @type {number}
     * @memberof ExecuteQueryLambdaRequest
     */
    default_row_limit?: number;
    /**
     * [DEPRECATED] Use `max_initial_results` instead. Number of documents to return in addition to paginating for this query call. Only relevant if `paginate` flag is also set.
     * @type {number}
     * @memberof ExecuteQueryLambdaRequest
     */
    initial_paginate_response_doc_count?: number;
    /**
     * This limits the maximum number of results in the initial response. A pagination cursor is returned if the number of results exceeds `max_initial_results`. If `max_initial_results` is not set, all results will be returned in the initial response up to 4 million. If `max_initial_results` is set, the value must be between 0 and 100,000. If the query is async and `client_timeout_ms` is exceeded, `max_initial_results` does not apply since none of the results will be returned with the initial response.
     * @type {number}
     * @memberof ExecuteQueryLambdaRequest
     */
    max_initial_results?: number;
    /**
     * Flag to paginate and store the results of this query for later / sequential retrieval.
     * @type {boolean}
     * @memberof ExecuteQueryLambdaRequest
     */
    paginate?: boolean;
    /**
     * List of named parameters.
     * @type {Array<QueryParameter>}
     * @memberof ExecuteQueryLambdaRequest
     */
    parameters?: Array<QueryParameter>;
    /**
     * If a query exceeds the specified timeout, the query will automatically stop and return an error. The query timeout defaults to a maximum of 2 minutes. If `async` is true, the query timeout defaults to a maximum of 30 minutes.
     * @type {number}
     * @memberof ExecuteQueryLambdaRequest
     */
    timeout_ms?: number;
    /**
     * Virtual instance on which to run the query.
     * @type {string}
     * @memberof ExecuteQueryLambdaRequest
     */
    virtual_instance_id?: string;
}

/**
 * 
 * @export
 * @interface ExecutionStatus
 */
export interface ExecutionStatus {
    /**
     * Message describing the execution status.
     * @type {string}
     * @memberof ExecutionStatus
     */
    message?: string;
    /**
     * The scheduled query lambda execution status
     * @type {string}
     * @memberof ExecutionStatus
     */
    state?: ExecutionStatus.StateEnum;
}

/**
 * @export
 * @namespace ExecutionStatus
 */
export namespace ExecutionStatus {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        WARNING = <any> 'WARNING',
        ERROR = <any> 'ERROR'
    }
}

/**
 * 
 * @export
 * @interface FieldMappingQuery
 */
export interface FieldMappingQuery {
    /**
     * SELECT * EXCEPT (name), SHA256(name) AS name_anon FROM _input.
     * @type {string}
     * @memberof FieldMappingQuery
     */
    sql?: string;
}

/**
 * 
 * @export
 * @interface FieldMappingV2
 */
export interface FieldMappingV2 {
    /**
     * A List of InputField for this mapping.
     * @type {Array<InputField>}
     * @memberof FieldMappingV2
     */
    input_fields?: Array<InputField>;
    /**
     * A boolean that determines whether to drop all fields in this document. If set, input and output fields should not be set
     * @type {boolean}
     * @memberof FieldMappingV2
     */
    is_drop_all_fields?: boolean;
    /**
     * A user specified string that is a name for this mapping.
     * @type {string}
     * @memberof FieldMappingV2
     */
    name?: string;
    /**
     * An OutputField for this mapping.
     * @type {OutputField}
     * @memberof FieldMappingV2
     */
    output_field?: OutputField;
}

/**
 * 
 * @export
 * @interface FieldPartition
 */
export interface FieldPartition {
    /**
     * The name of a field, parsed as a SQL qualified name.
     * @type {string}
     * @memberof FieldPartition
     */
    field_name?: string;
    /**
     * The values for partitioning of a field. Unneeded if the partition type is AUTO.
     * @type {Array<string>}
     * @memberof FieldPartition
     */
    keys?: Array<string>;
    /**
     * The type of partitions on a field.
     * @type {string}
     * @memberof FieldPartition
     */
    type?: FieldPartition.TypeEnum;
}

/**
 * @export
 * @namespace FieldPartition
 */
export namespace FieldPartition {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        AUTO = <any> 'AUTO'
    }
}

/**
 * 
 * @export
 * @interface FormatParams
 */
export interface FormatParams {
    /**
     * 
     * @type {AvroParams}
     * @memberof FormatParams
     */
    avro?: AvroParams;
    /**
     * 
     * @type {boolean}
     * @memberof FormatParams
     */
    bson?: boolean;
    /**
     * 
     * @type {CsvParams}
     * @memberof FormatParams
     */
    csv?: CsvParams;
    /**
     * Source data is in json format.
     * @type {boolean}
     * @memberof FormatParams
     */
    json?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FormatParams
     */
    mssql_dms?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FormatParams
     */
    mysql_dms?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FormatParams
     */
    oracle_dms?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FormatParams
     */
    postgres_dms?: boolean;
    /**
     * 
     * @type {XmlParams}
     * @memberof FormatParams
     */
    xml?: XmlParams;
}

/**
 * 
 * @export
 * @interface GcpServiceAccount
 */
export interface GcpServiceAccount {
    /**
     * Contents of JSON Service Account key file.
     * @type {string}
     * @memberof GcpServiceAccount
     */
    service_account_key_file_json: string;
}

/**
 * 
 * @export
 * @interface GcsIntegration
 */
export interface GcsIntegration {
    /**
     * Credentials for an GCP key integration.
     * @type {GcpServiceAccount}
     * @memberof GcsIntegration
     */
    gcp_service_account?: GcpServiceAccount;
}

/**
 * 
 * @export
 * @interface GetAliasResponse
 */
export interface GetAliasResponse {
    /**
     * Alias that was requested.
     * @type {Alias}
     * @memberof GetAliasResponse
     */
    data?: Alias;
}

/**
 * 
 * @export
 * @interface GetApiKeyResponse
 */
export interface GetApiKeyResponse {
    /**
     * The requested API key object.
     * @type {ApiKey}
     * @memberof GetApiKeyResponse
     */
    data?: ApiKey;
}

/**
 * 
 * @export
 * @interface GetCollectionCommit
 */
export interface GetCollectionCommit {
    /**
     * 
     * @type {GetCollectionCommitData}
     * @memberof GetCollectionCommit
     */
    data?: GetCollectionCommitData;
    /**
     * 
     * @type {Offsets}
     * @memberof GetCollectionCommit
     */
    offsets?: Offsets;
}

/**
 * 
 * @export
 * @interface GetCollectionCommitData
 */
export interface GetCollectionCommitData {
    /**
     * The max offset passed in the request which is the latest offset that was compared to the commit.
     * @type {string}
     * @memberof GetCollectionCommitData
     */
    fence?: string;
    /**
     * True if all the data in the offsets are available to be queried. False if one or more of the offsets is still behind the request offsets.
     * @type {boolean}
     * @memberof GetCollectionCommitData
     */
    passed?: boolean;
}

/**
 * 
 * @export
 * @interface GetCollectionCommitRequest
 */
export interface GetCollectionCommitRequest {
    /**
     * a list of zero or more collection offset fences
     * @type {Array<string>}
     * @memberof GetCollectionCommitRequest
     */
    name?: Array<string>;
}

/**
 * 
 * @export
 * @interface GetCollectionResponse
 */
export interface GetCollectionResponse {
    /**
     * Collection that was requested.
     * @type {Collection}
     * @memberof GetCollectionResponse
     */
    data?: Collection;
}

/**
 * 
 * @export
 * @interface GetIntegrationResponse
 */
export interface GetIntegrationResponse {
    /**
     * Integration object.
     * @type {Integration}
     * @memberof GetIntegrationResponse
     */
    data?: Integration;
}

/**
 * 
 * @export
 * @interface GetQueryResponse
 */
export interface GetQueryResponse {
    /**
     * 
     * @type {QueryInfo}
     * @memberof GetQueryResponse
     */
    data?: QueryInfo;
}

/**
 * 
 * @export
 * @interface GetSourceResponse
 */
export interface GetSourceResponse {
    /**
     * source config for source
     * @type {Source}
     * @memberof GetSourceResponse
     */
    data?: Source;
}

/**
 * 
 * @export
 * @interface GetViewResponse
 */
export interface GetViewResponse {
    /**
     * View that was requested.
     * @type {View}
     * @memberof GetViewResponse
     */
    data?: View;
}

/**
 * 
 * @export
 * @interface GetVirtualInstanceResponse
 */
export interface GetVirtualInstanceResponse {
    /**
     * Virtual instance that was requested.
     * @type {VirtualInstance}
     * @memberof GetVirtualInstanceResponse
     */
    data?: VirtualInstance;
}

/**
 * 
 * @export
 * @interface GetWorkspaceResponse
 */
export interface GetWorkspaceResponse {
    /**
     * The workspace that was requested.
     * @type {Workspace}
     * @memberof GetWorkspaceResponse
     */
    data?: Workspace;
}

/**
 * 
 * @export
 * @interface InputField
 */
export interface InputField {
    /**
     * The name of a field, parsed as a SQL qualified name.
     * @type {string}
     * @memberof InputField
     */
    field_name?: string;
    /**
     * Define the behaviour if fieldName is missing or is null.
     * @type {string}
     * @memberof InputField
     */
    if_missing?: InputField.IfMissingEnum;
    /**
     * If true, then drop fieldName from the document.
     * @type {boolean}
     * @memberof InputField
     */
    is_drop?: boolean;
    /**
     * Sql parameter name.
     * @type {string}
     * @memberof InputField
     */
    param?: string;
}

/**
 * @export
 * @namespace InputField
 */
export namespace InputField {
    /**
     * @export
     * @enum {string}
     */
    export enum IfMissingEnum {
        SKIP = <any> 'SKIP',
        PASS = <any> 'PASS'
    }
}

/**
 * Integrations that can be associated with data sources to create collections. Only one type of integration may be specified.
 * @export
 * @interface Integration
 */
export interface Integration {
    /**
     * Azure Blob Storage details.
     * @type {AzureBlobStorageIntegration}
     * @memberof Integration
     */
    azure_blob_storage?: AzureBlobStorageIntegration;
    /**
     * Azure Event Hubs details.
     * @type {AzureEventHubsIntegration}
     * @memberof Integration
     */
    azure_event_hubs?: AzureEventHubsIntegration;
    /**
     * Azure Service Bus details.
     * @type {AzureServiceBusIntegration}
     * @memberof Integration
     */
    azure_service_bus?: AzureServiceBusIntegration;
    /**
     * List of collections that use the integration.
     * @type {Array<Collection>}
     * @memberof Integration
     */
    collections?: Array<Collection>;
    /**
     * ISO-8601 date.
     * @type {string}
     * @memberof Integration
     */
    created_at?: string;
    /**
     * Email of user who created the integration.
     * @type {string}
     * @memberof Integration
     */
    created_by: string;
    /**
     * Name of the API key that was used to create this object if one was used.
     * @type {string}
     * @memberof Integration
     */
    created_by_apikey_name?: string;
    /**
     * Longer explanation for the integration.
     * @type {string}
     * @memberof Integration
     */
    description?: string;
    /**
     * Amazon DynamoDB details, must have one of aws_access_key or aws_role.
     * @type {DynamodbIntegration}
     * @memberof Integration
     */
    dynamodb?: DynamodbIntegration;
    /**
     * GCS details.
     * @type {GcsIntegration}
     * @memberof Integration
     */
    gcs?: GcsIntegration;
    /**
     * is write access enabled for this integration
     * @type {boolean}
     * @memberof Integration
     */
    is_write_enabled?: boolean;
    /**
     * Kafka details.
     * @type {KafkaIntegration}
     * @memberof Integration
     */
    kafka?: KafkaIntegration;
    /**
     * Amazon Kinesis details, must have one of aws_access_key or aws_role.
     * @type {KinesisIntegration}
     * @memberof Integration
     */
    kinesis?: KinesisIntegration;
    /**
     * MongoDb details.
     * @type {MongoDbIntegration}
     * @memberof Integration
     */
    mongodb?: MongoDbIntegration;
    /**
     * Descriptive label and unique identifier.
     * @type {string}
     * @memberof Integration
     */
    name: string;
    /**
     * User that owns this integration.
     * @type {string}
     * @memberof Integration
     */
    owner_email?: string;
    /**
     * Amazon S3 details, must have one of aws_access_key or aws_role.
     * @type {S3Integration}
     * @memberof Integration
     */
    s3?: S3Integration;
    /**
     * Snowflake details.
     * @type {SnowflakeIntegration}
     * @memberof Integration
     */
    snowflake?: SnowflakeIntegration;
}

/**
 * 
 * @export
 * @interface KafkaIntegration
 */
export interface KafkaIntegration {
    /**
     * Details of an AWS cross-account role integration.
     * @type {AwsRole}
     * @memberof KafkaIntegration
     */
    aws_role?: AwsRole;
    /**
     * The Kafka bootstrap server url(s). Required only for V3 integration.
     * @type {string}
     * @memberof KafkaIntegration
     */
    bootstrap_servers?: string;
    /**
     * Kafka connection string.
     * @type {string}
     * @memberof KafkaIntegration
     */
    connection_string?: string;
    /**
     * The format of the Kafka topics being tailed.
     * @type {string}
     * @memberof KafkaIntegration
     */
    kafka_data_format?: KafkaIntegration.KafkaDataFormatEnum;
    /**
     * Kafka topics to tail.
     * @type {Array<string>}
     * @memberof KafkaIntegration
     */
    kafka_topic_names?: Array<string>;
    /**
     * Kafka configurations for schema registry.
     * @type {SchemaRegistryConfig}
     * @memberof KafkaIntegration
     */
    schema_registry_config?: SchemaRegistryConfig;
    /**
     * Kafka security configurations.
     * @type {KafkaV3SecurityConfig}
     * @memberof KafkaIntegration
     */
    security_config?: KafkaV3SecurityConfig;
    /**
     * The status of the Kafka source by topic.
     * @type {{ [key: string]: StatusKafka; }}
     * @memberof KafkaIntegration
     */
    source_status_by_topic?: { [key: string]: StatusKafka; };
    /**
     * 
     * @type {boolean}
     * @memberof KafkaIntegration
     */
    use_v3?: boolean;
}

/**
 * @export
 * @namespace KafkaIntegration
 */
export namespace KafkaIntegration {
    /**
     * @export
     * @enum {string}
     */
    export enum KafkaDataFormatEnum {
        JSON = <any> 'JSON',
        AVRO = <any> 'AVRO'
    }
}

/**
 * 
 * @export
 * @interface KafkaV3SecurityConfig
 */
export interface KafkaV3SecurityConfig {
    /**
     * 
     * @type {string}
     * @memberof KafkaV3SecurityConfig
     */
    api_key?: string;
    /**
     * 
     * @type {string}
     * @memberof KafkaV3SecurityConfig
     */
    secret?: string;
}

/**
 * 
 * @export
 * @interface KinesisIntegration
 */
export interface KinesisIntegration {
    /**
     * Credentials for an AWS access key integration.
     * @type {AwsAccessKey}
     * @memberof KinesisIntegration
     */
    aws_access_key?: AwsAccessKey;
    /**
     * Details of an AWS cross-account role integration.
     * @type {AwsRole}
     * @memberof KinesisIntegration
     */
    aws_role?: AwsRole;
}

/**
 * 
 * @export
 * @interface ListAliasesResponse
 */
export interface ListAliasesResponse {
    /**
     * List of all aliases.
     * @type {Array<Alias>}
     * @memberof ListAliasesResponse
     */
    data?: Array<Alias>;
}

/**
 * 
 * @export
 * @interface ListApiKeysResponse
 */
export interface ListApiKeysResponse {
    /**
     * List of API key objects.
     * @type {Array<ApiKey>}
     * @memberof ListApiKeysResponse
     */
    data?: Array<ApiKey>;
}

/**
 * 
 * @export
 * @interface ListCollectionMountsResponse
 */
export interface ListCollectionMountsResponse {
    /**
     * List of all collection mounts.
     * @type {Array<CollectionMount>}
     * @memberof ListCollectionMountsResponse
     */
    data?: Array<CollectionMount>;
}

/**
 * 
 * @export
 * @interface ListCollectionsResponse
 */
export interface ListCollectionsResponse {
    /**
     * List of all collections.
     * @type {Array<Collection>}
     * @memberof ListCollectionsResponse
     */
    data?: Array<Collection>;
}

/**
 * 
 * @export
 * @interface ListIntegrationsResponse
 */
export interface ListIntegrationsResponse {
    /**
     * List of integration objects.
     * @type {Array<Integration>}
     * @memberof ListIntegrationsResponse
     */
    data?: Array<Integration>;
}

/**
 * 
 * @export
 * @interface ListQueriesResponse
 */
export interface ListQueriesResponse {
    /**
     * 
     * @type {Array<QueryInfo>}
     * @memberof ListQueriesResponse
     */
    data?: Array<QueryInfo>;
}

/**
 * 
 * @export
 * @interface ListQueryLambdaTagsResponse
 */
export interface ListQueryLambdaTagsResponse {
    /**
     * List of all tags associated with a Query Lambda.
     * @type {Array<QueryLambdaTag>}
     * @memberof ListQueryLambdaTagsResponse
     */
    data?: Array<QueryLambdaTag>;
}

/**
 * 
 * @export
 * @interface ListQueryLambdaVersionsResponse
 */
export interface ListQueryLambdaVersionsResponse {
    /**
     * List of all versions for a particular Query Lambda.
     * @type {Array<QueryLambdaVersion>}
     * @memberof ListQueryLambdaVersionsResponse
     */
    data?: Array<QueryLambdaVersion>;
}

/**
 * 
 * @export
 * @interface ListQueryLambdasResponse
 */
export interface ListQueryLambdasResponse {
    /**
     * List of all Query Lambdas.
     * @type {Array<QueryLambda>}
     * @memberof ListQueryLambdasResponse
     */
    data?: Array<QueryLambda>;
}

/**
 * 
 * @export
 * @interface ListRolesResponse
 */
export interface ListRolesResponse {
    /**
     * List of all roles.
     * @type {Array<Role>}
     * @memberof ListRolesResponse
     */
    data?: Array<Role>;
}

/**
 * 
 * @export
 * @interface ListSourcesResponse
 */
export interface ListSourcesResponse {
    /**
     * List of all sources in a collection
     * @type {Array<Source>}
     * @memberof ListSourcesResponse
     */
    data?: Array<Source>;
}

/**
 * 
 * @export
 * @interface ListUnsubscribePreferencesResponse
 */
export interface ListUnsubscribePreferencesResponse {
    /**
     * List of notification preferences.
     * @type {Array<UnsubscribePreference>}
     * @memberof ListUnsubscribePreferencesResponse
     */
    data?: Array<UnsubscribePreference>;
}

/**
 * 
 * @export
 * @interface ListUsersResponse
 */
export interface ListUsersResponse {
    /**
     * List of users.
     * @type {Array<User>}
     * @memberof ListUsersResponse
     */
    data?: Array<User>;
}

/**
 * 
 * @export
 * @interface ListViewsResponse
 */
export interface ListViewsResponse {
    /**
     * List of all views.
     * @type {Array<View>}
     * @memberof ListViewsResponse
     */
    data?: Array<View>;
}

/**
 * 
 * @export
 * @interface ListVirtualInstancesResponse
 */
export interface ListVirtualInstancesResponse {
    /**
     * List of all virtual instances.
     * @type {Array<VirtualInstance>}
     * @memberof ListVirtualInstancesResponse
     */
    data?: Array<VirtualInstance>;
}

/**
 * 
 * @export
 * @interface ListWorkspacesResponse
 */
export interface ListWorkspacesResponse {
    /**
     * List of workspaces.
     * @type {Array<Workspace>}
     * @memberof ListWorkspacesResponse
     */
    data?: Array<Workspace>;
}

/**
 * 
 * @export
 * @interface MongoDbIntegration
 */
export interface MongoDbIntegration {
    /**
     * MongoDB connection URI string.
     * @type {string}
     * @memberof MongoDbIntegration
     */
    connection_uri: string;
    /**
     * TLS configuration for mongo connection
     * @type {TLSConfig}
     * @memberof MongoDbIntegration
     */
    tls?: TLSConfig;
}

/**
 * 
 * @export
 * @interface Offsets
 */
export interface Offsets {
    /**
     * An encoded value representing the most recent offsets that have been committed. If the fence offset is less than or equal to the commit, then passed is true.
     * @type {string}
     * @memberof Offsets
     */
    commit?: string;
}

/**
 * An organization in Rockset is a container for users and collections.
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * List of clusters associated with this org.
     * @type {Array<Cluster>}
     * @memberof Organization
     */
    clusters?: Array<Cluster>;
    /**
     * ISO-8601 date.
     * @type {string}
     * @memberof Organization
     */
    created_at?: string;
    /**
     * Name of the organization.
     * @type {string}
     * @memberof Organization
     */
    display_name?: string;
    /**
     * Organization's unique external ID within Rockset.
     * @type {string}
     * @memberof Organization
     */
    external_id?: string;
    /**
     * Unique identifier for the organization.
     * @type {string}
     * @memberof Organization
     */
    id?: string;
    /**
     * Rockset's global AWS user.
     * @type {string}
     * @memberof Organization
     */
    rockset_user?: string;
    /**
     * Connection name of SSO connection.
     * @type {string}
     * @memberof Organization
     */
    sso_connection?: string;
    /**
     * Whether or not SSO is the only permitted form of auth.
     * @type {boolean}
     * @memberof Organization
     */
    sso_only?: boolean;
}

/**
 * 
 * @export
 * @interface OrganizationResponse
 */
export interface OrganizationResponse {
    /**
     * Organization object.
     * @type {Organization}
     * @memberof OrganizationResponse
     */
    data?: Organization;
}

/**
 * 
 * @export
 * @interface OutputField
 */
export interface OutputField {
    /**
     * The name of a field, parsed as a SQL qualified name.
     * @type {string}
     * @memberof OutputField
     */
    field_name?: string;
    /**
     * Error in Mapping execution: 'skip' or 'fail'.
     * @type {string}
     * @memberof OutputField
     */
    on_error?: OutputField.OnErrorEnum;
    /**
     * The name of a sql function.
     * @type {SqlExpression}
     * @memberof OutputField
     */
    value?: SqlExpression;
}

/**
 * @export
 * @namespace OutputField
 */
export namespace OutputField {
    /**
     * @export
     * @enum {string}
     */
    export enum OnErrorEnum {
        SKIP = <any> 'SKIP',
        FAIL = <any> 'FAIL'
    }
}

/**
 * 
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * Use this cursor to fetch the first page of results for this query.
     * @type {string}
     * @memberof Pagination
     */
    start_cursor?: string;
}

/**
 * 
 * @export
 * @interface PaginationInfo
 */
export interface PaginationInfo {
    /**
     * Number of documents returned in this result set.
     * @type {number}
     * @memberof PaginationInfo
     */
    current_page_doc_count?: number;
    /**
     * Cursor to use to get the list of documents.
     * @type {string}
     * @memberof PaginationInfo
     */
    next_cursor?: string;
    /**
     * The doc offset that next_cursor starts at.
     * @type {number}
     * @memberof PaginationInfo
     */
    next_cursor_offset?: number;
    /**
     * Direct link to the next page of results.
     * @type {string}
     * @memberof PaginationInfo
     */
    next_page_link?: string;
    /**
     * Cursor used to retrieve the first set of documents.
     * @type {string}
     * @memberof PaginationInfo
     */
    start_cursor?: string;
}

/**
 * 
 * @export
 * @interface PatchDocument
 */
export interface PatchDocument {
    /**
     * Unique ID of the document to be patched.
     * @type {string}
     * @memberof PatchDocument
     */
    _id: string;
    /**
     * List of patch operations.
     * @type {Array<PatchOperation>}
     * @memberof PatchDocument
     */
    patch: Array<PatchOperation>;
}

/**
 * 
 * @export
 * @interface PatchDocumentsRequest
 */
export interface PatchDocumentsRequest {
    /**
     * List of patches to be applied.
     * @type {Array<PatchDocument>}
     * @memberof PatchDocumentsRequest
     */
    data: Array<PatchDocument>;
}

/**
 * 
 * @export
 * @interface PatchDocumentsResponse
 */
export interface PatchDocumentsResponse {
    /**
     * 
     * @type {Array<DocumentStatus>}
     * @memberof PatchDocumentsResponse
     */
    data: Array<DocumentStatus>;
    /**
     * A string representing the collection offset after completing the patch.
     * @type {string}
     * @memberof PatchDocumentsResponse
     */
    last_offset?: string;
}

/**
 * 
 * @export
 * @interface PatchOperation
 */
export interface PatchOperation {
    /**
     * [JSON Pointer](https://datatracker.ietf.org/doc/html/rfc6901) referencing a location in the target document. Required for `COPY` and `MOVE` operations.
     * @type {string}
     * @memberof PatchOperation
     */
    from?: string;
    /**
     * [JSON Patch operation](https://datatracker.ietf.org/doc/html/rfc6902#page-4) to be performed in this patch. Case insensitive.
     * @type {string}
     * @memberof PatchOperation
     */
    op: PatchOperation.OpEnum;
    /**
     * [JSON Pointer](https://datatracker.ietf.org/doc/html/rfc6901) referencing a location in the target document where the operation is performed
     * @type {string}
     * @memberof PatchOperation
     */
    path: string;
    /**
     * Value used in the patch operation. Required for `ADD`, `REPLACE`, `TEST`, and `INCREMENT` operations.
     * @type {any}
     * @memberof PatchOperation
     */
    value?: any;
}

/**
 * @export
 * @namespace PatchOperation
 */
export namespace PatchOperation {
    /**
     * @export
     * @enum {string}
     */
    export enum OpEnum {
        ADD = <any> 'ADD',
        REPLACE = <any> 'REPLACE',
        REMOVE = <any> 'REMOVE',
        COPY = <any> 'COPY',
        MOVE = <any> 'MOVE',
        TEST = <any> 'TEST',
        INCREMENT = <any> 'INCREMENT'
    }
}

/**
 * 
 * @export
 * @interface Privilege
 */
export interface Privilege {
    /**
     * The action allowed by this privilege.
     * @type {string}
     * @memberof Privilege
     */
    action?: Privilege.ActionEnum;
    /**
     * Cluster ID (`usw2a1` for us-west-2, `use1a1` for us-east-1, `euc1a1` for eu-central-1) for which the action is allowed. Defaults to '*All*' if not specified.
     * @type {string}
     * @memberof Privilege
     */
    cluster?: string;
    /**
     * The resources on which the action is allowed. Defaults to '*All*' if not specified.
     * @type {string}
     * @memberof Privilege
     */
    resource_name?: string;
}

/**
 * @export
 * @namespace Privilege
 */
export namespace Privilege {
    /**
     * @export
     * @enum {string}
     */
    export enum ActionEnum {
        ALLGLOBALACTIONS = <any> 'ALL_GLOBAL_ACTIONS',
        GETORGGLOBAL = <any> 'GET_ORG_GLOBAL',
        GETCURRENTUSERGLOBAL = <any> 'GET_CURRENT_USER_GLOBAL',
        INVITEUSERGLOBAL = <any> 'INVITE_USER_GLOBAL',
        DELETEUSERGLOBAL = <any> 'DELETE_USER_GLOBAL',
        LISTUSERSGLOBAL = <any> 'LIST_USERS_GLOBAL',
        GETBILLINGGLOBAL = <any> 'GET_BILLING_GLOBAL',
        UPDATEBILLINGGLOBAL = <any> 'UPDATE_BILLING_GLOBAL',
        UPDATESETTINGSGLOBAL = <any> 'UPDATE_SETTINGS_GLOBAL',
        GETMETRICSGLOBAL = <any> 'GET_METRICS_GLOBAL',
        CREATEVIGLOBAL = <any> 'CREATE_VI_GLOBAL',
        UPDATEVIGLOBAL = <any> 'UPDATE_VI_GLOBAL',
        LISTVIGLOBAL = <any> 'LIST_VI_GLOBAL',
        CREATEWSGLOBAL = <any> 'CREATE_WS_GLOBAL',
        LISTWSGLOBAL = <any> 'LIST_WS_GLOBAL',
        CREATEINTEGRATIONGLOBAL = <any> 'CREATE_INTEGRATION_GLOBAL',
        DELETEINTEGRATIONGLOBAL = <any> 'DELETE_INTEGRATION_GLOBAL',
        LISTINTEGRATIONSGLOBAL = <any> 'LIST_INTEGRATIONS_GLOBAL',
        EXPORTDATAGLOBAL = <any> 'EXPORT_DATA_GLOBAL',
        UPDATERESOURCEOWNERGLOBAL = <any> 'UPDATE_RESOURCE_OWNER_GLOBAL',
        CREATEAPIKEYGLOBAL = <any> 'CREATE_API_KEY_GLOBAL',
        CREATEROLEGLOBAL = <any> 'CREATE_ROLE_GLOBAL',
        UPDATEROLEGLOBAL = <any> 'UPDATE_ROLE_GLOBAL',
        DELETEROLEGLOBAL = <any> 'DELETE_ROLE_GLOBAL',
        LISTROLESGLOBAL = <any> 'LIST_ROLES_GLOBAL',
        GRANTREVOKEROLEGLOBAL = <any> 'GRANT_REVOKE_ROLE_GLOBAL',
        CREATEQUERYLOGSCOLLECTIONGLOBAL = <any> 'CREATE_QUERY_LOGS_COLLECTION_GLOBAL',
        CREATEINGESTLOGSCOLLECTIONGLOBAL = <any> 'CREATE_INGEST_LOGS_COLLECTION_GLOBAL',
        ALLINTEGRATIONACTIONS = <any> 'ALL_INTEGRATION_ACTIONS',
        CREATECOLLECTIONINTEGRATION = <any> 'CREATE_COLLECTION_INTEGRATION',
        ALLWORKSPACEACTIONS = <any> 'ALL_WORKSPACE_ACTIONS',
        DELETEWS = <any> 'DELETE_WS',
        QUERYDATAWS = <any> 'QUERY_DATA_WS',
        WRITEDATAWS = <any> 'WRITE_DATA_WS',
        CREATECOLLECTIONWS = <any> 'CREATE_COLLECTION_WS',
        DELETECOLLECTIONWS = <any> 'DELETE_COLLECTION_WS',
        UPDATECOLLECTIONWS = <any> 'UPDATE_COLLECTION_WS',
        CREATEALIASWS = <any> 'CREATE_ALIAS_WS',
        DELETEALIASWS = <any> 'DELETE_ALIAS_WS',
        CREATESNAPSHOTWS = <any> 'CREATE_SNAPSHOT_WS',
        LISTRESOURCESWS = <any> 'LIST_RESOURCES_WS',
        CREATEQUERYLAMBDAWS = <any> 'CREATE_QUERY_LAMBDA_WS',
        DELETEQUERYLAMBDAWS = <any> 'DELETE_QUERY_LAMBDA_WS',
        EXECUTEQUERYLAMBDAWS = <any> 'EXECUTE_QUERY_LAMBDA_WS',
        CREATESCHEDULEDLAMBDAWS = <any> 'CREATE_SCHEDULED_LAMBDA_WS',
        DELETESCHEDULEDLAMBDAWS = <any> 'DELETE_SCHEDULED_LAMBDA_WS',
        CREATEVIEWWS = <any> 'CREATE_VIEW_WS',
        DELETEVIEWWS = <any> 'DELETE_VIEW_WS',
        ALLVIACTIONS = <any> 'ALL_VI_ACTIONS',
        QUERYVI = <any> 'QUERY_VI',
        UPDATEVI = <any> 'UPDATE_VI',
        SUSPENDRESUMEVI = <any> 'SUSPEND_RESUME_VI',
        DELETEVI = <any> 'DELETE_VI',
        CREATESIMILARITYINDEXWS = <any> 'CREATE_SIMILARITY_INDEX_WS',
        DELETESIMILARITYINDEXWS = <any> 'DELETE_SIMILARITY_INDEX_WS',
        CREATENETWORKCONFIGURATIONGLOBAL = <any> 'CREATE_NETWORK_CONFIGURATION_GLOBAL',
        DELETENETWORKCONFIGURATIONGLOBAL = <any> 'DELETE_NETWORK_CONFIGURATION_GLOBAL',
        LISTNETWORKCONFIGURATIONSGLOBAL = <any> 'LIST_NETWORK_CONFIGURATIONS_GLOBAL',
        UPDATEDEPLOYMENTDEFAULTQUERYVI = <any> 'UPDATE_DEPLOYMENT_DEFAULT_QUERY_VI'
    }
}

/**
 * 
 * @export
 * @interface QueryError
 */
export interface QueryError {
    /**
     * A message associated with the error, containing more information about it.
     * @type {string}
     * @memberof QueryError
     */
    message?: string;
    /**
     * The HTTP status code associated with this error, had it been sent as the response status code
     * @type {number}
     * @memberof QueryError
     */
    status_code?: number;
    /**
     * The type of error.
     * @type {string}
     * @memberof QueryError
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface QueryFieldType
 */
export interface QueryFieldType {
    /**
     * Name of the field.
     * @type {string}
     * @memberof QueryFieldType
     */
    name: string;
    /**
     * Data type of the field.
     * @type {string}
     * @memberof QueryFieldType
     */
    type: string;
}

/**
 * 
 * @export
 * @interface QueryInfo
 */
export interface QueryInfo {
    /**
     * User ID who executed the query.
     * @type {string}
     * @memberof QueryInfo
     */
    executed_by?: string;
    /**
     * Time (UTC) that query results expire. Only populated if `status` is `COMPLETE`.
     * @type {string}
     * @memberof QueryInfo
     */
    expires_at?: string;
    /**
     * The log offset that query results were written to in the destination collection. Only populated for INSERT INTO queries.
     * @type {string}
     * @memberof QueryInfo
     */
    last_offset?: string;
    /**
     * Information for fetching query results pages. Only populated if `status` is `COMPLETE`.
     * @type {Pagination}
     * @memberof QueryInfo
     */
    pagination?: Pagination;
    /**
     * Errors encountered while executing the query.
     * @type {Array<QueryError>}
     * @memberof QueryInfo
     */
    query_errors?: Array<QueryError>;
    /**
     * Unique Query ID.
     * @type {string}
     * @memberof QueryInfo
     */
    query_id?: string;
    /**
     * The SQL query for this request
     * @type {string}
     * @memberof QueryInfo
     */
    sql?: string;
    /**
     * Various stats about the query's execution.
     * @type {Stats}
     * @memberof QueryInfo
     */
    stats?: Stats;
    /**
     * Status of the query.
     * @type {string}
     * @memberof QueryInfo
     */
    status?: QueryInfo.StatusEnum;
    /**
     * Time (UTC) the query request was first received and queued for execution.
     * @type {string}
     * @memberof QueryInfo
     */
    submitted_at?: string;
}

/**
 * @export
 * @namespace QueryInfo
 */
export namespace QueryInfo {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        QUEUED = <any> 'QUEUED',
        RUNNING = <any> 'RUNNING',
        COMPLETED = <any> 'COMPLETED',
        ERROR = <any> 'ERROR',
        CANCELLED = <any> 'CANCELLED'
    }
}

/**
 * 
 * @export
 * @interface QueryLambda
 */
export interface QueryLambda {
    /**
     * Collections/aliases queried by underlying SQL query.
     * @type {Array<string>}
     * @memberof QueryLambda
     */
    collections?: Array<string>;
    /**
     * ISO-8601 date of when Query Lambda was last updated.
     * @type {string}
     * @memberof QueryLambda
     */
    last_updated?: string;
    /**
     * User that created this Query Lambda.
     * @type {string}
     * @memberof QueryLambda
     */
    last_updated_by?: string;
    /**
     * Query Lambda version details for most recently created version.
     * @type {QueryLambdaVersion}
     * @memberof QueryLambda
     */
    latest_version?: QueryLambdaVersion;
    /**
     * Query Lambda name.
     * @type {string}
     * @memberof QueryLambda
     */
    name?: string;
    /**
     * Number of Query Lambda versions.
     * @type {number}
     * @memberof QueryLambda
     */
    version_count?: number;
    /**
     * Workspace of this Query Lambda.
     * @type {string}
     * @memberof QueryLambda
     */
    workspace?: string;
}

/**
 * 
 * @export
 * @interface QueryLambdaSql
 */
export interface QueryLambdaSql {
    /**
     * Default parameters for this Query Lambda.
     * @type {Array<QueryParameter>}
     * @memberof QueryLambdaSql
     */
    default_parameters?: Array<QueryParameter>;
    /**
     * SQL text.
     * @type {string}
     * @memberof QueryLambdaSql
     */
    query: string;
}

/**
 * 
 * @export
 * @interface QueryLambdaStats
 */
export interface QueryLambdaStats {
    /**
     * ISO-8601 date.
     * @type {string}
     * @memberof QueryLambdaStats
     */
    last_executed?: string;
    /**
     * User who last executed Query Lambda.
     * @type {string}
     * @memberof QueryLambdaStats
     */
    last_executed_by?: string;
    /**
     * ISO-8601 date of last execution failure.
     * @type {string}
     * @memberof QueryLambdaStats
     */
    last_execution_error?: string;
    /**
     * Error message associated with last failed execution.
     * @type {string}
     * @memberof QueryLambdaStats
     */
    last_execution_error_message?: string;
}

/**
 * 
 * @export
 * @interface QueryLambdaTag
 */
export interface QueryLambdaTag {
    /**
     * Name of Query Lambda tag.
     * @type {string}
     * @memberof QueryLambdaTag
     */
    tag_name?: string;
    /**
     * Query lambda version.
     * @type {QueryLambdaVersion}
     * @memberof QueryLambdaTag
     */
    version?: QueryLambdaVersion;
}

/**
 * 
 * @export
 * @interface QueryLambdaTagResponse
 */
export interface QueryLambdaTagResponse {
    /**
     * Updated Query Lambda tag.
     * @type {QueryLambdaTag}
     * @memberof QueryLambdaTagResponse
     */
    data?: QueryLambdaTag;
}

/**
 * 
 * @export
 * @interface QueryLambdaVersion
 */
export interface QueryLambdaVersion {
    /**
     * Collections queried by underlying SQL query.
     * @type {Array<string>}
     * @memberof QueryLambdaVersion
     */
    collections?: Array<string>;
    /**
     * ISO-8601 date of when Query Lambda was created.
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    created_at?: string;
    /**
     * User that created this Query Lambda.
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    created_by?: string;
    /**
     * Name of the API key that was used to create this object if one was used.
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    created_by_apikey_name?: string;
    /**
     * Optional description.
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    description?: string;
    /**
     * Query Lambda name.
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    name?: string;
    /**
     * Public access ID associated with this QL version
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    public_access_id?: string;
    /**
     * Query Lambda SQL query.
     * @type {QueryLambdaSql}
     * @memberof QueryLambdaVersion
     */
    sql?: QueryLambdaSql;
    /**
     * Status of this Query Lambda.
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    state?: QueryLambdaVersion.StateEnum;
    /**
     * Stats related to this Query Lambda.
     * @type {QueryLambdaStats}
     * @memberof QueryLambdaVersion
     */
    stats?: QueryLambdaStats;
    /**
     * Query Lambda version.
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    version?: string;
    /**
     * Workspace of this Query Lambda.
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    workspace?: string;
}

/**
 * @export
 * @namespace QueryLambdaVersion
 */
export namespace QueryLambdaVersion {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        ACTIVE = <any> 'ACTIVE',
        INVALIDSQL = <any> 'INVALID_SQL'
    }
}

/**
 * 
 * @export
 * @interface QueryLambdaVersionResponse
 */
export interface QueryLambdaVersionResponse {
    /**
     * Query Lambda version details.
     * @type {QueryLambdaVersion}
     * @memberof QueryLambdaVersionResponse
     */
    data?: QueryLambdaVersion;
}

/**
 * 
 * @export
 * @interface QueryPaginationResponse
 */
export interface QueryPaginationResponse {
    /**
     * Pagination metadata.
     * @type {PaginationInfo}
     * @memberof QueryPaginationResponse
     */
    pagination?: PaginationInfo;
    /**
     * List of documents returned by the query.
     * @type {Array<any>}
     * @memberof QueryPaginationResponse
     */
    results?: Array<any>;
    /**
     * Total documents returned by the query.
     * @type {number}
     * @memberof QueryPaginationResponse
     */
    results_total_doc_count?: number;
}

/**
 * 
 * @export
 * @interface QueryParameter
 */
export interface QueryParameter {
    /**
     * Name of the field.
     * @type {string}
     * @memberof QueryParameter
     */
    name: string;
    /**
     * Deprecated. Data type of the field.
     * @type {string}
     * @memberof QueryParameter
     */
    type: string;
    /**
     * Literal value of the field.
     * @type {string}
     * @memberof QueryParameter
     */
    value: string;
}

/**
 * 
 * @export
 * @interface QueryRequest
 */
export interface QueryRequest {
    /**
     * If true, the query will run asynchronously for up to 30 minutes. The query request will immediately return with a query id that can be used to retrieve the query status and results. If false or not specified, the query will return with results once completed or timeout after 2 minutes. (To return results directly for shorter queries while still allowing a timeout of up to 30 minutes, set `async_options.client_timeout_ms`.) 
     * @type {boolean}
     * @memberof QueryRequest
     */
    async?: boolean;
    /**
     * Options for configuring Asynchronous Query Mode.
     * @type {AsyncQueryOptions}
     * @memberof QueryRequest
     */
    async_options?: AsyncQueryOptions;
    /**
     * If query execution takes longer than this value, debug information will be logged. If the query text includes the DEBUG hint and this parameter is also provided, only this value will be used and the DEBUG hint will be ignored.
     * @type {number}
     * @memberof QueryRequest
     */
    debug_threshold_ms?: number;
    /**
     * This limits the maximum number of results in the initial response. A pagination cursor is returned if the number of results exceeds `max_initial_results`. If `max_initial_results` is not set, all results will be returned in the initial response up to 4 million. If `max_initial_results` is set, the value must be between 0 and 100,000. If the query is async and `client_timeout_ms` is exceeded, `max_initial_results` does not apply since none of the results will be returned with the initial response.
     * @type {number}
     * @memberof QueryRequest
     */
    max_initial_results?: number;
    /**
     * Main query request body.
     * @type {QueryRequestSql}
     * @memberof QueryRequest
     */
    sql: QueryRequestSql;
    /**
     * If a query exceeds the specified timeout, the query will automatically stop and return an error. The query timeout defaults to a maximum of 2 minutes. If `async` is true, the query timeout defaults to a maximum of 30 minutes.
     * @type {number}
     * @memberof QueryRequest
     */
    timeout_ms?: number;
}

/**
 * 
 * @export
 * @interface QueryRequestSql
 */
export interface QueryRequestSql {
    /**
     * Row limit to use. Limits specified in the query text will override this default.
     * @type {number}
     * @memberof QueryRequestSql
     */
    default_row_limit?: number;
    /**
     * [DEPRECATED] Use `max_initial_results` instead. Number of documents to return in addition to paginating for this query call. Only relevant if `paginate` flag is also set.
     * @type {number}
     * @memberof QueryRequestSql
     */
    initial_paginate_response_doc_count?: number;
    /**
     * List of named parameters.
     * @type {Array<QueryParameter>}
     * @memberof QueryRequestSql
     */
    parameters?: Array<QueryParameter>;
    /**
     * SQL query string.
     * @type {string}
     * @memberof QueryRequestSql
     */
    query: string;
}

/**
 * 
 * @export
 * @interface QueryResponse
 */
export interface QueryResponse {
    /**
     * List of collections referenced in the query.
     * @type {Array<string>}
     * @memberof QueryResponse
     */
    collections?: Array<string>;
    /**
     * Meta information about each column in the result set. Not populated in `SELECT *` queries.
     * @type {Array<QueryFieldType>}
     * @memberof QueryResponse
     */
    column_fields?: Array<QueryFieldType>;
    /**
     * If this was a write query, this is the log offset the query was written to.
     * @type {string}
     * @memberof QueryResponse
     */
    last_offset?: string;
    /**
     * Pagination information. Only populated if `paginate` is specified in the query request.
     * @type {PaginationInfo}
     * @memberof QueryResponse
     */
    pagination?: PaginationInfo;
    /**
     * Errors encountered while executing the query.
     * @type {Array<QueryError>}
     * @memberof QueryResponse
     */
    query_errors?: Array<QueryError>;
    /**
     * Unique ID for this query.
     * @type {string}
     * @memberof QueryResponse
     */
    query_id?: string;
    /**
     * The full path of the executed query lambda. Includes version information.
     * @type {string}
     * @memberof QueryResponse
     */
    query_lambda_path?: string;
    /**
     * Results from the query.
     * @type {Array<any>}
     * @memberof QueryResponse
     */
    results?: Array<any>;
    /**
     * Number of results generated by the query.
     * @type {number}
     * @memberof QueryResponse
     */
    results_total_doc_count?: number;
    /**
     * Meta information about the query including execution latencies.
     * @type {QueryResponseStats}
     * @memberof QueryResponse
     */
    stats?: QueryResponseStats;
    /**
     * Status of query execution. Possible values: `QUEUED`, `RUNNING`, `COMPLETED`, `ERROR`.
     * @type {string}
     * @memberof QueryResponse
     */
    status?: QueryResponse.StatusEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof QueryResponse
     */
    warnings?: Array<string>;
}

/**
 * @export
 * @namespace QueryResponse
 */
export namespace QueryResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        QUEUED = <any> 'QUEUED',
        RUNNING = <any> 'RUNNING',
        COMPLETED = <any> 'COMPLETED',
        ERROR = <any> 'ERROR'
    }
}

/**
 * 
 * @export
 * @interface QueryResponseStats
 */
export interface QueryResponseStats {
    /**
     * Query time in milliseconds.
     * @type {number}
     * @memberof QueryResponseStats
     */
    elapsed_time_ms?: number;
    /**
     * Time query was throttled by admission control.
     * @type {number}
     * @memberof QueryResponseStats
     */
    throttled_time_micros?: number;
}

/**
 * 
 * @export
 * @interface ResumeVirtualInstanceResponse
 */
export interface ResumeVirtualInstanceResponse {
    /**
     * Virtual instance that was resumed.
     * @type {VirtualInstance}
     * @memberof ResumeVirtualInstanceResponse
     */
    data?: VirtualInstance;
}

/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * ISO-8601 date of when the role was created.
     * @type {string}
     * @memberof Role
     */
    created_at?: string;
    /**
     * Email of the user who created the role.
     * @type {string}
     * @memberof Role
     */
    created_by?: string;
    /**
     * Description for the role.
     * @type {string}
     * @memberof Role
     */
    description?: string;
    /**
     * Email of the user who currently owns the role.
     * @type {string}
     * @memberof Role
     */
    owner_email?: string;
    /**
     * List of privileges associated with the role.
     * @type {Array<Privilege>}
     * @memberof Role
     */
    privileges?: Array<Privilege>;
    /**
     * Unique identifier for the role.
     * @type {string}
     * @memberof Role
     */
    role_name?: string;
}

/**
 * 
 * @export
 * @interface RoleResponse
 */
export interface RoleResponse {
    /**
     * 
     * @type {Role}
     * @memberof RoleResponse
     */
    data?: Role;
}

/**
 * 
 * @export
 * @interface S3Integration
 */
export interface S3Integration {
    /**
     * Credentials for an AWS access key integration.
     * @type {AwsAccessKey}
     * @memberof S3Integration
     */
    aws_access_key?: AwsAccessKey;
    /**
     * Details of an AWS cross-account role integration.
     * @type {AwsRole}
     * @memberof S3Integration
     */
    aws_role?: AwsRole;
}

/**
 * 
 * @export
 * @interface ScheduledLambda
 */
export interface ScheduledLambda {
    /**
     * The UNIX-formatted cron string for this scheduled query lambda.
     * @type {string}
     * @memberof ScheduledLambda
     */
    cron_string?: string;
    /**
     * The number of times this scheduled QL has been executed.
     * @type {number}
     * @memberof ScheduledLambda
     */
    execution_count?: number;
    /**
     * The last time this scheduled query lambda completed successfully.
     * @type {string}
     * @memberof ScheduledLambda
     */
    last_completion_date?: string;
    /**
     * The ID of the query that was triggered by this scheduled lambda's last run.
     * @type {string}
     * @memberof ScheduledLambda
     */
    last_query_id?: string;
    /**
     * The next time this scheduled query lambda will be executed.
     * @type {string}
     * @memberof ScheduledLambda
     */
    next_execution_date?: string;
    /**
     * The name of the associated query lambda.
     * @type {string}
     * @memberof ScheduledLambda
     */
    ql_name?: string;
    /**
     * Query execution status of the scheduled lambda. This field will only be populated when the query execution encounters a warning or error state.
     * @type {ExecutionStatus}
     * @memberof ScheduledLambda
     */
    query_execution_status?: ExecutionStatus;
    /**
     * Boolean flag to allow a scheduled query lambda to resume execution after being suspended due to execution failure. This flag will be unset after scheduled lambda execution.
     * @type {boolean}
     * @memberof ScheduledLambda
     */
    resume_permanent_error?: boolean;
    /**
     * Scheduled Lambda mapping RRN.
     * @type {string}
     * @memberof ScheduledLambda
     */
    rrn?: string;
    /**
     * The query lambda tag.
     * @type {string}
     * @memberof ScheduledLambda
     */
    tag?: string;
    /**
     * The number of times to execute this scheduled query lambda. Once this scheduled query lambda has been executed this many times, it will no longer be executed.
     * @type {number}
     * @memberof ScheduledLambda
     */
    total_times_to_execute?: number;
    /**
     * The version of the associated query lambda.
     * @type {string}
     * @memberof ScheduledLambda
     */
    version?: string;
    /**
     * The payload that should be sent to the webhook.
     * @type {string}
     * @memberof ScheduledLambda
     */
    webhook_payload?: string;
    /**
     * The URL of the webhook that should be triggered after this scheduled query lambda completes.
     * @type {string}
     * @memberof ScheduledLambda
     */
    webhook_url?: string;
    /**
     * Workspace of the associated query lambda.
     * @type {string}
     * @memberof ScheduledLambda
     */
    workspace?: string;
}

/**
 * 
 * @export
 * @interface ScheduledLambdaResponse
 */
export interface ScheduledLambdaResponse {
    /**
     * Scheduled lambda mapping
     * @type {ScheduledLambda}
     * @memberof ScheduledLambdaResponse
     */
    data?: ScheduledLambda;
}

/**
 * 
 * @export
 * @interface SchemaRegistryConfig
 */
export interface SchemaRegistryConfig {
    /**
     * The secure API key for schema registry.
     * @type {string}
     * @memberof SchemaRegistryConfig
     */
    key?: string;
    /**
     * The secure API password registry.
     * @type {string}
     * @memberof SchemaRegistryConfig
     */
    secret?: string;
    /**
     * Schema registry URL.
     * @type {string}
     * @memberof SchemaRegistryConfig
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface SnowflakeIntegration
 */
export interface SnowflakeIntegration {
    /**
     * Credentials for an AWS access key integration.
     * @type {AwsAccessKey}
     * @memberof SnowflakeIntegration
     */
    aws_access_key?: AwsAccessKey;
    /**
     * Details of an AWS cross-account role integration.
     * @type {AwsRole}
     * @memberof SnowflakeIntegration
     */
    aws_role?: AwsRole;
    /**
     * default snowflake data warehouse name for query execution. Warehouse name can be overridden in the collection.
     * @type {string}
     * @memberof SnowflakeIntegration
     */
    default_warehouse: string;
    /**
     * Snowflake database password.
     * @type {string}
     * @memberof SnowflakeIntegration
     */
    password: string;
    /**
     * S3 path used for running 'COPY INTO' command on snowflake table.
     * @type {string}
     * @memberof SnowflakeIntegration
     */
    s3_export_path: string;
    /**
     * Snowflake browser url.
     * @type {string}
     * @memberof SnowflakeIntegration
     */
    snowflake_url: string;
    /**
     * Snowflake user role. If unspecified, will use the default user role.
     * @type {string}
     * @memberof SnowflakeIntegration
     */
    user_role?: string;
    /**
     * Snowflake database username.
     * @type {string}
     * @memberof SnowflakeIntegration
     */
    username: string;
}

/**
 * Details about the data source for the given collection. Only one of the following fields are allowed to be defined. Only collections can act as data sources for views. 
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * Configuration for ingestion from Azure Blob Storage.
     * @type {SourceAzureBlobStorage}
     * @memberof Source
     */
    azure_blob_storage?: SourceAzureBlobStorage;
    /**
     * Configuration for ingestion from Azure Event Hubs.
     * @type {SourceAzureEventHubs}
     * @memberof Source
     */
    azure_event_hubs?: SourceAzureEventHubs;
    /**
     * 
     * @type {SourceAzureServiceBus}
     * @memberof Source
     */
    azure_service_bus?: SourceAzureServiceBus;
    /**
     * Configuration for ingestion from  a dynamodb table.
     * @type {SourceDynamoDb}
     * @memberof Source
     */
    dynamodb?: SourceDynamoDb;
    /**
     * File upload details.
     * @type {SourceFileUpload}
     * @memberof Source
     */
    file_upload?: SourceFileUpload;
    /**
     * Format parameters for data from this source.
     * @type {FormatParams}
     * @memberof Source
     */
    format_params?: FormatParams;
    /**
     * Configuration for ingestion from GCS.
     * @type {SourceGcs}
     * @memberof Source
     */
    gcs?: SourceGcs;
    /**
     * Unique source identifier.
     * @type {string}
     * @memberof Source
     */
    id?: string;
    /**
     * Ingest transformation for a source.
     * @type {FieldMappingQuery}
     * @memberof Source
     */
    ingest_transformation?: FieldMappingQuery;
    /**
     * Name of integration to use.
     * @type {string}
     * @memberof Source
     */
    integration_name?: string;
    /**
     * Kafka collection identifier.
     * @type {SourceKafka}
     * @memberof Source
     */
    kafka?: SourceKafka;
    /**
     * Configuration for ingestion from kinesis stream.
     * @type {SourceKinesis}
     * @memberof Source
     */
    kinesis?: SourceKinesis;
    /**
     * MongoDB collection details.
     * @type {SourceMongoDb}
     * @memberof Source
     */
    mongodb?: SourceMongoDb;
    /**
     * ISO-8601 date when source would be auto resumed, if suspended
     * @type {string}
     * @memberof Source
     */
    resume_at?: string;
    /**
     * Configuration for ingestion from S3.
     * @type {SourceS3}
     * @memberof Source
     */
    s3?: SourceS3;
    /**
     * Configuration for restoring from snapshot.
     * @type {SourceSnapshot}
     * @memberof Source
     */
    snapshot?: SourceSnapshot;
    /**
     * Configuration for ingestion from Snowflake.
     * @type {SourceSnowflake}
     * @memberof Source
     */
    snowflake?: SourceSnowflake;
    /**
     * The ingest status of this source.
     * @type {Status}
     * @memberof Source
     */
    status?: Status;
    /**
     * ISO-8601 date when source was suspended, if suspended
     * @type {string}
     * @memberof Source
     */
    suspended_at?: string;
    /**
     * 
     * @type {SourceSystem}
     * @memberof Source
     */
    system?: SourceSystem;
    /**
     * 
     * @type {SourceWriteApi}
     * @memberof Source
     */
    write_api?: SourceWriteApi;
}

/**
 * 
 * @export
 * @interface SourceAzBlobStorageBase
 */
export interface SourceAzBlobStorageBase {
    /**
     * custom settings for Azure blob Storage source
     * @type {SourceAzBlobStorageSettings}
     * @memberof SourceAzBlobStorageBase
     */
    settings?: SourceAzBlobStorageSettings;
}

/**
 * 
 * @export
 * @interface SourceAzBlobStorageSettings
 */
export interface SourceAzBlobStorageSettings {
    /**
     * Rockset scans an Azure blob Storage container based on a defined time interval. The scan frequency determines the length of time between a new scan and the previous scan. If the previous scan finds new objects or updates to existing objects, Rockset immediately scans the bucket again after processing changes from the previous scan. Duration value is of type ISO 8601 (e.g. PT5H, PT4M, PT3S). It doesn't account for DST, leap seconds and leap years. Minimum value: PT1S. Maximum value: PT1H.
     * @type {string}
     * @memberof SourceAzBlobStorageSettings
     */
    azblob_scan_frequency?: string;
}

/**
 * 
 * @export
 * @interface SourceAzureBlobStorage
 */
export interface SourceAzureBlobStorage {
    /**
     * 
     * @type {number}
     * @memberof SourceAzureBlobStorage
     */
    blob_bytes_total?: number;
    /**
     * 
     * @type {number}
     * @memberof SourceAzureBlobStorage
     */
    blob_count_downloaded?: number;
    /**
     * 
     * @type {number}
     * @memberof SourceAzureBlobStorage
     */
    blob_count_total?: number;
    /**
     * Name of Azure blob Storage container you want to ingest from.
     * @type {string}
     * @memberof SourceAzureBlobStorage
     */
    container?: string;
    /**
     * Glob-style pattern that selects keys to ingest. Only either prefix or pattern can be specified.
     * @type {string}
     * @memberof SourceAzureBlobStorage
     */
    pattern?: string;
    /**
     * Prefix that selects blobs to ingest.
     * @type {string}
     * @memberof SourceAzureBlobStorage
     */
    prefix?: string;
    /**
     * custom settings for Azure blob Storage source
     * @type {SourceAzBlobStorageSettings}
     * @memberof SourceAzureBlobStorage
     */
    settings?: SourceAzBlobStorageSettings;
}

/**
 * 
 * @export
 * @interface SourceAzureEventHubs
 */
export interface SourceAzureEventHubs {
    /**
     * Name of the hub which rockset should ingest from.
     * @type {string}
     * @memberof SourceAzureEventHubs
     */
    hub_id?: string;
    /**
     * The offset reset policy.
     * @type {string}
     * @memberof SourceAzureEventHubs
     */
    offset_reset_policy?: SourceAzureEventHubs.OffsetResetPolicyEnum;
    /**
     * Source status.
     * @type {StatusAzureEventHubs}
     * @memberof SourceAzureEventHubs
     */
    status?: StatusAzureEventHubs;
}

/**
 * @export
 * @namespace SourceAzureEventHubs
 */
export namespace SourceAzureEventHubs {
    /**
     * @export
     * @enum {string}
     */
    export enum OffsetResetPolicyEnum {
        LATEST = <any> 'LATEST',
        EARLIEST = <any> 'EARLIEST'
    }
}

/**
 * 
 * @export
 * @interface SourceAzureServiceBus
 */
export interface SourceAzureServiceBus {
    /**
     * Azure Service bus source status.
     * @type {StatusAzureServiceBus}
     * @memberof SourceAzureServiceBus
     */
    status?: StatusAzureServiceBus;
    /**
     * The subscription to read from the topic.
     * @type {string}
     * @memberof SourceAzureServiceBus
     */
    subscription?: string;
    /**
     * Name of the topic which rockset should ingest from.
     * @type {string}
     * @memberof SourceAzureServiceBus
     */
    topic?: string;
}

/**
 * 
 * @export
 * @interface SourceBase
 */
export interface SourceBase {
    /**
     * Configuration for ingestion from Azure Blob Storage.
     * @type {SourceAzBlobStorageBase}
     * @memberof SourceBase
     */
    azure_blob_storage?: SourceAzBlobStorageBase;
    /**
     * Configuration for ingestion from a DynamoDb table.
     * @type {SourceDynamoDbBase}
     * @memberof SourceBase
     */
    dynamodb?: SourceDynamoDbBase;
    /**
     * Configuration for ingestion from GCS.
     * @type {SourceGcsBase}
     * @memberof SourceBase
     */
    gcs?: SourceGcsBase;
    /**
     * Configuration for ingestion from S3.
     * @type {SourceS3Base}
     * @memberof SourceBase
     */
    s3?: SourceS3Base;
}

/**
 * 
 * @export
 * @interface SourceDynamoDb
 */
export interface SourceDynamoDb {
    /**
     * AWS region name of DynamoDB table, by default us-west-2 is used.
     * @type {string}
     * @memberof SourceDynamoDb
     */
    aws_region?: string;
    /**
     * DynamoDB source status v2.
     * @type {StatusDynamoDbV2}
     * @memberof SourceDynamoDb
     */
    current_status?: StatusDynamoDbV2;
    /**
     * Max RCU usage for scan.
     * @type {number}
     * @memberof SourceDynamoDb
     */
    rcu?: number;
    /**
     * custom settings for Amazon DynamoDB source
     * @type {SourceDynamoDbSettings}
     * @memberof SourceDynamoDb
     */
    settings?: SourceDynamoDbSettings;
    /**
     * DynamoDB source status.
     * @type {StatusDynamoDb}
     * @memberof SourceDynamoDb
     */
    status?: StatusDynamoDb;
    /**
     * Name of DynamoDB table containing data.
     * @type {string}
     * @memberof SourceDynamoDb
     */
    table_name: string;
    /**
     * Whether to use DynamoDB Scan API for the initial scan.
     * @type {boolean}
     * @memberof SourceDynamoDb
     */
    use_scan_api?: boolean;
}

/**
 * 
 * @export
 * @interface SourceDynamoDbBase
 */
export interface SourceDynamoDbBase {
    /**
     * custom settings for Amazon DynamoDB source
     * @type {SourceDynamoDbSettings}
     * @memberof SourceDynamoDbBase
     */
    settings?: SourceDynamoDbSettings;
}

/**
 * 
 * @export
 * @interface SourceDynamoDbSettings
 */
export interface SourceDynamoDbSettings {
    /**
     * Each DynamoDB stream can have one to many shards, and Rockset polls each DynamoDB shard at a fixed rate. Decreasing the duration between polls helps reduce ingest latency, while increasing the duration can prevent  Rockset from keeping up with the updates. If the latency exceeds 24 hours (DynamoDB stream retention duration), Rockset will not be able to process all of the streaming updates. Each request also has a fixed price associated with it. Duration value is of type ISO 8601 (e.g. PT5H, PT4M, PT3S). It doesn't account for DST, leap seconds and leap years. Minimum value: PT0.25S. Maximum value: PT5M.
     * @type {string}
     * @memberof SourceDynamoDbSettings
     */
    dynamodb_stream_poll_frequency?: string;
}

/**
 * 
 * @export
 * @interface SourceFileUpload
 */
export interface SourceFileUpload {
    /**
     * Name of the file.
     * @type {string}
     * @memberof SourceFileUpload
     */
    file_name: string;
    /**
     * Size of the file in bytes.
     * @type {number}
     * @memberof SourceFileUpload
     */
    file_size: number;
    /**
     * Time of file upload.
     * @type {string}
     * @memberof SourceFileUpload
     */
    file_upload_time: string;
}

/**
 * 
 * @export
 * @interface SourceGcs
 */
export interface SourceGcs {
    /**
     * Name of GCS bucket you want to ingest from.
     * @type {string}
     * @memberof SourceGcs
     */
    bucket?: string;
    /**
     * 
     * @type {number}
     * @memberof SourceGcs
     */
    object_bytes_downloaded?: number;
    /**
     * 
     * @type {number}
     * @memberof SourceGcs
     */
    object_bytes_total?: number;
    /**
     * 
     * @type {number}
     * @memberof SourceGcs
     */
    object_count_downloaded?: number;
    /**
     * 
     * @type {number}
     * @memberof SourceGcs
     */
    object_count_total?: number;
    /**
     * Glob-style pattern that selects keys to ingest. Only either prefix or pattern can be specified.
     * @type {string}
     * @memberof SourceGcs
     */
    pattern?: string;
    /**
     * Prefix that selects keys to ingest.
     * @type {string}
     * @memberof SourceGcs
     */
    prefix?: string;
    /**
     * custom settings for Google cloud Storage source
     * @type {SourceGcsSettings}
     * @memberof SourceGcs
     */
    settings?: SourceGcsSettings;
}

/**
 * 
 * @export
 * @interface SourceGcsBase
 */
export interface SourceGcsBase {
    /**
     * custom settings for Google cloud Storage source
     * @type {SourceGcsSettings}
     * @memberof SourceGcsBase
     */
    settings?: SourceGcsSettings;
}

/**
 * 
 * @export
 * @interface SourceGcsSettings
 */
export interface SourceGcsSettings {
    /**
     * Rockset scans a GCS bucket based on a defined time interval. The scan frequency determines the length of time between a new scan and the previous scan. If the previous scan finds new objects or updates to existing objects, Rockset immediately scans the bucket again after processing changes from the previous scan. Duration value is of type ISO 8601 (e.g. PT5H, PT4M, PT3S). It doesn't account for DST, leap seconds and leap years. Minimum value: PT1S. Maximum value: PT1H.
     * @type {string}
     * @memberof SourceGcsSettings
     */
    gcs_scan_frequency?: string;
}

/**
 * 
 * @export
 * @interface SourceKafka
 */
export interface SourceKafka {
    /**
     * The kafka client id being used.
     * @type {string}
     * @memberof SourceKafka
     */
    client_id?: string;
    /**
     * The Kafka consumer group Id being used.
     * @type {string}
     * @memberof SourceKafka
     */
    consumer_group_id?: string;
    /**
     * The Kafka topic to be tailed.
     * @type {string}
     * @memberof SourceKafka
     */
    kafka_topic_name?: string;
    /**
     * The offset reset policy.
     * @type {string}
     * @memberof SourceKafka
     */
    offset_reset_policy?: SourceKafka.OffsetResetPolicyEnum;
    /**
     * Kafka source status.
     * @type {StatusKafka}
     * @memberof SourceKafka
     */
    status?: StatusKafka;
    /**
     * Whether to use v3 integration.
     * @type {boolean}
     * @memberof SourceKafka
     */
    use_v3?: boolean;
}

/**
 * @export
 * @namespace SourceKafka
 */
export namespace SourceKafka {
    /**
     * @export
     * @enum {string}
     */
    export enum OffsetResetPolicyEnum {
        LATEST = <any> 'LATEST',
        EARLIEST = <any> 'EARLIEST'
    }
}

/**
 * 
 * @export
 * @interface SourceKinesis
 */
export interface SourceKinesis {
    /**
     * AWS region name of Kinesis stream, by default us-west-2 is used.
     * @type {string}
     * @memberof SourceKinesis
     */
    aws_region?: string;
    /**
     * Set of fields that correspond to a DMS primary key.
     * @type {Array<string>}
     * @memberof SourceKinesis
     */
    dms_primary_key?: Array<string>;
    /**
     * For non-DMS streams, Rockset can tail from the earliest end or latest end of kinesis source.
     * @type {string}
     * @memberof SourceKinesis
     */
    offset_reset_policy?: SourceKinesis.OffsetResetPolicyEnum;
    /**
     * Name of kinesis stream.
     * @type {string}
     * @memberof SourceKinesis
     */
    stream_name: string;
}

/**
 * @export
 * @namespace SourceKinesis
 */
export namespace SourceKinesis {
    /**
     * @export
     * @enum {string}
     */
    export enum OffsetResetPolicyEnum {
        LATEST = <any> 'LATEST',
        EARLIEST = <any> 'EARLIEST'
    }
}

/**
 * 
 * @export
 * @interface SourceMongoDb
 */
export interface SourceMongoDb {
    /**
     * MongoDB collection name.
     * @type {string}
     * @memberof SourceMongoDb
     */
    collection_name: string;
    /**
     * MongoDB database name containing this collection.
     * @type {string}
     * @memberof SourceMongoDb
     */
    database_name: string;
    /**
     * Whether to get the full document from the MongoDB change stream to enable multi-field expression transformations. Selecting this option will increase load on your upstream MongoDB database.
     * @type {boolean}
     * @memberof SourceMongoDb
     */
    retrieve_full_document?: boolean;
    /**
     * MongoDB source status.
     * @type {StatusMongoDb}
     * @memberof SourceMongoDb
     */
    status?: StatusMongoDb;
}

/**
 * 
 * @export
 * @interface SourceS3
 */
export interface SourceS3 {
    /**
     * Address of S3 bucket containing data.
     * @type {string}
     * @memberof SourceS3
     */
    bucket: string;
    /**
     * 
     * @type {number}
     * @memberof SourceS3
     */
    object_bytes_downloaded?: number;
    /**
     * 
     * @type {number}
     * @memberof SourceS3
     */
    object_bytes_total?: number;
    /**
     * 
     * @type {number}
     * @memberof SourceS3
     */
    object_count_downloaded?: number;
    /**
     * 
     * @type {number}
     * @memberof SourceS3
     */
    object_count_total?: number;
    /**
     * Glob-style pattern that selects keys to ingest. Only either prefix or pattern can be specified.
     * @type {string}
     * @memberof SourceS3
     */
    pattern?: string;
    /**
     * Prefix that selects keys to ingest.
     * @type {string}
     * @memberof SourceS3
     */
    prefix?: string;
    /**
     * Deprecated in favor of `prefix`. List of prefixes to paths from which data should be ingested.
     * @type {Array<string>}
     * @memberof SourceS3
     */
    prefixes?: Array<string>;
    /**
     * AWS region containing source bucket.
     * @type {string}
     * @memberof SourceS3
     */
    region?: string;
    /**
     * custom settings for Amazon S3 source
     * @type {SourceS3Settings}
     * @memberof SourceS3
     */
    settings?: SourceS3Settings;
}

/**
 * 
 * @export
 * @interface SourceS3Base
 */
export interface SourceS3Base {
    /**
     * custom settings for Amazon S3 source
     * @type {SourceS3Settings}
     * @memberof SourceS3Base
     */
    settings?: SourceS3Settings;
}

/**
 * 
 * @export
 * @interface SourceS3Settings
 */
export interface SourceS3Settings {
    /**
     * Rockset scans an S3 bucket based on a defined time interval. The scan frequency determines the length of time between a new scan and the previous scan. If the previous scan finds new objects or updates to existing objects, Rockset immediately scans the bucket again after processing changes from the previous scan. Duration value is of type ISO 8601 (e.g. PT5H, PT4M, PT3S). It doesn't account for DST, leap seconds and leap years. Minimum value: PT1S. Maximum value: PT1H.
     * @type {string}
     * @memberof SourceS3Settings
     */
    s3_scan_frequency?: string;
}

/**
 * 
 * @export
 * @interface SourceSnapshot
 */
export interface SourceSnapshot {
    /**
     * A representation of the workspace and collection where the source snapshot originated.
     * @type {string}
     * @memberof SourceSnapshot
     */
    source_collection_path?: string;
    /**
     * RRN of the snapshot that the new collection will be created from.
     * @type {string}
     * @memberof SourceSnapshot
     */
    source_snapshot_rrn?: string;
}

/**
 * 
 * @export
 * @interface SourceSnowflake
 */
export interface SourceSnowflake {
    /**
     * Name of the snowflake database.
     * @type {string}
     * @memberof SourceSnowflake
     */
    database: string;
    /**
     * Name of the snowflake database schema.
     * @type {string}
     * @memberof SourceSnowflake
     */
    schema: string;
    /**
     * Snowflake source status.
     * @type {StatusSnowflake}
     * @memberof SourceSnowflake
     */
    status?: StatusSnowflake;
    /**
     * Name of the snowflake table.
     * @type {string}
     * @memberof SourceSnowflake
     */
    table_name: string;
    /**
     * Name of the data warehouse to be used.
     * @type {string}
     * @memberof SourceSnowflake
     */
    warehouse?: string;
}

/**
 * 
 * @export
 * @interface SourceSystem
 */
export interface SourceSystem {
    /**
     * The type of this system source.
     * @type {string}
     * @memberof SourceSystem
     */
    type?: SourceSystem.TypeEnum;
    /**
     * The workspace for which collections will have logs created. If unspecified, logs will be created for collections in all workspaces. Currently only supported for the INGEST_LOGS system source.
     * @type {string}
     * @memberof SourceSystem
     */
    workspace?: string;
}

/**
 * @export
 * @namespace SourceSystem
 */
export namespace SourceSystem {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        QUERYLOGS = <any> 'QUERY_LOGS',
        INGESTLOGS = <any> 'INGEST_LOGS'
    }
}

/**
 * 
 * @export
 * @interface SourceWriteApi
 */
export interface SourceWriteApi {
}

/**
 * 
 * @export
 * @interface SqlExpression
 */
export interface SqlExpression {
    /**
     * The name of a sql function.
     * @type {string}
     * @memberof SqlExpression
     */
    sql?: string;
}

/**
 * 
 * @export
 * @interface Stats
 */
export interface Stats {
    /**
     * Total execution time (including time queued) of the query, in milliseconds.
     * @type {number}
     * @memberof Stats
     */
    elapsed_time_ms?: number;
    /**
     * Number of bytes in the query result set. Only populated if `status` is `COMPLETE`. Not populated for INSERT INTO queries.
     * @type {number}
     * @memberof Stats
     */
    result_set_bytes_size?: number;
    /**
     * Number of documents returned by the query. Only populated if `status` is `COMPLETE`.
     * @type {number}
     * @memberof Stats
     */
    result_set_document_count?: number;
    /**
     * Number of files written by by the query. Only populated if `status` is `COMPLETE` and the query is an export query.
     * @type {number}
     * @memberof Stats
     */
    result_set_file_count?: number;
    /**
     * Time query spent queued, in milliseconds.
     * @type {number}
     * @memberof Stats
     */
    throttled_time_ms?: number;
}

/**
 * 
 * @export
 * @interface Status
 */
export interface Status {
    /**
     * Size in bytes detected for the source at collection initialization. This size can be 0 or null for event stream sources.
     * @type {number}
     * @memberof Status
     */
    detected_size_bytes?: number;
    /**
     * ISO-8601 date when source was last processed.
     * @type {string}
     * @memberof Status
     */
    last_processed_at?: string;
    /**
     * Last source item processed by ingester.
     * @type {string}
     * @memberof Status
     */
    last_processed_item?: string;
    /**
     * State message.
     * @type {string}
     * @memberof Status
     */
    message?: string;
    /**
     * Status of the Source's ingestion.
     * @type {string}
     * @memberof Status
     */
    state?: Status.StateEnum;
    /**
     * Total items processed of source.
     * @type {number}
     * @memberof Status
     */
    total_processed_items?: number;
}

/**
 * @export
 * @namespace Status
 */
export namespace Status {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        INITIALIZING = <any> 'INITIALIZING',
        WATCHING = <any> 'WATCHING',
        PROCESSING = <any> 'PROCESSING',
        COMPLETED = <any> 'COMPLETED',
        ERROR = <any> 'ERROR',
        SUSPENDED = <any> 'SUSPENDED'
    }
}

/**
 * 
 * @export
 * @interface StatusAzureEventHubs
 */
export interface StatusAzureEventHubs {
    /**
     * Time at which the last document was consumed.
     * @type {string}
     * @memberof StatusAzureEventHubs
     */
    last_consumed_time?: string;
    /**
     * Number of documents consumed.
     * @type {number}
     * @memberof StatusAzureEventHubs
     */
    num_documents_processed?: number;
    /**
     * Status info per partition.
     * @type {Array<StatusAzureEventHubsPartition>}
     * @memberof StatusAzureEventHubs
     */
    partitions?: Array<StatusAzureEventHubsPartition>;
    /**
     * State of the source.
     * @type {string}
     * @memberof StatusAzureEventHubs
     */
    state?: StatusAzureEventHubs.StateEnum;
}

/**
 * @export
 * @namespace StatusAzureEventHubs
 */
export namespace StatusAzureEventHubs {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        NODOCSYET = <any> 'NO_DOCS_YET',
        ACTIVE = <any> 'ACTIVE',
        DORMANT = <any> 'DORMANT'
    }
}

/**
 * 
 * @export
 * @interface StatusAzureEventHubsPartition
 */
export interface StatusAzureEventHubsPartition {
    /**
     * Per partition lag for offset.
     * @type {number}
     * @memberof StatusAzureEventHubsPartition
     */
    offset_lag?: number;
    /**
     * The number of this partition.
     * @type {number}
     * @memberof StatusAzureEventHubsPartition
     */
    partition_number?: number;
    /**
     * Latest offset of partition.
     * @type {number}
     * @memberof StatusAzureEventHubsPartition
     */
    partition_offset?: number;
}

/**
 * 
 * @export
 * @interface StatusAzureServiceBus
 */
export interface StatusAzureServiceBus {
    /**
     * Service Bus first message processed time in ISO-8601 format.
     * @type {string}
     * @memberof StatusAzureServiceBus
     */
    first_processed_at?: string;
    /**
     * Number of records processed.
     * @type {number}
     * @memberof StatusAzureServiceBus
     */
    records_processed?: number;
    /**
     * Sessions processed.
     * @type {{ [key: string]: StatusAzureServiceBusSession; }}
     * @memberof StatusAzureServiceBus
     */
    sessions?: { [key: string]: StatusAzureServiceBusSession; };
}

/**
 * 
 * @export
 * @interface StatusAzureServiceBusSession
 */
export interface StatusAzureServiceBusSession {
    /**
     * Most recent ISO-8601 date when a message from this session was processed.
     * @type {string}
     * @memberof StatusAzureServiceBusSession
     */
    last_processed?: string;
    /**
     * The last processed sequence number within this session.
     * @type {number}
     * @memberof StatusAzureServiceBusSession
     */
    sequence_number?: number;
}

/**
 * 
 * @export
 * @interface StatusDynamoDb
 */
export interface StatusDynamoDb {
    /**
     * DynamoDb scan end time.
     * @type {string}
     * @memberof StatusDynamoDb
     */
    scan_end_time?: string;
    /**
     * Number of records inserted using scan.
     * @type {number}
     * @memberof StatusDynamoDb
     */
    scan_records_processed?: number;
    /**
     * DynamoDB scan start time.
     * @type {string}
     * @memberof StatusDynamoDb
     */
    scan_start_time?: string;
    /**
     * Number of records in DynamoDB table at time of scan.
     * @type {number}
     * @memberof StatusDynamoDb
     */
    scan_total_records?: number;
    /**
     * State of current ingest for this table.
     * @type {string}
     * @memberof StatusDynamoDb
     */
    state?: StatusDynamoDb.StateEnum;
    /**
     * ISO-8601 date when source was last processed.
     * @type {string}
     * @memberof StatusDynamoDb
     */
    stream_last_processed_at?: string;
}

/**
 * @export
 * @namespace StatusDynamoDb
 */
export namespace StatusDynamoDb {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        INITIALIZING = <any> 'INITIALIZING',
        SCANNINGTABLE = <any> 'SCANNING_TABLE',
        PROCESSINGSTREAM = <any> 'PROCESSING_STREAM'
    }
}

/**
 * 
 * @export
 * @interface StatusDynamoDbV2
 */
export interface StatusDynamoDbV2 {
    /**
     * 
     * @type {number}
     * @memberof StatusDynamoDbV2
     */
    initial_dump_completion_percentage?: number;
    /**
     * State of current ingest for this table.
     * @type {string}
     * @memberof StatusDynamoDbV2
     */
    state?: StatusDynamoDbV2.StateEnum;
    /**
     * ISO-8601 date when source was last processed.
     * @type {string}
     * @memberof StatusDynamoDbV2
     */
    stream_last_processed_at?: string;
}

/**
 * @export
 * @namespace StatusDynamoDbV2
 */
export namespace StatusDynamoDbV2 {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        INITIALIZING = <any> 'INITIALIZING',
        SCANNING = <any> 'SCANNING',
        EXPORTINGTOS3 = <any> 'EXPORTING_TO_S3',
        DOWNLOADINGFROMS3 = <any> 'DOWNLOADING_FROM_S3',
        PROCESSINGSTREAM = <any> 'PROCESSING_STREAM'
    }
}

/**
 * 
 * @export
 * @interface StatusKafka
 */
export interface StatusKafka {
    /**
     * Status info per partition.
     * @type {Array<StatusKafkaPartition>}
     * @memberof StatusKafka
     */
    kafka_partitions?: Array<StatusKafkaPartition>;
    /**
     * Time at which the last document was consumed from Kafka.
     * @type {string}
     * @memberof StatusKafka
     */
    last_consumed_time?: string;
    /**
     * Number of documents consumed by this Kafka topic.
     * @type {number}
     * @memberof StatusKafka
     */
    num_documents_processed?: number;
    /**
     * State of the Kafka source.
     * @type {string}
     * @memberof StatusKafka
     */
    state?: StatusKafka.StateEnum;
}

/**
 * @export
 * @namespace StatusKafka
 */
export namespace StatusKafka {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        NODOCSYET = <any> 'NO_DOCS_YET',
        ACTIVE = <any> 'ACTIVE',
        DORMANT = <any> 'DORMANT'
    }
}

/**
 * 
 * @export
 * @interface StatusKafkaPartition
 */
export interface StatusKafkaPartition {
    /**
     * Per partition lag for offset.
     * @type {number}
     * @memberof StatusKafkaPartition
     */
    offset_lag?: number;
    /**
     * The number of this partition.
     * @type {number}
     * @memberof StatusKafkaPartition
     */
    partition_number?: number;
    /**
     * Latest offset of partition.
     * @type {number}
     * @memberof StatusKafkaPartition
     */
    partition_offset?: number;
}

/**
 * 
 * @export
 * @interface StatusMongoDb
 */
export interface StatusMongoDb {
    /**
     * MongoDB scan end time.
     * @type {string}
     * @memberof StatusMongoDb
     */
    scan_end_time?: string;
    /**
     * Number of records inserted using scan.
     * @type {number}
     * @memberof StatusMongoDb
     */
    scan_records_processed?: number;
    /**
     * MongoDB scan start time.
     * @type {string}
     * @memberof StatusMongoDb
     */
    scan_start_time?: string;
    /**
     * Number of records in MongoDB table at time of scan.
     * @type {number}
     * @memberof StatusMongoDb
     */
    scan_total_records?: number;
    /**
     * State of current ingest for this table.
     * @type {string}
     * @memberof StatusMongoDb
     */
    state?: StatusMongoDb.StateEnum;
    /**
     * ISO-8601 date when delete from source was last processed.
     * @type {string}
     * @memberof StatusMongoDb
     */
    stream_last_delete_processed_at?: string;
    /**
     * ISO-8601 date when new insert from source was last processed.
     * @type {string}
     * @memberof StatusMongoDb
     */
    stream_last_insert_processed_at?: string;
    /**
     * ISO-8601 date when update from source was last processed.
     * @type {string}
     * @memberof StatusMongoDb
     */
    stream_last_update_processed_at?: string;
    /**
     * Number of new records deleted using stream.
     * @type {number}
     * @memberof StatusMongoDb
     */
    stream_records_deleted?: number;
    /**
     * Number of new records inserted using stream.
     * @type {number}
     * @memberof StatusMongoDb
     */
    stream_records_inserted?: number;
    /**
     * Number of new records updated using stream.
     * @type {number}
     * @memberof StatusMongoDb
     */
    stream_records_updated?: number;
}

/**
 * @export
 * @namespace StatusMongoDb
 */
export namespace StatusMongoDb {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        INITIALIZING = <any> 'INITIALIZING',
        SCANNINGTABLE = <any> 'SCANNING_TABLE',
        PROCESSINGSTREAM = <any> 'PROCESSING_STREAM'
    }
}

/**
 * 
 * @export
 * @interface StatusSnowflake
 */
export interface StatusSnowflake {
    /**
     * State of current ingest for this table.
     * @type {string}
     * @memberof StatusSnowflake
     */
    state?: StatusSnowflake.StateEnum;
}

/**
 * @export
 * @namespace StatusSnowflake
 */
export namespace StatusSnowflake {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        INITIALIZING = <any> 'INITIALIZING',
        EXPORTINGTOS3 = <any> 'EXPORTING_TO_S3',
        DOWNLOADINGFROMS3 = <any> 'DOWNLOADING_FROM_S3',
        COMPLETED = <any> 'COMPLETED'
    }
}

/**
 * 
 * @export
 * @interface SuspendSourceRequest
 */
export interface SuspendSourceRequest {
    /**
     * duration to suspend source; 1h is the default
     * @type {string}
     * @memberof SuspendSourceRequest
     */
    resume_after_duration?: string;
}

/**
 * 
 * @export
 * @interface SuspendVirtualInstanceResponse
 */
export interface SuspendVirtualInstanceResponse {
    /**
     * Virtual instance that was suspended.
     * @type {VirtualInstance}
     * @memberof SuspendVirtualInstanceResponse
     */
    data?: VirtualInstance;
}

/**
 * 
 * @export
 * @interface TLSConfig
 */
export interface TLSConfig {
    /**
     * PEM-formatted certificate chain of the Certificate Authority used to verify remote server. If empty, Rockset, will use publicly trusted CAs
     * @type {string}
     * @memberof TLSConfig
     */
    ca_cert?: string;
    /**
     * PEM-formatted certificate chain to use for client authentication
     * @type {string}
     * @memberof TLSConfig
     */
    client_cert: string;
    /**
     * Expiration date of the client certificate (represented as number of ms since epoch)
     * @type {number}
     * @memberof TLSConfig
     */
    client_cert_expiry?: number;
    /**
     * Subject of the client certificate, containing common name and other attributes
     * @type {string}
     * @memberof TLSConfig
     */
    client_cert_subject?: string;
    /**
     * PEM-formatted private key to be used for client authentication
     * @type {string}
     * @memberof TLSConfig
     */
    client_key: string;
}

/**
 * Notification preferences for the user.
 * @export
 * @interface UnsubscribePreference
 */
export interface UnsubscribePreference {
    /**
     * The type of notification to be unsubscribed from.
     * @type {string}
     * @memberof UnsubscribePreference
     */
    notificationType: string;
}

/**
 * 
 * @export
 * @interface UpdateAliasRequest
 */
export interface UpdateAliasRequest {
    /**
     * List of fully qualified collection names referenced by alias.
     * @type {Array<string>}
     * @memberof UpdateAliasRequest
     */
    collections: Array<string>;
    /**
     * Optional description.
     * @type {string}
     * @memberof UpdateAliasRequest
     */
    description?: string;
}

/**
 * 
 * @export
 * @interface UpdateApiKeyRequest
 */
export interface UpdateApiKeyRequest {
    /**
     * If set to true, the expiration time for this key will be cleared.
     * @type {boolean}
     * @memberof UpdateApiKeyRequest
     */
    clear_expiry_time?: boolean;
    /**
     * If provided, the API key will automatically expire at this time (ISO-8601 format). Requires premium.
     * @type {string}
     * @memberof UpdateApiKeyRequest
     */
    expiry_time?: string;
    /**
     * State that the api key should be set to.
     * @type {string}
     * @memberof UpdateApiKeyRequest
     */
    state?: UpdateApiKeyRequest.StateEnum;
}

/**
 * @export
 * @namespace UpdateApiKeyRequest
 */
export namespace UpdateApiKeyRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        ACTIVE = <any> 'ACTIVE',
        SUSPENDED = <any> 'SUSPENDED'
    }
}

/**
 * 
 * @export
 * @interface UpdateApiKeyResponse
 */
export interface UpdateApiKeyResponse {
    /**
     * The API key that was updated.
     * @type {ApiKey}
     * @memberof UpdateApiKeyResponse
     */
    data?: ApiKey;
}

/**
 * 
 * @export
 * @interface UpdateCollectionRequest
 */
export interface UpdateCollectionRequest {
    /**
     * Updated text describing the collection.
     * @type {string}
     * @memberof UpdateCollectionRequest
     */
    description?: string;
    /**
     * Updated ingest transformation query. Note that updating the transformation will lead to a brief interruption in ingestion.
     * @type {FieldMappingQuery}
     * @memberof UpdateCollectionRequest
     */
    field_mapping_query?: FieldMappingQuery;
}

/**
 * 
 * @export
 * @interface UpdateDeploymentSettingsRequest
 */
export interface UpdateDeploymentSettingsRequest {
    /**
     * RRN of the Virtual Instance that all queries will be routed to by default
     * @type {string}
     * @memberof UpdateDeploymentSettingsRequest
     */
    default_query_vi?: string;
}

/**
 * 
 * @export
 * @interface UpdateIntegrationRequest
 */
export interface UpdateIntegrationRequest {
    /**
     * Azure Blob Storage details.
     * @type {AzureBlobStorageIntegration}
     * @memberof UpdateIntegrationRequest
     */
    azure_blob_storage?: AzureBlobStorageIntegration;
    /**
     * Azure Event Hubs details.
     * @type {AzureEventHubsIntegration}
     * @memberof UpdateIntegrationRequest
     */
    azure_event_hubs?: AzureEventHubsIntegration;
    /**
     * Azure Service Bus details.
     * @type {AzureServiceBusIntegration}
     * @memberof UpdateIntegrationRequest
     */
    azure_service_bus?: AzureServiceBusIntegration;
    /**
     * Longer explanation for the integration.
     * @type {string}
     * @memberof UpdateIntegrationRequest
     */
    description?: string;
    /**
     * Amazon DynamoDB details, must have one of aws_access_key or aws_role.
     * @type {DynamodbIntegration}
     * @memberof UpdateIntegrationRequest
     */
    dynamodb?: DynamodbIntegration;
    /**
     * GCS details.
     * @type {GcsIntegration}
     * @memberof UpdateIntegrationRequest
     */
    gcs?: GcsIntegration;
    /**
     * is write access enabled for this integration.
     * @type {boolean}
     * @memberof UpdateIntegrationRequest
     */
    is_write_enabled?: boolean;
    /**
     * 
     * @type {KafkaIntegration}
     * @memberof UpdateIntegrationRequest
     */
    kafka?: KafkaIntegration;
    /**
     * Amazon Kinesis details, must have one of aws_access_key or aws_role.
     * @type {KinesisIntegration}
     * @memberof UpdateIntegrationRequest
     */
    kinesis?: KinesisIntegration;
    /**
     * MongoDb details.
     * @type {MongoDbIntegration}
     * @memberof UpdateIntegrationRequest
     */
    mongodb?: MongoDbIntegration;
    /**
     * Amazon S3 details, must have one of aws_access_key or aws_role.
     * @type {S3Integration}
     * @memberof UpdateIntegrationRequest
     */
    s3?: S3Integration;
    /**
     * Snowflake details.
     * @type {SnowflakeIntegration}
     * @memberof UpdateIntegrationRequest
     */
    snowflake?: SnowflakeIntegration;
}

/**
 * 
 * @export
 * @interface UpdateIntegrationResponse
 */
export interface UpdateIntegrationResponse {
    /**
     * Updated integration object.
     * @type {Integration}
     * @memberof UpdateIntegrationResponse
     */
    data?: Integration;
}

/**
 * 
 * @export
 * @interface UpdateQueryLambdaRequest
 */
export interface UpdateQueryLambdaRequest {
    /**
     * Optional description.
     * @type {string}
     * @memberof UpdateQueryLambdaRequest
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateQueryLambdaRequest
     */
    is_public?: boolean;
    /**
     * Query Lambda SQL query.
     * @type {QueryLambdaSql}
     * @memberof UpdateQueryLambdaRequest
     */
    sql?: QueryLambdaSql;
}

/**
 * 
 * @export
 * @interface UpdateRoleRequest
 */
export interface UpdateRoleRequest {
    /**
     * Description for the role.
     * @type {string}
     * @memberof UpdateRoleRequest
     */
    description?: string;
    /**
     * List of privileges that will be associated with the role.
     * @type {Array<Privilege>}
     * @memberof UpdateRoleRequest
     */
    privileges?: Array<Privilege>;
}

/**
 * 
 * @export
 * @interface UpdateScheduledLambdaRequest
 */
export interface UpdateScheduledLambdaRequest {
    /**
     * The apikey to use when triggering execution of the associated query lambda.
     * @type {string}
     * @memberof UpdateScheduledLambdaRequest
     */
    apikey?: string;
    /**
     * Boolean flag to allow a scheduled query lambda to resume execution after being suspended due to execution failure. This flag will be unset after scheduled lambda execution.
     * @type {boolean}
     * @memberof UpdateScheduledLambdaRequest
     */
    resume_permanent_error?: boolean;
    /**
     * The number of times to execute this scheduled query lambda.
     * @type {number}
     * @memberof UpdateScheduledLambdaRequest
     */
    total_times_to_execute?: number;
    /**
     * The value to use as the authorization header when hitting the webhook.
     * @type {string}
     * @memberof UpdateScheduledLambdaRequest
     */
    webhook_auth_header?: string;
    /**
     * The payload that should be sent to the webhook. JSON format.
     * @type {string}
     * @memberof UpdateScheduledLambdaRequest
     */
    webhook_payload?: string;
    /**
     * The URL of the webhook that should be triggered after this scheduled query lambda completes.
     * @type {string}
     * @memberof UpdateScheduledLambdaRequest
     */
    webhook_url?: string;
}

/**
 * 
 * @export
 * @interface UpdateUnsubscribePreferencesRequest
 */
export interface UpdateUnsubscribePreferencesRequest {
    /**
     * List of notification preferences.
     * @type {Array<UnsubscribePreference>}
     * @memberof UpdateUnsubscribePreferencesRequest
     */
    data?: Array<UnsubscribePreference>;
}

/**
 * 
 * @export
 * @interface UpdateUnsubscribePreferencesResponse
 */
export interface UpdateUnsubscribePreferencesResponse {
    /**
     * List of notification preferences.
     * @type {Array<UnsubscribePreference>}
     * @memberof UpdateUnsubscribePreferencesResponse
     */
    data?: Array<UnsubscribePreference>;
}

/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * User first name.
     * @type {string}
     * @memberof UpdateUserRequest
     */
    first_name?: string;
    /**
     * User last name.
     * @type {string}
     * @memberof UpdateUserRequest
     */
    last_name?: string;
    /**
     * New list of roles for a given user.
     * @type {Array<string>}
     * @memberof UpdateUserRequest
     */
    roles?: Array<string>;
}

/**
 * 
 * @export
 * @interface UpdateViewRequest
 */
export interface UpdateViewRequest {
    /**
     * Optional description.
     * @type {string}
     * @memberof UpdateViewRequest
     */
    description?: string;
    /**
     * SQL for this view.
     * @type {string}
     * @memberof UpdateViewRequest
     */
    query: string;
}

/**
 * 
 * @export
 * @interface UpdateViewResponse
 */
export interface UpdateViewResponse {
    /**
     * View that was updated.
     * @type {View}
     * @memberof UpdateViewResponse
     */
    data?: View;
}

/**
 * 
 * @export
 * @interface UpdateVirtualInstanceRequest
 */
export interface UpdateVirtualInstanceRequest {
    /**
     * Options for configuring auto scaling policy
     * @type {AutoScalingPolicy}
     * @memberof UpdateVirtualInstanceRequest
     */
    auto_scaling_policy?: AutoScalingPolicy;
    /**
     * Whether Query VI auto-suspend should be enabled for this Virtual Instance.
     * @type {boolean}
     * @memberof UpdateVirtualInstanceRequest
     */
    auto_suspend_enabled?: boolean;
    /**
     * Number of seconds without queries after which the Query VI is suspended
     * @type {number}
     * @memberof UpdateVirtualInstanceRequest
     */
    auto_suspend_seconds?: number;
    /**
     * New virtual instance description.
     * @type {string}
     * @memberof UpdateVirtualInstanceRequest
     */
    description?: string;
    /**
     * When a Virtual Instance is resumed, it will remount all collections that were mounted when the Virtual Instance was suspended.
     * @type {boolean}
     * @memberof UpdateVirtualInstanceRequest
     */
    enable_remount_on_resume?: boolean;
    /**
     * Virtual Instance Class. Use `MO_IL` for Memory Optimized and `GP_IL` for General Purpose instance class.
     * @type {string}
     * @memberof UpdateVirtualInstanceRequest
     */
    instance_class?: UpdateVirtualInstanceRequest.InstanceClassEnum;
    /**
     * DEPRECATED. Use `mount_type` instead. Number of seconds between data refreshes for mounts on this Virtual Instance. The only valid values are 0 and null. 0 means the data will be refreshed continuously and null means the data will never refresh.
     * @type {number}
     * @memberof UpdateVirtualInstanceRequest
     */
    mount_refresh_interval_seconds?: number;
    /**
     * The mount type of collections that this Virtual Instance will query. Live mounted collections stay up-to-date with the underlying collection in real-time. Static mounted collections do not stay up-to-date. See https://docs.rockset.com/documentation/docs/using-virtual-instances#virtual-instance-configuration
     * @type {string}
     * @memberof UpdateVirtualInstanceRequest
     */
    mount_type?: UpdateVirtualInstanceRequest.MountTypeEnum;
    /**
     * New virtual instance name.
     * @type {string}
     * @memberof UpdateVirtualInstanceRequest
     */
    name?: string;
    /**
     * Requested virtual instance size.
     * @type {string}
     * @memberof UpdateVirtualInstanceRequest
     */
    new_size?: UpdateVirtualInstanceRequest.NewSizeEnum;
}

/**
 * @export
 * @namespace UpdateVirtualInstanceRequest
 */
export namespace UpdateVirtualInstanceRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum InstanceClassEnum {
        MOIL = <any> 'MO_IL',
        GPIL = <any> 'GP_IL'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum MountTypeEnum {
        LIVE = <any> 'LIVE',
        STATIC = <any> 'STATIC'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum NewSizeEnum {
        FREE = <any> 'FREE',
        NANO = <any> 'NANO',
        SHARED = <any> 'SHARED',
        MILLI = <any> 'MILLI',
        XSMALL = <any> 'XSMALL',
        SMALL = <any> 'SMALL',
        MEDIUM = <any> 'MEDIUM',
        LARGE = <any> 'LARGE',
        XLARGE = <any> 'XLARGE',
        XLARGE2 = <any> 'XLARGE2',
        XLARGE4 = <any> 'XLARGE4',
        XLARGE8 = <any> 'XLARGE8',
        XLARGE16 = <any> 'XLARGE16'
    }
}

/**
 * 
 * @export
 * @interface UpdateVirtualInstanceResponse
 */
export interface UpdateVirtualInstanceResponse {
    /**
     * Virtual instance that was switched.
     * @type {VirtualInstance}
     * @memberof UpdateVirtualInstanceResponse
     */
    data?: VirtualInstance;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * ISO-8601 date.
     * @type {string}
     * @memberof User
     */
    created_at?: string;
    /**
     * User email.
     * @type {string}
     * @memberof User
     */
    email: string;
    /**
     * User first name.
     * @type {string}
     * @memberof User
     */
    first_name?: string;
    /**
     * User last name.
     * @type {string}
     * @memberof User
     */
    last_name?: string;
    /**
     * List of roles for a given user.
     * @type {Array<string>}
     * @memberof User
     */
    roles?: Array<string>;
    /**
     * State of user - NEW / ACTIVE.
     * @type {string}
     * @memberof User
     */
    state?: string;
}

/**
 * 
 * @export
 * @interface ValidateQueryResponse
 */
export interface ValidateQueryResponse {
    /**
     * List of collections specified in query.
     * @type {Array<string>}
     * @memberof ValidateQueryResponse
     */
    collections: Array<string>;
    /**
     * List of parameters specified in query.
     * @type {Array<string>}
     * @memberof ValidateQueryResponse
     */
    parameters: Array<string>;
}

/**
 * 
 * @export
 * @interface View
 */
export interface View {
    /**
     * ISO-8601 date.
     * @type {string}
     * @memberof View
     */
    created_at?: string;
    /**
     * Name of the API key that was used to create this object if one was used.
     * @type {string}
     * @memberof View
     */
    created_by_apikey_name?: string;
    /**
     * Email of the creator.
     * @type {string}
     * @memberof View
     */
    creator_email?: string;
    /**
     * View description.
     * @type {string}
     * @memberof View
     */
    description?: string;
    /**
     * List of entities referenced by view. An entity can be a view, alias or collection.
     * @type {Array<string>}
     * @memberof View
     */
    entities?: Array<string>;
    /**
     * ISO-8601 date.
     * @type {string}
     * @memberof View
     */
    modified_at?: string;
    /**
     * Name of the view.
     * @type {string}
     * @memberof View
     */
    name?: string;
    /**
     * Email of the owner, note: deprecated and will always be null.
     * @type {string}
     * @memberof View
     */
    owner_email?: string;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    path?: string;
    /**
     * SQL query of the view.
     * @type {string}
     * @memberof View
     */
    query_sql?: string;
    /**
     * State of the view.
     * @type {string}
     * @memberof View
     */
    state?: View.StateEnum;
    /**
     * Name of the workspace.
     * @type {string}
     * @memberof View
     */
    workspace?: string;
}

/**
 * @export
 * @namespace View
 */
export namespace View {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        CREATED = <any> 'CREATED',
        SYNCING = <any> 'SYNCING',
        DELETED = <any> 'DELETED'
    }
}

/**
 * 
 * @export
 * @interface VirtualInstance
 */
export interface VirtualInstance {
    /**
     * Options for configuring auto scaling policy
     * @type {AutoScalingPolicy}
     * @memberof VirtualInstance
     */
    auto_scaling_policy?: AutoScalingPolicy;
    /**
     * Number of seconds without queries after which the VI is suspended
     * @type {number}
     * @memberof VirtualInstance
     */
    auto_suspend_seconds?: number;
    /**
     * ISO-8601 date of when virtual instance was created.
     * @type {string}
     * @memberof VirtualInstance
     */
    created_at?: string;
    /**
     * Creator of requested virtual instance.
     * @type {string}
     * @memberof VirtualInstance
     */
    created_by?: string;
    /**
     * Virtual Instance Class. `MO_IL` represents Memory Optimized and `GP_IL` represents General Purpose instance class.
     * @type {string}
     * @memberof VirtualInstance
     */
    current_instance_class?: VirtualInstance.CurrentInstanceClassEnum;
    /**
     * Virtual instance current size.
     * @type {string}
     * @memberof VirtualInstance
     */
    current_size?: VirtualInstance.CurrentSizeEnum;
    /**
     * 
     * @type {number}
     * @memberof VirtualInstance
     */
    default_pod_count?: number;
    /**
     * 
     * @type {boolean}
     * @memberof VirtualInstance
     */
    default_vi?: boolean;
    /**
     * Virtual instance description.
     * @type {string}
     * @memberof VirtualInstance
     */
    description?: string;
    /**
     * Virtual Instance Class.
     * @type {string}
     * @memberof VirtualInstance
     */
    desired_instance_class?: VirtualInstance.DesiredInstanceClassEnum;
    /**
     * Virtual instance desired size.
     * @type {string}
     * @memberof VirtualInstance
     */
    desired_size?: VirtualInstance.DesiredSizeEnum;
    /**
     * When a Virtual Instance is resumed, it will remount all collections that were mounted when the Virtual Instance was suspended.
     * @type {boolean}
     * @memberof VirtualInstance
     */
    enable_remount_on_resume?: boolean;
    /**
     * Unique identifier for virtual instance.
     * @type {string}
     * @memberof VirtualInstance
     */
    id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof VirtualInstance
     */
    monitoring_enabled?: boolean;
    /**
     * DEPRECATED. Number of seconds between data refreshes for mounts on this Virtual Instance
     * @type {number}
     * @memberof VirtualInstance
     */
    mount_refresh_interval_seconds?: number;
    /**
     * The mount type of collections that this Virtual Instance will query. Live mounted collections stay up-to-date with the underlying collection in real-time. Static mounted collections do not stay up-to-date. See https://docs.rockset.com/documentation/docs/using-virtual-instances#virtual-instance-configuration
     * @type {string}
     * @memberof VirtualInstance
     */
    mount_type?: VirtualInstance.MountTypeEnum;
    /**
     * Virtual instance name.
     * @type {string}
     * @memberof VirtualInstance
     */
    name: string;
    /**
     * ISO-8601 date of when virtual instance was created.
     * @type {string}
     * @memberof VirtualInstance
     */
    resumed_at?: string;
    /**
     * Virtual Instance RRN.
     * @type {string}
     * @memberof VirtualInstance
     */
    rrn?: string;
    /**
     * 
     * @type {number}
     * @memberof VirtualInstance
     */
    scaled_pod_count?: number;
    /**
     * Virtual instance state.
     * @type {string}
     * @memberof VirtualInstance
     */
    state?: VirtualInstance.StateEnum;
    /**
     * Stats about this VirtualInstance
     * @type {VirtualInstanceStats}
     * @memberof VirtualInstance
     */
    stats?: VirtualInstanceStats;
}

/**
 * @export
 * @namespace VirtualInstance
 */
export namespace VirtualInstance {
    /**
     * @export
     * @enum {string}
     */
    export enum CurrentInstanceClassEnum {
        MOBR = <any> 'MO_BR',
        MOIL = <any> 'MO_IL',
        GPIL = <any> 'GP_IL'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum CurrentSizeEnum {
        FREE = <any> 'FREE',
        NANO = <any> 'NANO',
        SHARED = <any> 'SHARED',
        MILLI = <any> 'MILLI',
        XSMALL = <any> 'XSMALL',
        SMALL = <any> 'SMALL',
        MEDIUM = <any> 'MEDIUM',
        LARGE = <any> 'LARGE',
        XLARGE = <any> 'XLARGE',
        XLARGE2 = <any> 'XLARGE2',
        XLARGE4 = <any> 'XLARGE4',
        XLARGE8 = <any> 'XLARGE8',
        XLARGE16 = <any> 'XLARGE16'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DesiredInstanceClassEnum {
        MOBR = <any> 'MO_BR',
        MOIL = <any> 'MO_IL',
        GPIL = <any> 'GP_IL'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DesiredSizeEnum {
        FREE = <any> 'FREE',
        NANO = <any> 'NANO',
        SHARED = <any> 'SHARED',
        MILLI = <any> 'MILLI',
        XSMALL = <any> 'XSMALL',
        SMALL = <any> 'SMALL',
        MEDIUM = <any> 'MEDIUM',
        LARGE = <any> 'LARGE',
        XLARGE = <any> 'XLARGE',
        XLARGE2 = <any> 'XLARGE2',
        XLARGE4 = <any> 'XLARGE4',
        XLARGE8 = <any> 'XLARGE8',
        XLARGE16 = <any> 'XLARGE16'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum MountTypeEnum {
        LIVE = <any> 'LIVE',
        STATIC = <any> 'STATIC'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        INITIALIZING = <any> 'INITIALIZING',
        PROVISIONINGRESOURCES = <any> 'PROVISIONING_RESOURCES',
        REBALANCINGCOLLECTIONS = <any> 'REBALANCING_COLLECTIONS',
        ACTIVE = <any> 'ACTIVE',
        SUSPENDING = <any> 'SUSPENDING',
        SUSPENDED = <any> 'SUSPENDED',
        RESUMING = <any> 'RESUMING',
        DELETED = <any> 'DELETED',
        ENABLINGDEDICATEDSERVICES = <any> 'ENABLING_DEDICATED_SERVICES',
        DISABLINGDEDICATEDSERVICES = <any> 'DISABLING_DEDICATED_SERVICES'
    }
}

/**
 * 
 * @export
 * @interface VirtualInstanceRrn
 */
export interface VirtualInstanceRrn {
    /**
     * 
     * @type {string}
     * @memberof VirtualInstanceRrn
     */
    cluster?: VirtualInstanceRrn.ClusterEnum;
    /**
     * 
     * @type {string}
     * @memberof VirtualInstanceRrn
     */
    resourceType?: VirtualInstanceRrn.ResourceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof VirtualInstanceRrn
     */
    uuid?: string;
    /**
     * 
     * @type {number}
     * @memberof VirtualInstanceRrn
     */
    version?: number;
}

/**
 * @export
 * @namespace VirtualInstanceRrn
 */
export namespace VirtualInstanceRrn {
    /**
     * @export
     * @enum {string}
     */
    export enum ClusterEnum {
        APT2A1 = <any> 'APT2A1',
        DEV = <any> 'DEV',
        DEVUSW2A1 = <any> 'DEV_USW2A1',
        EUC1A1 = <any> 'EUC1A1',
        EUW1A1 = <any> 'EUW1A1',
        GLOBAL = <any> 'GLOBAL',
        TEST = <any> 'TEST',
        UNKNOWN = <any> 'UNKNOWN',
        USE1A1 = <any> 'USE1A1',
        USW2A1 = <any> 'USW2A1'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ResourceTypeEnum {
        ALIAS = <any> 'ALIAS',
        CLUSTER = <any> 'CLUSTER',
        COLLECTION = <any> 'COLLECTION',
        COLLECTIONSTATS = <any> 'COLLECTION_STATS',
        COMPACTIONINFO = <any> 'COMPACTION_INFO',
        DEPLOYMENTSTATS = <any> 'DEPLOYMENT_STATS',
        FIELDSCHEMA = <any> 'FIELD_SCHEMA',
        INTEGRATION = <any> 'INTEGRATION',
        IPALLOWLIST = <any> 'IP_ALLOWLIST',
        LEAF = <any> 'LEAF',
        LEAFGROUP = <any> 'LEAF_GROUP',
        MOUNT = <any> 'MOUNT',
        NETWORKCONFIGURATION = <any> 'NETWORK_CONFIGURATION',
        ORG = <any> 'ORG',
        PENDINGSNAPSHOTS = <any> 'PENDING_SNAPSHOTS',
        PREVIEWSOURCE = <any> 'PREVIEW_SOURCE',
        QUERYLAMBDA = <any> 'QUERY_LAMBDA',
        QUERYLAMBDATAG = <any> 'QUERY_LAMBDA_TAG',
        QUERYLAMBDAVERSION = <any> 'QUERY_LAMBDA_VERSION',
        ROCKSETDEPLOYMENT = <any> 'ROCKSET_DEPLOYMENT',
        ROLE = <any> 'ROLE',
        ROOT = <any> 'ROOT',
        SCHEDULEDQUERYLAMBDA = <any> 'SCHEDULED_QUERY_LAMBDA',
        SHARD = <any> 'SHARD',
        SHARDBATCH = <any> 'SHARD_BATCH',
        SIMILARITYINDEX = <any> 'SIMILARITY_INDEX',
        SNAPSHOT = <any> 'SNAPSHOT',
        SOURCE = <any> 'SOURCE',
        SOURCESTATE = <any> 'SOURCE_STATE',
        USER = <any> 'USER',
        VIEW = <any> 'VIEW',
        VIRTUALINSTANCE = <any> 'VIRTUAL_INSTANCE',
        WORKSPACE = <any> 'WORKSPACE'
    }
}

/**
 * 
 * @export
 * @interface VirtualInstanceStats
 */
export interface VirtualInstanceStats {
    /**
     * Milliseconds since Unix epoch Jan 1, 1970.
     * @type {number}
     * @memberof VirtualInstanceStats
     */
    last_queried_ms?: number;
}

/**
 * Workspaces are organizational containers for collections.
 * @export
 * @interface Workspace
 */
export interface Workspace {
    /**
     * Number of collections that are immediate children of workspace.
     * @type {number}
     * @memberof Workspace
     */
    collection_count?: number;
    /**
     * ISO-8601 date of when workspace was created.
     * @type {string}
     * @memberof Workspace
     */
    created_at?: string;
    /**
     * Email of user who created the workspace.
     * @type {string}
     * @memberof Workspace
     */
    created_by?: string;
    /**
     * Longer explanation for the workspace.
     * @type {string}
     * @memberof Workspace
     */
    description?: string;
    /**
     * Descriptive label and unique identifier.
     * @type {string}
     * @memberof Workspace
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface XmlParams
 */
export interface XmlParams {
    /**
     * Tag to differentiate between attributes and elements.
     * @type {string}
     * @memberof XmlParams
     */
    attribute_prefix?: string;
    /**
     * Tags with which documents are identified.
     * @type {string}
     * @memberof XmlParams
     */
    doc_tag?: string;
    /**
     * Encoding in which data source is encoded.
     * @type {string}
     * @memberof XmlParams
     */
    encoding?: string;
    /**
     * Tag until which xml is ignored.
     * @type {string}
     * @memberof XmlParams
     */
    root_tag?: string;
    /**
     * tag used for the value when there are attributes in the element having no child
     * @type {string}
     * @memberof XmlParams
     */
    value_tag?: string;
}


/**
 * APIKeysApi - fetch parameter creator
 * @export
 */
export const APIKeysApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new API key for the authenticated user.
         * @summary Create API Key
         * @param {CreateApiKeyRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey(body: CreateApiKeyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createApiKey.');
            }
            const localVarPath = `/v1/orgs/self/users/self/apikeys`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateApiKeyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an API key for any user in your organization.
         * @summary Delete API Key
         * @param {string} name Name of the API key.
         * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey(name: string, user: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteApiKey.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling deleteApiKey.');
            }
            const localVarPath = `/v1/orgs/self/users/{user}/apikeys/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a particular API key for any user in your organization.
         * @summary Retrieve API Key
         * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
         * @param {string} name Name of the API key.
         * @param {boolean} [reveal] Reveal full key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKey(user: string, name: string, reveal?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling getApiKey.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getApiKey.');
            }
            const localVarPath = `/v1/orgs/self/users/{user}/apikeys/{name}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            if (reveal !== undefined) {
                localVarQueryParameter['reveal'] = reveal;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List API key metadata for any user in your organization.
         * @summary List API Keys
         * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeys(user: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling listApiKeys.');
            }
            const localVarPath = `/v1/orgs/self/users/{user}/apikeys`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the state of an API key for any user in your organization.
         * @summary Update API Key State
         * @param {string} name Name of the API key.
         * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
         * @param {UpdateApiKeyRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApiKey(name: string, user: string, body: UpdateApiKeyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling updateApiKey.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling updateApiKey.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateApiKey.');
            }
            const localVarPath = `/v1/orgs/self/users/{user}/apikeys/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateApiKeyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};
/**
 * APIKeysApi - functional programming interface
 * @export
 */
export const APIKeysApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new API key for the authenticated user.
         * @summary Create API Key
         * @param {CreateApiKeyRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey(body: CreateApiKeyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateApiKeyResponse> {
            const localVarFetchArgs = APIKeysApiFetchParamCreator(configuration).createApiKey(body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an API key for any user in your organization.
         * @summary Delete API Key
         * @param {string} name Name of the API key.
         * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey(name: string, user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteApiKeyResponse> {
            const localVarFetchArgs = APIKeysApiFetchParamCreator(configuration).deleteApiKey(name, user, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve a particular API key for any user in your organization.
         * @summary Retrieve API Key
         * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
         * @param {string} name Name of the API key.
         * @param {boolean} [reveal] Reveal full key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKey(user: string, name: string, reveal?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetApiKeyResponse> {
            const localVarFetchArgs = APIKeysApiFetchParamCreator(configuration).getApiKey(user, name, reveal, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List API key metadata for any user in your organization.
         * @summary List API Keys
         * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeys(user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListApiKeysResponse> {
            const localVarFetchArgs = APIKeysApiFetchParamCreator(configuration).listApiKeys(user, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the state of an API key for any user in your organization.
         * @summary Update API Key State
         * @param {string} name Name of the API key.
         * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
         * @param {UpdateApiKeyRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApiKey(name: string, user: string, body: UpdateApiKeyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpdateApiKeyResponse> {
            const localVarFetchArgs = APIKeysApiFetchParamCreator(configuration).updateApiKey(name, user, body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * APIKeysApi - factory interface
 * @export
 */
export const APIKeysApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new API key for the authenticated user.
         * @summary Create API Key
         * @param {CreateApiKeyRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey(body: CreateApiKeyRequest, options?: any) {
            return APIKeysApiFp(configuration).createApiKey(body, options)(fetch, basePath);
        },
        /**
         * Delete an API key for any user in your organization.
         * @summary Delete API Key
         * @param {string} name Name of the API key.
         * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey(name: string, user: string, options?: any) {
            return APIKeysApiFp(configuration).deleteApiKey(name, user, options)(fetch, basePath);
        },
        /**
         * Retrieve a particular API key for any user in your organization.
         * @summary Retrieve API Key
         * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
         * @param {string} name Name of the API key.
         * @param {boolean} [reveal] Reveal full key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKey(user: string, name: string, reveal?: boolean, options?: any) {
            return APIKeysApiFp(configuration).getApiKey(user, name, reveal, options)(fetch, basePath);
        },
        /**
         * List API key metadata for any user in your organization.
         * @summary List API Keys
         * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeys(user: string, options?: any) {
            return APIKeysApiFp(configuration).listApiKeys(user, options)(fetch, basePath);
        },
        /**
         * Update the state of an API key for any user in your organization.
         * @summary Update API Key State
         * @param {string} name Name of the API key.
         * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
         * @param {UpdateApiKeyRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApiKey(name: string, user: string, body: UpdateApiKeyRequest, options?: any) {
            return APIKeysApiFp(configuration).updateApiKey(name, user, body, options)(fetch, basePath);
        },
    };
};
/**
 * APIKeysApi - object-oriented interface
 * @export
 * @class APIKeysApi
 * @extends {BaseAPI}
 */
export class APIKeysApi extends BaseAPI {
    /**
     * Create a new API key for the authenticated user.
     * @summary Create API Key
     * @param {CreateApiKeyRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public createApiKey(body: CreateApiKeyRequest, options?: any) {
        return APIKeysApiFp(this.configuration).createApiKey(body, options)(this.fetch, this.basePath);
    }
    /**
     * Delete an API key for any user in your organization.
     * @summary Delete API Key
     * @param {string} name Name of the API key.
     * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public deleteApiKey(name: string, user: string, options?: any) {
        return APIKeysApiFp(this.configuration).deleteApiKey(name, user, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve a particular API key for any user in your organization.
     * @summary Retrieve API Key
     * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
     * @param {string} name Name of the API key.
     * @param {boolean} [reveal] Reveal full key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public getApiKey(user: string, name: string, reveal?: boolean, options?: any) {
        return APIKeysApiFp(this.configuration).getApiKey(user, name, reveal, options)(this.fetch, this.basePath);
    }
    /**
     * List API key metadata for any user in your organization.
     * @summary List API Keys
     * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public listApiKeys(user: string, options?: any) {
        return APIKeysApiFp(this.configuration).listApiKeys(user, options)(this.fetch, this.basePath);
    }
    /**
     * Update the state of an API key for any user in your organization.
     * @summary Update API Key State
     * @param {string} name Name of the API key.
     * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
     * @param {UpdateApiKeyRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public updateApiKey(name: string, user: string, body: UpdateApiKeyRequest, options?: any) {
        return APIKeysApiFp(this.configuration).updateApiKey(name, user, body, options)(this.fetch, this.basePath);
    }
}

/**
 * AliasesApi - fetch parameter creator
 * @export
 */
export const AliasesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new alias in a workspace.
         * @summary Create Alias
         * @param {string} workspace name of the workspace
         * @param {CreateAliasRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlias(workspace: string, body: CreateAliasRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling createAlias.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createAlias.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/aliases`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateAliasRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an alias.
         * @summary Delete Alias
         * @param {string} workspace name of the workspace
         * @param {string} alias name of the alias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlias(workspace: string, alias: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling deleteAlias.');
            }
            // verify required parameter 'alias' is not null or undefined
            if (alias === null || alias === undefined) {
                throw new RequiredError('alias','Required parameter alias was null or undefined when calling deleteAlias.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/aliases/{alias}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"alias"}}`, encodeURIComponent(String(alias)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details about an alias
         * @summary Retrieve Alias
         * @param {string} workspace name of the workspace
         * @param {string} alias name of the alias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlias(workspace: string, alias: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling getAlias.');
            }
            // verify required parameter 'alias' is not null or undefined
            if (alias === null || alias === undefined) {
                throw new RequiredError('alias','Required parameter alias was null or undefined when calling getAlias.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/aliases/{alias}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"alias"}}`, encodeURIComponent(String(alias)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all aliases in an organization
         * @summary List Aliases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAliases(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/aliases`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update alias in a workspace.
         * @summary Update Alias
         * @param {string} workspace name of the workspace
         * @param {string} alias name of the alias
         * @param {UpdateAliasRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlias(workspace: string, alias: string, body: UpdateAliasRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling updateAlias.');
            }
            // verify required parameter 'alias' is not null or undefined
            if (alias === null || alias === undefined) {
                throw new RequiredError('alias','Required parameter alias was null or undefined when calling updateAlias.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateAlias.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/aliases/{alias}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"alias"}}`, encodeURIComponent(String(alias)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateAliasRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all aliases in a workspace.
         * @summary List Aliases in Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceAliases(workspace: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling workspaceAliases.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/aliases`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};
/**
 * AliasesApi - functional programming interface
 * @export
 */
export const AliasesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create new alias in a workspace.
         * @summary Create Alias
         * @param {string} workspace name of the workspace
         * @param {CreateAliasRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlias(workspace: string, body: CreateAliasRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateAliasResponse> {
            const localVarFetchArgs = AliasesApiFetchParamCreator(configuration).createAlias(workspace, body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an alias.
         * @summary Delete Alias
         * @param {string} workspace name of the workspace
         * @param {string} alias name of the alias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlias(workspace: string, alias: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteAliasResponse> {
            const localVarFetchArgs = AliasesApiFetchParamCreator(configuration).deleteAlias(workspace, alias, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get details about an alias
         * @summary Retrieve Alias
         * @param {string} workspace name of the workspace
         * @param {string} alias name of the alias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlias(workspace: string, alias: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAliasResponse> {
            const localVarFetchArgs = AliasesApiFetchParamCreator(configuration).getAlias(workspace, alias, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all aliases in an organization
         * @summary List Aliases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAliases(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListAliasesResponse> {
            const localVarFetchArgs = AliasesApiFetchParamCreator(configuration).listAliases(options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update alias in a workspace.
         * @summary Update Alias
         * @param {string} workspace name of the workspace
         * @param {string} alias name of the alias
         * @param {UpdateAliasRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlias(workspace: string, alias: string, body: UpdateAliasRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAliasResponse> {
            const localVarFetchArgs = AliasesApiFetchParamCreator(configuration).updateAlias(workspace, alias, body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all aliases in a workspace.
         * @summary List Aliases in Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceAliases(workspace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListAliasesResponse> {
            const localVarFetchArgs = AliasesApiFetchParamCreator(configuration).workspaceAliases(workspace, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AliasesApi - factory interface
 * @export
 */
export const AliasesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create new alias in a workspace.
         * @summary Create Alias
         * @param {string} workspace name of the workspace
         * @param {CreateAliasRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlias(workspace: string, body: CreateAliasRequest, options?: any) {
            return AliasesApiFp(configuration).createAlias(workspace, body, options)(fetch, basePath);
        },
        /**
         * Delete an alias.
         * @summary Delete Alias
         * @param {string} workspace name of the workspace
         * @param {string} alias name of the alias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlias(workspace: string, alias: string, options?: any) {
            return AliasesApiFp(configuration).deleteAlias(workspace, alias, options)(fetch, basePath);
        },
        /**
         * Get details about an alias
         * @summary Retrieve Alias
         * @param {string} workspace name of the workspace
         * @param {string} alias name of the alias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlias(workspace: string, alias: string, options?: any) {
            return AliasesApiFp(configuration).getAlias(workspace, alias, options)(fetch, basePath);
        },
        /**
         * Retrieve all aliases in an organization
         * @summary List Aliases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAliases(options?: any) {
            return AliasesApiFp(configuration).listAliases(options)(fetch, basePath);
        },
        /**
         * Update alias in a workspace.
         * @summary Update Alias
         * @param {string} workspace name of the workspace
         * @param {string} alias name of the alias
         * @param {UpdateAliasRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlias(workspace: string, alias: string, body: UpdateAliasRequest, options?: any) {
            return AliasesApiFp(configuration).updateAlias(workspace, alias, body, options)(fetch, basePath);
        },
        /**
         * Retrieve all aliases in a workspace.
         * @summary List Aliases in Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceAliases(workspace: string, options?: any) {
            return AliasesApiFp(configuration).workspaceAliases(workspace, options)(fetch, basePath);
        },
    };
};
/**
 * AliasesApi - object-oriented interface
 * @export
 * @class AliasesApi
 * @extends {BaseAPI}
 */
export class AliasesApi extends BaseAPI {
    /**
     * Create new alias in a workspace.
     * @summary Create Alias
     * @param {string} workspace name of the workspace
     * @param {CreateAliasRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    public createAlias(workspace: string, body: CreateAliasRequest, options?: any) {
        return AliasesApiFp(this.configuration).createAlias(workspace, body, options)(this.fetch, this.basePath);
    }
    /**
     * Delete an alias.
     * @summary Delete Alias
     * @param {string} workspace name of the workspace
     * @param {string} alias name of the alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    public deleteAlias(workspace: string, alias: string, options?: any) {
        return AliasesApiFp(this.configuration).deleteAlias(workspace, alias, options)(this.fetch, this.basePath);
    }
    /**
     * Get details about an alias
     * @summary Retrieve Alias
     * @param {string} workspace name of the workspace
     * @param {string} alias name of the alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    public getAlias(workspace: string, alias: string, options?: any) {
        return AliasesApiFp(this.configuration).getAlias(workspace, alias, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve all aliases in an organization
     * @summary List Aliases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    public listAliases(options?: any) {
        return AliasesApiFp(this.configuration).listAliases(options)(this.fetch, this.basePath);
    }
    /**
     * Update alias in a workspace.
     * @summary Update Alias
     * @param {string} workspace name of the workspace
     * @param {string} alias name of the alias
     * @param {UpdateAliasRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    public updateAlias(workspace: string, alias: string, body: UpdateAliasRequest, options?: any) {
        return AliasesApiFp(this.configuration).updateAlias(workspace, alias, body, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve all aliases in a workspace.
     * @summary List Aliases in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    public workspaceAliases(workspace: string, options?: any) {
        return AliasesApiFp(this.configuration).workspaceAliases(workspace, options)(this.fetch, this.basePath);
    }
}

/**
 * CollectionsApi - fetch parameter creator
 * @export
 */
export const CollectionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new collection in a workspace.
         * @summary Create Collection
         * @param {string} workspace name of the workspace
         * @param {CreateCollectionRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection(workspace: string, body: CreateCollectionRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling createCollection.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createCollection.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateCollectionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a collection and all its documents from Rockset.
         * @summary Delete Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollection(workspace: string, collection: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling deleteCollection.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling deleteCollection.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details about a collection.
         * @summary Retrieve Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection(workspace: string, collection: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling getCollection.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling getCollection.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Determines if the collection includes data at or after the specified fence(s) for close read-after-write semantics.
         * @summary Get Collection Commit
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {GetCollectionCommitRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionOffsets(workspace: string, collection: string, body: GetCollectionCommitRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling getCollectionOffsets.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling getCollectionOffsets.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getCollectionOffsets.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/offsets/commit`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GetCollectionCommitRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all collections in an organization.
         * @summary List Collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/collections`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update details about a collection.
         * @summary Update Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {UpdateCollectionRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollection(workspace: string, collection: string, body: UpdateCollectionRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling updateCollection.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling updateCollection.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateCollection.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateCollectionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all collections in a workspace.
         * @summary List Collections in Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceCollections(workspace: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling workspaceCollections.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};
/**
 * CollectionsApi - functional programming interface
 * @export
 */
export const CollectionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create new collection in a workspace.
         * @summary Create Collection
         * @param {string} workspace name of the workspace
         * @param {CreateCollectionRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection(workspace: string, body: CreateCollectionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateCollectionResponse> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).createCollection(workspace, body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a collection and all its documents from Rockset.
         * @summary Delete Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollection(workspace: string, collection: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteCollectionResponse> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).deleteCollection(workspace, collection, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get details about a collection.
         * @summary Retrieve Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection(workspace: string, collection: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCollectionResponse> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).getCollection(workspace, collection, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Determines if the collection includes data at or after the specified fence(s) for close read-after-write semantics.
         * @summary Get Collection Commit
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {GetCollectionCommitRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionOffsets(workspace: string, collection: string, body: GetCollectionCommitRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCollectionCommit> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).getCollectionOffsets(workspace, collection, body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all collections in an organization.
         * @summary List Collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListCollectionsResponse> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).listCollections(options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update details about a collection.
         * @summary Update Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {UpdateCollectionRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollection(workspace: string, collection: string, body: UpdateCollectionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCollectionResponse> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).updateCollection(workspace, collection, body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all collections in a workspace.
         * @summary List Collections in Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceCollections(workspace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListCollectionsResponse> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).workspaceCollections(workspace, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CollectionsApi - factory interface
 * @export
 */
export const CollectionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create new collection in a workspace.
         * @summary Create Collection
         * @param {string} workspace name of the workspace
         * @param {CreateCollectionRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection(workspace: string, body: CreateCollectionRequest, options?: any) {
            return CollectionsApiFp(configuration).createCollection(workspace, body, options)(fetch, basePath);
        },
        /**
         * Delete a collection and all its documents from Rockset.
         * @summary Delete Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollection(workspace: string, collection: string, options?: any) {
            return CollectionsApiFp(configuration).deleteCollection(workspace, collection, options)(fetch, basePath);
        },
        /**
         * Get details about a collection.
         * @summary Retrieve Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection(workspace: string, collection: string, options?: any) {
            return CollectionsApiFp(configuration).getCollection(workspace, collection, options)(fetch, basePath);
        },
        /**
         * Determines if the collection includes data at or after the specified fence(s) for close read-after-write semantics.
         * @summary Get Collection Commit
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {GetCollectionCommitRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionOffsets(workspace: string, collection: string, body: GetCollectionCommitRequest, options?: any) {
            return CollectionsApiFp(configuration).getCollectionOffsets(workspace, collection, body, options)(fetch, basePath);
        },
        /**
         * Retrieve all collections in an organization.
         * @summary List Collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections(options?: any) {
            return CollectionsApiFp(configuration).listCollections(options)(fetch, basePath);
        },
        /**
         * Update details about a collection.
         * @summary Update Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {UpdateCollectionRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollection(workspace: string, collection: string, body: UpdateCollectionRequest, options?: any) {
            return CollectionsApiFp(configuration).updateCollection(workspace, collection, body, options)(fetch, basePath);
        },
        /**
         * Retrieve all collections in a workspace.
         * @summary List Collections in Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceCollections(workspace: string, options?: any) {
            return CollectionsApiFp(configuration).workspaceCollections(workspace, options)(fetch, basePath);
        },
    };
};
/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
export class CollectionsApi extends BaseAPI {
    /**
     * Create new collection in a workspace.
     * @summary Create Collection
     * @param {string} workspace name of the workspace
     * @param {CreateCollectionRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public createCollection(workspace: string, body: CreateCollectionRequest, options?: any) {
        return CollectionsApiFp(this.configuration).createCollection(workspace, body, options)(this.fetch, this.basePath);
    }
    /**
     * Delete a collection and all its documents from Rockset.
     * @summary Delete Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public deleteCollection(workspace: string, collection: string, options?: any) {
        return CollectionsApiFp(this.configuration).deleteCollection(workspace, collection, options)(this.fetch, this.basePath);
    }
    /**
     * Get details about a collection.
     * @summary Retrieve Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getCollection(workspace: string, collection: string, options?: any) {
        return CollectionsApiFp(this.configuration).getCollection(workspace, collection, options)(this.fetch, this.basePath);
    }
    /**
     * Determines if the collection includes data at or after the specified fence(s) for close read-after-write semantics.
     * @summary Get Collection Commit
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {GetCollectionCommitRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getCollectionOffsets(workspace: string, collection: string, body: GetCollectionCommitRequest, options?: any) {
        return CollectionsApiFp(this.configuration).getCollectionOffsets(workspace, collection, body, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve all collections in an organization.
     * @summary List Collections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public listCollections(options?: any) {
        return CollectionsApiFp(this.configuration).listCollections(options)(this.fetch, this.basePath);
    }
    /**
     * Update details about a collection.
     * @summary Update Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {UpdateCollectionRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public updateCollection(workspace: string, collection: string, body: UpdateCollectionRequest, options?: any) {
        return CollectionsApiFp(this.configuration).updateCollection(workspace, collection, body, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve all collections in a workspace.
     * @summary List Collections in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public workspaceCollections(workspace: string, options?: any) {
        return CollectionsApiFp(this.configuration).workspaceCollections(workspace, options)(this.fetch, this.basePath);
    }
}

/**
 * CustomRolesApi - fetch parameter creator
 * @export
 */
export const CustomRolesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a role for your organization.
         * @summary Create a Role
         * @param {CreateRoleRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(body: CreateRoleRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRole.');
            }
            const localVarPath = `/v1/orgs/self/roles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateRoleRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a role for your organization.
         * @summary Delete a Role
         * @param {string} roleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(roleName: string, options: any = {}): FetchArgs {
            // verify required parameter 'roleName' is not null or undefined
            if (roleName === null || roleName === undefined) {
                throw new RequiredError('roleName','Required parameter roleName was null or undefined when calling deleteRole.');
            }
            const localVarPath = `/v1/orgs/self/roles/{roleName}`
                .replace(`{${"roleName"}}`, encodeURIComponent(String(roleName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a role by name for your organization.
         * @summary Retrieve role
         * @param {string} roleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole(roleName: string, options: any = {}): FetchArgs {
            // verify required parameter 'roleName' is not null or undefined
            if (roleName === null || roleName === undefined) {
                throw new RequiredError('roleName','Required parameter roleName was null or undefined when calling getRole.');
            }
            const localVarPath = `/v1/orgs/self/roles/{roleName}`
                .replace(`{${"roleName"}}`, encodeURIComponent(String(roleName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all roles for your organization.
         * @summary List Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/roles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a role for your organization.
         * @summary Update a Role
         * @param {string} roleName 
         * @param {UpdateRoleRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(roleName: string, body: UpdateRoleRequest, options: any = {}): FetchArgs {
            // verify required parameter 'roleName' is not null or undefined
            if (roleName === null || roleName === undefined) {
                throw new RequiredError('roleName','Required parameter roleName was null or undefined when calling updateRole.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateRole.');
            }
            const localVarPath = `/v1/orgs/self/roles/{roleName}`
                .replace(`{${"roleName"}}`, encodeURIComponent(String(roleName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateRoleRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};
/**
 * CustomRolesApi - functional programming interface
 * @export
 */
export const CustomRolesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a role for your organization.
         * @summary Create a Role
         * @param {CreateRoleRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(body: CreateRoleRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleResponse> {
            const localVarFetchArgs = CustomRolesApiFetchParamCreator(configuration).createRole(body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a role for your organization.
         * @summary Delete a Role
         * @param {string} roleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(roleName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleResponse> {
            const localVarFetchArgs = CustomRolesApiFetchParamCreator(configuration).deleteRole(roleName, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve a role by name for your organization.
         * @summary Retrieve role
         * @param {string} roleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole(roleName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleResponse> {
            const localVarFetchArgs = CustomRolesApiFetchParamCreator(configuration).getRole(roleName, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all roles for your organization.
         * @summary List Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListRolesResponse> {
            const localVarFetchArgs = CustomRolesApiFetchParamCreator(configuration).listRoles(options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a role for your organization.
         * @summary Update a Role
         * @param {string} roleName 
         * @param {UpdateRoleRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(roleName: string, body: UpdateRoleRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleResponse> {
            const localVarFetchArgs = CustomRolesApiFetchParamCreator(configuration).updateRole(roleName, body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomRolesApi - factory interface
 * @export
 */
export const CustomRolesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a role for your organization.
         * @summary Create a Role
         * @param {CreateRoleRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(body: CreateRoleRequest, options?: any) {
            return CustomRolesApiFp(configuration).createRole(body, options)(fetch, basePath);
        },
        /**
         * Delete a role for your organization.
         * @summary Delete a Role
         * @param {string} roleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(roleName: string, options?: any) {
            return CustomRolesApiFp(configuration).deleteRole(roleName, options)(fetch, basePath);
        },
        /**
         * Retrieve a role by name for your organization.
         * @summary Retrieve role
         * @param {string} roleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole(roleName: string, options?: any) {
            return CustomRolesApiFp(configuration).getRole(roleName, options)(fetch, basePath);
        },
        /**
         * List all roles for your organization.
         * @summary List Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(options?: any) {
            return CustomRolesApiFp(configuration).listRoles(options)(fetch, basePath);
        },
        /**
         * Update a role for your organization.
         * @summary Update a Role
         * @param {string} roleName 
         * @param {UpdateRoleRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(roleName: string, body: UpdateRoleRequest, options?: any) {
            return CustomRolesApiFp(configuration).updateRole(roleName, body, options)(fetch, basePath);
        },
    };
};
/**
 * CustomRolesApi - object-oriented interface
 * @export
 * @class CustomRolesApi
 * @extends {BaseAPI}
 */
export class CustomRolesApi extends BaseAPI {
    /**
     * Create a role for your organization.
     * @summary Create a Role
     * @param {CreateRoleRequest} body JSON Object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesApi
     */
    public createRole(body: CreateRoleRequest, options?: any) {
        return CustomRolesApiFp(this.configuration).createRole(body, options)(this.fetch, this.basePath);
    }
    /**
     * Delete a role for your organization.
     * @summary Delete a Role
     * @param {string} roleName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesApi
     */
    public deleteRole(roleName: string, options?: any) {
        return CustomRolesApiFp(this.configuration).deleteRole(roleName, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve a role by name for your organization.
     * @summary Retrieve role
     * @param {string} roleName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesApi
     */
    public getRole(roleName: string, options?: any) {
        return CustomRolesApiFp(this.configuration).getRole(roleName, options)(this.fetch, this.basePath);
    }
    /**
     * List all roles for your organization.
     * @summary List Roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesApi
     */
    public listRoles(options?: any) {
        return CustomRolesApiFp(this.configuration).listRoles(options)(this.fetch, this.basePath);
    }
    /**
     * Update a role for your organization.
     * @summary Update a Role
     * @param {string} roleName 
     * @param {UpdateRoleRequest} body JSON Object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesApi
     */
    public updateRole(roleName: string, body: UpdateRoleRequest, options?: any) {
        return CustomRolesApiFp(this.configuration).updateRole(roleName, body, options)(this.fetch, this.basePath);
    }
}

/**
 * DeploymentSettingsApi - fetch parameter creator
 * @export
 */
export const DeploymentSettingsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve settings for the current deployment.
         * @summary Retrieve Deployment Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentSettings(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/deploymentsettings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update settings for the current deployment.
         * @summary Update Deployment Settings
         * @param {UpdateDeploymentSettingsRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeploymentSettings(body: UpdateDeploymentSettingsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateDeploymentSettings.');
            }
            const localVarPath = `/v1/orgs/self/deploymentsettings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateDeploymentSettingsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};
/**
 * DeploymentSettingsApi - functional programming interface
 * @export
 */
export const DeploymentSettingsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve settings for the current deployment.
         * @summary Retrieve Deployment Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentSettings(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeploymentSettingsResponse> {
            const localVarFetchArgs = DeploymentSettingsApiFetchParamCreator(configuration).getDeploymentSettings(options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update settings for the current deployment.
         * @summary Update Deployment Settings
         * @param {UpdateDeploymentSettingsRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeploymentSettings(body: UpdateDeploymentSettingsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeploymentSettingsResponse> {
            const localVarFetchArgs = DeploymentSettingsApiFetchParamCreator(configuration).updateDeploymentSettings(body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DeploymentSettingsApi - factory interface
 * @export
 */
export const DeploymentSettingsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve settings for the current deployment.
         * @summary Retrieve Deployment Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentSettings(options?: any) {
            return DeploymentSettingsApiFp(configuration).getDeploymentSettings(options)(fetch, basePath);
        },
        /**
         * Update settings for the current deployment.
         * @summary Update Deployment Settings
         * @param {UpdateDeploymentSettingsRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeploymentSettings(body: UpdateDeploymentSettingsRequest, options?: any) {
            return DeploymentSettingsApiFp(configuration).updateDeploymentSettings(body, options)(fetch, basePath);
        },
    };
};
/**
 * DeploymentSettingsApi - object-oriented interface
 * @export
 * @class DeploymentSettingsApi
 * @extends {BaseAPI}
 */
export class DeploymentSettingsApi extends BaseAPI {
    /**
     * Retrieve settings for the current deployment.
     * @summary Retrieve Deployment Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentSettingsApi
     */
    public getDeploymentSettings(options?: any) {
        return DeploymentSettingsApiFp(this.configuration).getDeploymentSettings(options)(this.fetch, this.basePath);
    }
    /**
     * Update settings for the current deployment.
     * @summary Update Deployment Settings
     * @param {UpdateDeploymentSettingsRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentSettingsApi
     */
    public updateDeploymentSettings(body: UpdateDeploymentSettingsRequest, options?: any) {
        return DeploymentSettingsApiFp(this.configuration).updateDeploymentSettings(body, options)(this.fetch, this.basePath);
    }
}

/**
 * DocumentsApi - fetch parameter creator
 * @export
 */
export const DocumentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add documents to a collection.
         * @summary Add Documents
         * @param {string} workspace Name of the workspace.
         * @param {string} collection Name of the collection.
         * @param {AddDocumentsRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocuments(workspace: string, collection: string, body: AddDocumentsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling addDocuments.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling addDocuments.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addDocuments.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/docs`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddDocumentsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete documents from a collection.
         * @summary Delete Documents
         * @param {string} workspace Name of the workspace.
         * @param {string} collection Name of the collection.
         * @param {DeleteDocumentsRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocuments(workspace: string, collection: string, body: DeleteDocumentsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling deleteDocuments.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling deleteDocuments.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deleteDocuments.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/docs`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeleteDocumentsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing documents in a collection.
         * @summary Patch Documents
         * @param {string} workspace Name of the workspace.
         * @param {string} collection Name of the collection.
         * @param {PatchDocumentsRequest} body JSON Patch objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDocuments(workspace: string, collection: string, body: PatchDocumentsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling patchDocuments.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling patchDocuments.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchDocuments.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/docs`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PatchDocumentsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};
/**
 * DocumentsApi - functional programming interface
 * @export
 */
export const DocumentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add documents to a collection.
         * @summary Add Documents
         * @param {string} workspace Name of the workspace.
         * @param {string} collection Name of the collection.
         * @param {AddDocumentsRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocuments(workspace: string, collection: string, body: AddDocumentsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddDocumentsResponse> {
            const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).addDocuments(workspace, collection, body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete documents from a collection.
         * @summary Delete Documents
         * @param {string} workspace Name of the workspace.
         * @param {string} collection Name of the collection.
         * @param {DeleteDocumentsRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocuments(workspace: string, collection: string, body: DeleteDocumentsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteDocumentsResponse> {
            const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).deleteDocuments(workspace, collection, body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update existing documents in a collection.
         * @summary Patch Documents
         * @param {string} workspace Name of the workspace.
         * @param {string} collection Name of the collection.
         * @param {PatchDocumentsRequest} body JSON Patch objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDocuments(workspace: string, collection: string, body: PatchDocumentsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PatchDocumentsResponse> {
            const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).patchDocuments(workspace, collection, body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DocumentsApi - factory interface
 * @export
 */
export const DocumentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Add documents to a collection.
         * @summary Add Documents
         * @param {string} workspace Name of the workspace.
         * @param {string} collection Name of the collection.
         * @param {AddDocumentsRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocuments(workspace: string, collection: string, body: AddDocumentsRequest, options?: any) {
            return DocumentsApiFp(configuration).addDocuments(workspace, collection, body, options)(fetch, basePath);
        },
        /**
         * Delete documents from a collection.
         * @summary Delete Documents
         * @param {string} workspace Name of the workspace.
         * @param {string} collection Name of the collection.
         * @param {DeleteDocumentsRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocuments(workspace: string, collection: string, body: DeleteDocumentsRequest, options?: any) {
            return DocumentsApiFp(configuration).deleteDocuments(workspace, collection, body, options)(fetch, basePath);
        },
        /**
         * Update existing documents in a collection.
         * @summary Patch Documents
         * @param {string} workspace Name of the workspace.
         * @param {string} collection Name of the collection.
         * @param {PatchDocumentsRequest} body JSON Patch objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDocuments(workspace: string, collection: string, body: PatchDocumentsRequest, options?: any) {
            return DocumentsApiFp(configuration).patchDocuments(workspace, collection, body, options)(fetch, basePath);
        },
    };
};
/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export class DocumentsApi extends BaseAPI {
    /**
     * Add documents to a collection.
     * @summary Add Documents
     * @param {string} workspace Name of the workspace.
     * @param {string} collection Name of the collection.
     * @param {AddDocumentsRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public addDocuments(workspace: string, collection: string, body: AddDocumentsRequest, options?: any) {
        return DocumentsApiFp(this.configuration).addDocuments(workspace, collection, body, options)(this.fetch, this.basePath);
    }
    /**
     * Delete documents from a collection.
     * @summary Delete Documents
     * @param {string} workspace Name of the workspace.
     * @param {string} collection Name of the collection.
     * @param {DeleteDocumentsRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public deleteDocuments(workspace: string, collection: string, body: DeleteDocumentsRequest, options?: any) {
        return DocumentsApiFp(this.configuration).deleteDocuments(workspace, collection, body, options)(this.fetch, this.basePath);
    }
    /**
     * Update existing documents in a collection.
     * @summary Patch Documents
     * @param {string} workspace Name of the workspace.
     * @param {string} collection Name of the collection.
     * @param {PatchDocumentsRequest} body JSON Patch objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public patchDocuments(workspace: string, collection: string, body: PatchDocumentsRequest, options?: any) {
        return DocumentsApiFp(this.configuration).patchDocuments(workspace, collection, body, options)(this.fetch, this.basePath);
    }
}

/**
 * IntegrationsApi - fetch parameter creator
 * @export
 */
export const IntegrationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new integration.
         * @summary Create Integration
         * @param {CreateIntegrationRequest} body integration credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIntegration(body: CreateIntegrationRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createIntegration.');
            }
            const localVarPath = `/v1/orgs/self/integrations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateIntegrationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an integration.
         * @summary Delete Integration
         * @param {string} integration name of the integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIntegration(integration: string, options: any = {}): FetchArgs {
            // verify required parameter 'integration' is not null or undefined
            if (integration === null || integration === undefined) {
                throw new RequiredError('integration','Required parameter integration was null or undefined when calling deleteIntegration.');
            }
            const localVarPath = `/v1/orgs/self/integrations/{integration}`
                .replace(`{${"integration"}}`, encodeURIComponent(String(integration)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information about a single integration.
         * @summary Retrieve Integration
         * @param {string} integration name of the integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegration(integration: string, options: any = {}): FetchArgs {
            // verify required parameter 'integration' is not null or undefined
            if (integration === null || integration === undefined) {
                throw new RequiredError('integration','Required parameter integration was null or undefined when calling getIntegration.');
            }
            const localVarPath = `/v1/orgs/self/integrations/{integration}`
                .replace(`{${"integration"}}`, encodeURIComponent(String(integration)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all integrations in an organization.
         * @summary List Integrations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIntegrations(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/integrations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing integration.
         * @summary Update Integration
         * @param {string} integration 
         * @param {UpdateIntegrationRequest} body integration configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIntegration(integration: string, body: UpdateIntegrationRequest, options: any = {}): FetchArgs {
            // verify required parameter 'integration' is not null or undefined
            if (integration === null || integration === undefined) {
                throw new RequiredError('integration','Required parameter integration was null or undefined when calling updateIntegration.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateIntegration.');
            }
            const localVarPath = `/v1/orgs/self/integrations/{integration}`
                .replace(`{${"integration"}}`, encodeURIComponent(String(integration)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateIntegrationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};
/**
 * IntegrationsApi - functional programming interface
 * @export
 */
export const IntegrationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new integration.
         * @summary Create Integration
         * @param {CreateIntegrationRequest} body integration credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIntegration(body: CreateIntegrationRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateIntegrationResponse> {
            const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).createIntegration(body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove an integration.
         * @summary Delete Integration
         * @param {string} integration name of the integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIntegration(integration: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteIntegrationResponse> {
            const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).deleteIntegration(integration, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve information about a single integration.
         * @summary Retrieve Integration
         * @param {string} integration name of the integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegration(integration: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetIntegrationResponse> {
            const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).getIntegration(integration, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all integrations in an organization.
         * @summary List Integrations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIntegrations(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListIntegrationsResponse> {
            const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).listIntegrations(options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update an existing integration.
         * @summary Update Integration
         * @param {string} integration 
         * @param {UpdateIntegrationRequest} body integration configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIntegration(integration: string, body: UpdateIntegrationRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpdateIntegrationResponse> {
            const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).updateIntegration(integration, body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * IntegrationsApi - factory interface
 * @export
 */
export const IntegrationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new integration.
         * @summary Create Integration
         * @param {CreateIntegrationRequest} body integration credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIntegration(body: CreateIntegrationRequest, options?: any) {
            return IntegrationsApiFp(configuration).createIntegration(body, options)(fetch, basePath);
        },
        /**
         * Remove an integration.
         * @summary Delete Integration
         * @param {string} integration name of the integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIntegration(integration: string, options?: any) {
            return IntegrationsApiFp(configuration).deleteIntegration(integration, options)(fetch, basePath);
        },
        /**
         * Retrieve information about a single integration.
         * @summary Retrieve Integration
         * @param {string} integration name of the integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegration(integration: string, options?: any) {
            return IntegrationsApiFp(configuration).getIntegration(integration, options)(fetch, basePath);
        },
        /**
         * List all integrations in an organization.
         * @summary List Integrations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIntegrations(options?: any) {
            return IntegrationsApiFp(configuration).listIntegrations(options)(fetch, basePath);
        },
        /**
         * Update an existing integration.
         * @summary Update Integration
         * @param {string} integration 
         * @param {UpdateIntegrationRequest} body integration configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIntegration(integration: string, body: UpdateIntegrationRequest, options?: any) {
            return IntegrationsApiFp(configuration).updateIntegration(integration, body, options)(fetch, basePath);
        },
    };
};
/**
 * IntegrationsApi - object-oriented interface
 * @export
 * @class IntegrationsApi
 * @extends {BaseAPI}
 */
export class IntegrationsApi extends BaseAPI {
    /**
     * Create a new integration.
     * @summary Create Integration
     * @param {CreateIntegrationRequest} body integration credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public createIntegration(body: CreateIntegrationRequest, options?: any) {
        return IntegrationsApiFp(this.configuration).createIntegration(body, options)(this.fetch, this.basePath);
    }
    /**
     * Remove an integration.
     * @summary Delete Integration
     * @param {string} integration name of the integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public deleteIntegration(integration: string, options?: any) {
        return IntegrationsApiFp(this.configuration).deleteIntegration(integration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve information about a single integration.
     * @summary Retrieve Integration
     * @param {string} integration name of the integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getIntegration(integration: string, options?: any) {
        return IntegrationsApiFp(this.configuration).getIntegration(integration, options)(this.fetch, this.basePath);
    }
    /**
     * List all integrations in an organization.
     * @summary List Integrations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public listIntegrations(options?: any) {
        return IntegrationsApiFp(this.configuration).listIntegrations(options)(this.fetch, this.basePath);
    }
    /**
     * Update an existing integration.
     * @summary Update Integration
     * @param {string} integration 
     * @param {UpdateIntegrationRequest} body integration configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public updateIntegration(integration: string, body: UpdateIntegrationRequest, options?: any) {
        return IntegrationsApiFp(this.configuration).updateIntegration(integration, body, options)(this.fetch, this.basePath);
    }
}

/**
 * OrganizationsApi - fetch parameter creator
 * @export
 */
export const OrganizationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve information about current organization.
         * @summary Get Organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};
/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve information about current organization.
         * @summary Get Organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrganizationResponse> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getOrganization(options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve information about current organization.
         * @summary Get Organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(options?: any) {
            return OrganizationsApiFp(configuration).getOrganization(options)(fetch, basePath);
        },
    };
};
/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI {
    /**
     * Retrieve information about current organization.
     * @summary Get Organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganization(options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganization(options)(this.fetch, this.basePath);
    }
}

/**
 * QueriesApi - fetch parameter creator
 * @export
 */
export const QueriesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Attempts to cancel an actively-running query.
         * @summary Cancel Query
         * @param {string} queryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelQuery(queryId: string, options: any = {}): FetchArgs {
            // verify required parameter 'queryId' is not null or undefined
            if (queryId === null || queryId === undefined) {
                throw new RequiredError('queryId','Required parameter queryId was null or undefined when calling cancelQuery.');
            }
            const localVarPath = `/v1/orgs/self/queries/{queryId}`
                .replace(`{${"queryId"}}`, encodeURIComponent(String(queryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about a query.
         * @summary Retrieve Query
         * @param {string} queryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuery(queryId: string, options: any = {}): FetchArgs {
            // verify required parameter 'queryId' is not null or undefined
            if (queryId === null || queryId === undefined) {
                throw new RequiredError('queryId','Required parameter queryId was null or undefined when calling getQuery.');
            }
            const localVarPath = `/v1/orgs/self/queries/{queryId}`
                .replace(`{${"queryId"}}`, encodeURIComponent(String(queryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a page of query results.
         * @summary Retrieve Query Results Page
         * @param {string} queryId 
         * @param {string} [cursor] Cursor to current page. If unset, will default to the first page.
         * @param {number} [docs] Number of documents to fetch.
         * @param {number} [offset] Offset from the cursor of the first document to be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryResults(queryId: string, cursor?: string, docs?: number, offset?: number, options: any = {}): FetchArgs {
            // verify required parameter 'queryId' is not null or undefined
            if (queryId === null || queryId === undefined) {
                throw new RequiredError('queryId','Required parameter queryId was null or undefined when calling getQueryResults.');
            }
            const localVarPath = `/v1/orgs/self/queries/{queryId}/pages`
                .replace(`{${"queryId"}}`, encodeURIComponent(String(queryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            if (docs !== undefined) {
                localVarQueryParameter['docs'] = docs;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists actively queued and running queries.
         * @summary List Queries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActiveQueries(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/queries`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Make a SQL query to Rockset. If you want to issue the query to a specific Virtual Instance use this https://docs.rockset.com/documentation/reference/queryvirtualinstance
         * @summary Execute SQL Query
         * @param {QueryRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        query(body: QueryRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling query.');
            }
            const localVarPath = `/v1/orgs/self/queries`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QueryRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate a SQL query with Rockset's parser and planner.
         * @summary Validate Query
         * @param {QueryRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validate(body: QueryRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling validate.');
            }
            const localVarPath = `/v1/orgs/self/queries/validations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QueryRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};
/**
 * QueriesApi - functional programming interface
 * @export
 */
export const QueriesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Attempts to cancel an actively-running query.
         * @summary Cancel Query
         * @param {string} queryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelQuery(queryId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CancelQueryResponse> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).cancelQuery(queryId, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns information about a query.
         * @summary Retrieve Query
         * @param {string} queryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuery(queryId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetQueryResponse> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).getQuery(queryId, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a page of query results.
         * @summary Retrieve Query Results Page
         * @param {string} queryId 
         * @param {string} [cursor] Cursor to current page. If unset, will default to the first page.
         * @param {number} [docs] Number of documents to fetch.
         * @param {number} [offset] Offset from the cursor of the first document to be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryResults(queryId: string, cursor?: string, docs?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryPaginationResponse> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).getQueryResults(queryId, cursor, docs, offset, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists actively queued and running queries.
         * @summary List Queries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActiveQueries(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueriesResponse> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).listActiveQueries(options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Make a SQL query to Rockset. If you want to issue the query to a specific Virtual Instance use this https://docs.rockset.com/documentation/reference/queryvirtualinstance
         * @summary Execute SQL Query
         * @param {QueryRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        query(body: QueryRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryResponse> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).query(body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Validate a SQL query with Rockset's parser and planner.
         * @summary Validate Query
         * @param {QueryRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validate(body: QueryRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ValidateQueryResponse> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).validate(body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QueriesApi - factory interface
 * @export
 */
export const QueriesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Attempts to cancel an actively-running query.
         * @summary Cancel Query
         * @param {string} queryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelQuery(queryId: string, options?: any) {
            return QueriesApiFp(configuration).cancelQuery(queryId, options)(fetch, basePath);
        },
        /**
         * Returns information about a query.
         * @summary Retrieve Query
         * @param {string} queryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuery(queryId: string, options?: any) {
            return QueriesApiFp(configuration).getQuery(queryId, options)(fetch, basePath);
        },
        /**
         * Returns a page of query results.
         * @summary Retrieve Query Results Page
         * @param {string} queryId 
         * @param {string} [cursor] Cursor to current page. If unset, will default to the first page.
         * @param {number} [docs] Number of documents to fetch.
         * @param {number} [offset] Offset from the cursor of the first document to be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryResults(queryId: string, cursor?: string, docs?: number, offset?: number, options?: any) {
            return QueriesApiFp(configuration).getQueryResults(queryId, cursor, docs, offset, options)(fetch, basePath);
        },
        /**
         * Lists actively queued and running queries.
         * @summary List Queries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActiveQueries(options?: any) {
            return QueriesApiFp(configuration).listActiveQueries(options)(fetch, basePath);
        },
        /**
         * Make a SQL query to Rockset. If you want to issue the query to a specific Virtual Instance use this https://docs.rockset.com/documentation/reference/queryvirtualinstance
         * @summary Execute SQL Query
         * @param {QueryRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        query(body: QueryRequest, options?: any) {
            return QueriesApiFp(configuration).query(body, options)(fetch, basePath);
        },
        /**
         * Validate a SQL query with Rockset's parser and planner.
         * @summary Validate Query
         * @param {QueryRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validate(body: QueryRequest, options?: any) {
            return QueriesApiFp(configuration).validate(body, options)(fetch, basePath);
        },
    };
};
/**
 * QueriesApi - object-oriented interface
 * @export
 * @class QueriesApi
 * @extends {BaseAPI}
 */
export class QueriesApi extends BaseAPI {
    /**
     * Attempts to cancel an actively-running query.
     * @summary Cancel Query
     * @param {string} queryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public cancelQuery(queryId: string, options?: any) {
        return QueriesApiFp(this.configuration).cancelQuery(queryId, options)(this.fetch, this.basePath);
    }
    /**
     * Returns information about a query.
     * @summary Retrieve Query
     * @param {string} queryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public getQuery(queryId: string, options?: any) {
        return QueriesApiFp(this.configuration).getQuery(queryId, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a page of query results.
     * @summary Retrieve Query Results Page
     * @param {string} queryId 
     * @param {string} [cursor] Cursor to current page. If unset, will default to the first page.
     * @param {number} [docs] Number of documents to fetch.
     * @param {number} [offset] Offset from the cursor of the first document to be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public getQueryResults(queryId: string, cursor?: string, docs?: number, offset?: number, options?: any) {
        return QueriesApiFp(this.configuration).getQueryResults(queryId, cursor, docs, offset, options)(this.fetch, this.basePath);
    }
    /**
     * Lists actively queued and running queries.
     * @summary List Queries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public listActiveQueries(options?: any) {
        return QueriesApiFp(this.configuration).listActiveQueries(options)(this.fetch, this.basePath);
    }
    /**
     * Make a SQL query to Rockset. If you want to issue the query to a specific Virtual Instance use this https://docs.rockset.com/documentation/reference/queryvirtualinstance
     * @summary Execute SQL Query
     * @param {QueryRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public query(body: QueryRequest, options?: any) {
        return QueriesApiFp(this.configuration).query(body, options)(this.fetch, this.basePath);
    }
    /**
     * Validate a SQL query with Rockset's parser and planner.
     * @summary Validate Query
     * @param {QueryRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public validate(body: QueryRequest, options?: any) {
        return QueriesApiFp(this.configuration).validate(body, options)(this.fetch, this.basePath);
    }
}

/**
 * QueryLambdasApi - fetch parameter creator
 * @export
 */
export const QueryLambdasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a Query Lambda in given workspace.
         * @summary Create Query Lambda
         * @param {string} workspace name of the workspace
         * @param {CreateQueryLambdaRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueryLambda(workspace: string, body: CreateQueryLambdaRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling createQueryLambda.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createQueryLambda.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateQueryLambdaRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a tag for a specific Query Lambda version, or update that tag if it already exists.
         * @summary Create Query Lambda Tag
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {CreateQueryLambdaTagRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueryLambdaTag(workspace: string, queryLambda: string, body: CreateQueryLambdaTagRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling createQueryLambdaTag.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling createQueryLambdaTag.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createQueryLambdaTag.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/tags`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateQueryLambdaTagRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Query Lambda.
         * @summary Delete Query Lambda
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueryLambda(workspace: string, queryLambda: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling deleteQueryLambda.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling deleteQueryLambda.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a tag for a specific Query Lambda
         * @summary Delete Query Lambda Tag Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} tag name of the tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueryLambdaTag(workspace: string, queryLambda: string, tag: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling deleteQueryLambdaTag.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling deleteQueryLambdaTag.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling deleteQueryLambdaTag.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/tags/{tag}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Query Lambda version.
         * @summary Delete Query Lambda Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} version version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling deleteQueryLambdaVersion.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling deleteQueryLambdaVersion.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling deleteQueryLambdaVersion.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/version/{version}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Execute a particular version of a Query Lambda.
         * @summary Execute Query Lambda By Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} version version
         * @param {ExecuteQueryLambdaRequest} [body] JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeQueryLambda(workspace: string, queryLambda: string, version: string, body?: ExecuteQueryLambdaRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling executeQueryLambda.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling executeQueryLambda.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling executeQueryLambda.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/versions/{version}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ExecuteQueryLambdaRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Execute the Query Lambda version associated with a given tag.
         * @summary Execute Query Lambda By Tag
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} tag tag
         * @param {ExecuteQueryLambdaRequest} [body] JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeQueryLambdaByTag(workspace: string, queryLambda: string, tag: string, body?: ExecuteQueryLambdaRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling executeQueryLambdaByTag.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling executeQueryLambdaByTag.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling executeQueryLambdaByTag.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/tags/{tag}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ExecuteQueryLambdaRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the Query Lambda version associated with a given tag.
         * @summary Retrieve Query Lambda Tag
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} tag name of the tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryLambdaTagVersion(workspace: string, queryLambda: string, tag: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling getQueryLambdaTagVersion.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling getQueryLambdaTagVersion.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling getQueryLambdaTagVersion.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/tags/{tag}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details for a specified version of a Query Lambda.
         * @summary Retrieve Query Lambda Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} version version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling getQueryLambdaVersion.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling getQueryLambdaVersion.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling getQueryLambdaVersion.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/versions/{version}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all Query Lambdas in an organization.
         * @summary List Query Lambdas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllQueryLambdas(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/lambdas`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all tags associated with a Query Lambda
         * @summary List Query Lambda Tags
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdaTags(workspace: string, queryLambda: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling listQueryLambdaTags.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling listQueryLambdaTags.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/tags`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all versions of a Query Lambda.
         * @summary List Query Lambda Versions
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdaVersions(workspace: string, queryLambda: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling listQueryLambdaVersions.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling listQueryLambdaVersions.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/versions`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all Query Lambdas under given workspace.
         * @summary List Query Lambdas in Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdasInWorkspace(workspace: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling listQueryLambdasInWorkspace.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new version of a Query Lambda in given workspace.
         * @summary Update Query Lambda
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {UpdateQueryLambdaRequest} body JSON object
         * @param {boolean} [create] Create a new Query Lambda if one does not exist already.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQueryLambda(workspace: string, queryLambda: string, body: UpdateQueryLambdaRequest, create?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling updateQueryLambda.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling updateQueryLambda.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateQueryLambda.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/versions`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            if (create !== undefined) {
                localVarQueryParameter['create'] = create;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateQueryLambdaRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};
/**
 * QueryLambdasApi - functional programming interface
 * @export
 */
export const QueryLambdasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a Query Lambda in given workspace.
         * @summary Create Query Lambda
         * @param {string} workspace name of the workspace
         * @param {CreateQueryLambdaRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueryLambda(workspace: string, body: CreateQueryLambdaRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryLambdaVersionResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).createQueryLambda(workspace, body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a tag for a specific Query Lambda version, or update that tag if it already exists.
         * @summary Create Query Lambda Tag
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {CreateQueryLambdaTagRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueryLambdaTag(workspace: string, queryLambda: string, body: CreateQueryLambdaTagRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryLambdaTagResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).createQueryLambdaTag(workspace, queryLambda, body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a Query Lambda.
         * @summary Delete Query Lambda
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueryLambda(workspace: string, queryLambda: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteQueryLambdaResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).deleteQueryLambda(workspace, queryLambda, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a tag for a specific Query Lambda
         * @summary Delete Query Lambda Tag Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} tag name of the tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueryLambdaTag(workspace: string, queryLambda: string, tag: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryLambdaTagResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).deleteQueryLambdaTag(workspace, queryLambda, tag, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a Query Lambda version.
         * @summary Delete Query Lambda Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} version version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryLambdaVersionResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).deleteQueryLambdaVersion(workspace, queryLambda, version, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Execute a particular version of a Query Lambda.
         * @summary Execute Query Lambda By Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} version version
         * @param {ExecuteQueryLambdaRequest} [body] JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeQueryLambda(workspace: string, queryLambda: string, version: string, body?: ExecuteQueryLambdaRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).executeQueryLambda(workspace, queryLambda, version, body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Execute the Query Lambda version associated with a given tag.
         * @summary Execute Query Lambda By Tag
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} tag tag
         * @param {ExecuteQueryLambdaRequest} [body] JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeQueryLambdaByTag(workspace: string, queryLambda: string, tag: string, body?: ExecuteQueryLambdaRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).executeQueryLambdaByTag(workspace, queryLambda, tag, body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve the Query Lambda version associated with a given tag.
         * @summary Retrieve Query Lambda Tag
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} tag name of the tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryLambdaTagVersion(workspace: string, queryLambda: string, tag: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryLambdaTagResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).getQueryLambdaTagVersion(workspace, queryLambda, tag, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve details for a specified version of a Query Lambda.
         * @summary Retrieve Query Lambda Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} version version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryLambdaVersionResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).getQueryLambdaVersion(workspace, queryLambda, version, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all Query Lambdas in an organization.
         * @summary List Query Lambdas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllQueryLambdas(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueryLambdasResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).listAllQueryLambdas(options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all tags associated with a Query Lambda
         * @summary List Query Lambda Tags
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdaTags(workspace: string, queryLambda: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueryLambdaTagsResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).listQueryLambdaTags(workspace, queryLambda, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all versions of a Query Lambda.
         * @summary List Query Lambda Versions
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdaVersions(workspace: string, queryLambda: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueryLambdaVersionsResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).listQueryLambdaVersions(workspace, queryLambda, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all Query Lambdas under given workspace.
         * @summary List Query Lambdas in Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdasInWorkspace(workspace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueryLambdasResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).listQueryLambdasInWorkspace(workspace, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new version of a Query Lambda in given workspace.
         * @summary Update Query Lambda
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {UpdateQueryLambdaRequest} body JSON object
         * @param {boolean} [create] Create a new Query Lambda if one does not exist already.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQueryLambda(workspace: string, queryLambda: string, body: UpdateQueryLambdaRequest, create?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryLambdaVersionResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).updateQueryLambda(workspace, queryLambda, body, create, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QueryLambdasApi - factory interface
 * @export
 */
export const QueryLambdasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a Query Lambda in given workspace.
         * @summary Create Query Lambda
         * @param {string} workspace name of the workspace
         * @param {CreateQueryLambdaRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueryLambda(workspace: string, body: CreateQueryLambdaRequest, options?: any) {
            return QueryLambdasApiFp(configuration).createQueryLambda(workspace, body, options)(fetch, basePath);
        },
        /**
         * Create a tag for a specific Query Lambda version, or update that tag if it already exists.
         * @summary Create Query Lambda Tag
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {CreateQueryLambdaTagRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueryLambdaTag(workspace: string, queryLambda: string, body: CreateQueryLambdaTagRequest, options?: any) {
            return QueryLambdasApiFp(configuration).createQueryLambdaTag(workspace, queryLambda, body, options)(fetch, basePath);
        },
        /**
         * Delete a Query Lambda.
         * @summary Delete Query Lambda
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueryLambda(workspace: string, queryLambda: string, options?: any) {
            return QueryLambdasApiFp(configuration).deleteQueryLambda(workspace, queryLambda, options)(fetch, basePath);
        },
        /**
         * Delete a tag for a specific Query Lambda
         * @summary Delete Query Lambda Tag Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} tag name of the tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueryLambdaTag(workspace: string, queryLambda: string, tag: string, options?: any) {
            return QueryLambdasApiFp(configuration).deleteQueryLambdaTag(workspace, queryLambda, tag, options)(fetch, basePath);
        },
        /**
         * Delete a Query Lambda version.
         * @summary Delete Query Lambda Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} version version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options?: any) {
            return QueryLambdasApiFp(configuration).deleteQueryLambdaVersion(workspace, queryLambda, version, options)(fetch, basePath);
        },
        /**
         * Execute a particular version of a Query Lambda.
         * @summary Execute Query Lambda By Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} version version
         * @param {ExecuteQueryLambdaRequest} [body] JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeQueryLambda(workspace: string, queryLambda: string, version: string, body?: ExecuteQueryLambdaRequest, options?: any) {
            return QueryLambdasApiFp(configuration).executeQueryLambda(workspace, queryLambda, version, body, options)(fetch, basePath);
        },
        /**
         * Execute the Query Lambda version associated with a given tag.
         * @summary Execute Query Lambda By Tag
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} tag tag
         * @param {ExecuteQueryLambdaRequest} [body] JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeQueryLambdaByTag(workspace: string, queryLambda: string, tag: string, body?: ExecuteQueryLambdaRequest, options?: any) {
            return QueryLambdasApiFp(configuration).executeQueryLambdaByTag(workspace, queryLambda, tag, body, options)(fetch, basePath);
        },
        /**
         * Retrieve the Query Lambda version associated with a given tag.
         * @summary Retrieve Query Lambda Tag
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} tag name of the tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryLambdaTagVersion(workspace: string, queryLambda: string, tag: string, options?: any) {
            return QueryLambdasApiFp(configuration).getQueryLambdaTagVersion(workspace, queryLambda, tag, options)(fetch, basePath);
        },
        /**
         * Retrieve details for a specified version of a Query Lambda.
         * @summary Retrieve Query Lambda Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} version version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options?: any) {
            return QueryLambdasApiFp(configuration).getQueryLambdaVersion(workspace, queryLambda, version, options)(fetch, basePath);
        },
        /**
         * List all Query Lambdas in an organization.
         * @summary List Query Lambdas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllQueryLambdas(options?: any) {
            return QueryLambdasApiFp(configuration).listAllQueryLambdas(options)(fetch, basePath);
        },
        /**
         * List all tags associated with a Query Lambda
         * @summary List Query Lambda Tags
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdaTags(workspace: string, queryLambda: string, options?: any) {
            return QueryLambdasApiFp(configuration).listQueryLambdaTags(workspace, queryLambda, options)(fetch, basePath);
        },
        /**
         * List all versions of a Query Lambda.
         * @summary List Query Lambda Versions
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdaVersions(workspace: string, queryLambda: string, options?: any) {
            return QueryLambdasApiFp(configuration).listQueryLambdaVersions(workspace, queryLambda, options)(fetch, basePath);
        },
        /**
         * List all Query Lambdas under given workspace.
         * @summary List Query Lambdas in Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdasInWorkspace(workspace: string, options?: any) {
            return QueryLambdasApiFp(configuration).listQueryLambdasInWorkspace(workspace, options)(fetch, basePath);
        },
        /**
         * Create a new version of a Query Lambda in given workspace.
         * @summary Update Query Lambda
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {UpdateQueryLambdaRequest} body JSON object
         * @param {boolean} [create] Create a new Query Lambda if one does not exist already.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQueryLambda(workspace: string, queryLambda: string, body: UpdateQueryLambdaRequest, create?: boolean, options?: any) {
            return QueryLambdasApiFp(configuration).updateQueryLambda(workspace, queryLambda, body, create, options)(fetch, basePath);
        },
    };
};
/**
 * QueryLambdasApi - object-oriented interface
 * @export
 * @class QueryLambdasApi
 * @extends {BaseAPI}
 */
export class QueryLambdasApi extends BaseAPI {
    /**
     * Create a Query Lambda in given workspace.
     * @summary Create Query Lambda
     * @param {string} workspace name of the workspace
     * @param {CreateQueryLambdaRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public createQueryLambda(workspace: string, body: CreateQueryLambdaRequest, options?: any) {
        return QueryLambdasApiFp(this.configuration).createQueryLambda(workspace, body, options)(this.fetch, this.basePath);
    }
    /**
     * Create a tag for a specific Query Lambda version, or update that tag if it already exists.
     * @summary Create Query Lambda Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {CreateQueryLambdaTagRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public createQueryLambdaTag(workspace: string, queryLambda: string, body: CreateQueryLambdaTagRequest, options?: any) {
        return QueryLambdasApiFp(this.configuration).createQueryLambdaTag(workspace, queryLambda, body, options)(this.fetch, this.basePath);
    }
    /**
     * Delete a Query Lambda.
     * @summary Delete Query Lambda
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public deleteQueryLambda(workspace: string, queryLambda: string, options?: any) {
        return QueryLambdasApiFp(this.configuration).deleteQueryLambda(workspace, queryLambda, options)(this.fetch, this.basePath);
    }
    /**
     * Delete a tag for a specific Query Lambda
     * @summary Delete Query Lambda Tag Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag name of the tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public deleteQueryLambdaTag(workspace: string, queryLambda: string, tag: string, options?: any) {
        return QueryLambdasApiFp(this.configuration).deleteQueryLambdaTag(workspace, queryLambda, tag, options)(this.fetch, this.basePath);
    }
    /**
     * Delete a Query Lambda version.
     * @summary Delete Query Lambda Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public deleteQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options?: any) {
        return QueryLambdasApiFp(this.configuration).deleteQueryLambdaVersion(workspace, queryLambda, version, options)(this.fetch, this.basePath);
    }
    /**
     * Execute a particular version of a Query Lambda.
     * @summary Execute Query Lambda By Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {ExecuteQueryLambdaRequest} [body] JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public executeQueryLambda(workspace: string, queryLambda: string, version: string, body?: ExecuteQueryLambdaRequest, options?: any) {
        return QueryLambdasApiFp(this.configuration).executeQueryLambda(workspace, queryLambda, version, body, options)(this.fetch, this.basePath);
    }
    /**
     * Execute the Query Lambda version associated with a given tag.
     * @summary Execute Query Lambda By Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag tag
     * @param {ExecuteQueryLambdaRequest} [body] JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public executeQueryLambdaByTag(workspace: string, queryLambda: string, tag: string, body?: ExecuteQueryLambdaRequest, options?: any) {
        return QueryLambdasApiFp(this.configuration).executeQueryLambdaByTag(workspace, queryLambda, tag, body, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve the Query Lambda version associated with a given tag.
     * @summary Retrieve Query Lambda Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag name of the tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public getQueryLambdaTagVersion(workspace: string, queryLambda: string, tag: string, options?: any) {
        return QueryLambdasApiFp(this.configuration).getQueryLambdaTagVersion(workspace, queryLambda, tag, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve details for a specified version of a Query Lambda.
     * @summary Retrieve Query Lambda Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public getQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options?: any) {
        return QueryLambdasApiFp(this.configuration).getQueryLambdaVersion(workspace, queryLambda, version, options)(this.fetch, this.basePath);
    }
    /**
     * List all Query Lambdas in an organization.
     * @summary List Query Lambdas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public listAllQueryLambdas(options?: any) {
        return QueryLambdasApiFp(this.configuration).listAllQueryLambdas(options)(this.fetch, this.basePath);
    }
    /**
     * List all tags associated with a Query Lambda
     * @summary List Query Lambda Tags
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public listQueryLambdaTags(workspace: string, queryLambda: string, options?: any) {
        return QueryLambdasApiFp(this.configuration).listQueryLambdaTags(workspace, queryLambda, options)(this.fetch, this.basePath);
    }
    /**
     * List all versions of a Query Lambda.
     * @summary List Query Lambda Versions
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public listQueryLambdaVersions(workspace: string, queryLambda: string, options?: any) {
        return QueryLambdasApiFp(this.configuration).listQueryLambdaVersions(workspace, queryLambda, options)(this.fetch, this.basePath);
    }
    /**
     * List all Query Lambdas under given workspace.
     * @summary List Query Lambdas in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public listQueryLambdasInWorkspace(workspace: string, options?: any) {
        return QueryLambdasApiFp(this.configuration).listQueryLambdasInWorkspace(workspace, options)(this.fetch, this.basePath);
    }
    /**
     * Create a new version of a Query Lambda in given workspace.
     * @summary Update Query Lambda
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {UpdateQueryLambdaRequest} body JSON object
     * @param {boolean} [create] Create a new Query Lambda if one does not exist already.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public updateQueryLambda(workspace: string, queryLambda: string, body: UpdateQueryLambdaRequest, create?: boolean, options?: any) {
        return QueryLambdasApiFp(this.configuration).updateQueryLambda(workspace, queryLambda, body, create, options)(this.fetch, this.basePath);
    }
}

/**
 * ScheduledLambdasApi - fetch parameter creator
 * @export
 */
export const ScheduledLambdasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a scheduled lambda mapping for your organization.
         * @summary Create a Scheduled Lambda mapping
         * @param {string} workspace name of the workspace
         * @param {CreateScheduledLambdaRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScheduledLambda(workspace: string, body: CreateScheduledLambdaRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling createScheduledLambda.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createScheduledLambda.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/scheduled_lambdas`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateScheduledLambdaRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a scheduled lambda mapping for your organization.
         * @summary Delete a Scheduled Lambda mapping
         * @param {string} workspace name of the workspace
         * @param {string} scheduledLambdaId Scheduled Lambda RRN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduledLambda(workspace: string, scheduledLambdaId: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling deleteScheduledLambda.');
            }
            // verify required parameter 'scheduledLambdaId' is not null or undefined
            if (scheduledLambdaId === null || scheduledLambdaId === undefined) {
                throw new RequiredError('scheduledLambdaId','Required parameter scheduledLambdaId was null or undefined when calling deleteScheduledLambda.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/scheduled_lambdas/{scheduledLambdaId}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"scheduledLambdaId"}}`, encodeURIComponent(String(scheduledLambdaId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a scheduled lambda mapping for your organization.
         * @summary Update a Scheduled Lambda mapping
         * @param {string} workspace name of the workspace
         * @param {string} scheduledLambdaId Scheduled Lambda RRN
         * @param {UpdateScheduledLambdaRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScheduledLambda(workspace: string, scheduledLambdaId: string, body: UpdateScheduledLambdaRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling updateScheduledLambda.');
            }
            // verify required parameter 'scheduledLambdaId' is not null or undefined
            if (scheduledLambdaId === null || scheduledLambdaId === undefined) {
                throw new RequiredError('scheduledLambdaId','Required parameter scheduledLambdaId was null or undefined when calling updateScheduledLambda.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateScheduledLambda.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/scheduled_lambdas/{scheduledLambdaId}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"scheduledLambdaId"}}`, encodeURIComponent(String(scheduledLambdaId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateScheduledLambdaRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};
/**
 * ScheduledLambdasApi - functional programming interface
 * @export
 */
export const ScheduledLambdasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a scheduled lambda mapping for your organization.
         * @summary Create a Scheduled Lambda mapping
         * @param {string} workspace name of the workspace
         * @param {CreateScheduledLambdaRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScheduledLambda(workspace: string, body: CreateScheduledLambdaRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScheduledLambdaResponse> {
            const localVarFetchArgs = ScheduledLambdasApiFetchParamCreator(configuration).createScheduledLambda(workspace, body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a scheduled lambda mapping for your organization.
         * @summary Delete a Scheduled Lambda mapping
         * @param {string} workspace name of the workspace
         * @param {string} scheduledLambdaId Scheduled Lambda RRN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduledLambda(workspace: string, scheduledLambdaId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScheduledLambdaResponse> {
            const localVarFetchArgs = ScheduledLambdasApiFetchParamCreator(configuration).deleteScheduledLambda(workspace, scheduledLambdaId, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a scheduled lambda mapping for your organization.
         * @summary Update a Scheduled Lambda mapping
         * @param {string} workspace name of the workspace
         * @param {string} scheduledLambdaId Scheduled Lambda RRN
         * @param {UpdateScheduledLambdaRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScheduledLambda(workspace: string, scheduledLambdaId: string, body: UpdateScheduledLambdaRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScheduledLambdaResponse> {
            const localVarFetchArgs = ScheduledLambdasApiFetchParamCreator(configuration).updateScheduledLambda(workspace, scheduledLambdaId, body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ScheduledLambdasApi - factory interface
 * @export
 */
export const ScheduledLambdasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a scheduled lambda mapping for your organization.
         * @summary Create a Scheduled Lambda mapping
         * @param {string} workspace name of the workspace
         * @param {CreateScheduledLambdaRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScheduledLambda(workspace: string, body: CreateScheduledLambdaRequest, options?: any) {
            return ScheduledLambdasApiFp(configuration).createScheduledLambda(workspace, body, options)(fetch, basePath);
        },
        /**
         * Delete a scheduled lambda mapping for your organization.
         * @summary Delete a Scheduled Lambda mapping
         * @param {string} workspace name of the workspace
         * @param {string} scheduledLambdaId Scheduled Lambda RRN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduledLambda(workspace: string, scheduledLambdaId: string, options?: any) {
            return ScheduledLambdasApiFp(configuration).deleteScheduledLambda(workspace, scheduledLambdaId, options)(fetch, basePath);
        },
        /**
         * Update a scheduled lambda mapping for your organization.
         * @summary Update a Scheduled Lambda mapping
         * @param {string} workspace name of the workspace
         * @param {string} scheduledLambdaId Scheduled Lambda RRN
         * @param {UpdateScheduledLambdaRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScheduledLambda(workspace: string, scheduledLambdaId: string, body: UpdateScheduledLambdaRequest, options?: any) {
            return ScheduledLambdasApiFp(configuration).updateScheduledLambda(workspace, scheduledLambdaId, body, options)(fetch, basePath);
        },
    };
};
/**
 * ScheduledLambdasApi - object-oriented interface
 * @export
 * @class ScheduledLambdasApi
 * @extends {BaseAPI}
 */
export class ScheduledLambdasApi extends BaseAPI {
    /**
     * Create a scheduled lambda mapping for your organization.
     * @summary Create a Scheduled Lambda mapping
     * @param {string} workspace name of the workspace
     * @param {CreateScheduledLambdaRequest} body JSON Object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledLambdasApi
     */
    public createScheduledLambda(workspace: string, body: CreateScheduledLambdaRequest, options?: any) {
        return ScheduledLambdasApiFp(this.configuration).createScheduledLambda(workspace, body, options)(this.fetch, this.basePath);
    }
    /**
     * Delete a scheduled lambda mapping for your organization.
     * @summary Delete a Scheduled Lambda mapping
     * @param {string} workspace name of the workspace
     * @param {string} scheduledLambdaId Scheduled Lambda RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledLambdasApi
     */
    public deleteScheduledLambda(workspace: string, scheduledLambdaId: string, options?: any) {
        return ScheduledLambdasApiFp(this.configuration).deleteScheduledLambda(workspace, scheduledLambdaId, options)(this.fetch, this.basePath);
    }
    /**
     * Update a scheduled lambda mapping for your organization.
     * @summary Update a Scheduled Lambda mapping
     * @param {string} workspace name of the workspace
     * @param {string} scheduledLambdaId Scheduled Lambda RRN
     * @param {UpdateScheduledLambdaRequest} body JSON Object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledLambdasApi
     */
    public updateScheduledLambda(workspace: string, scheduledLambdaId: string, body: UpdateScheduledLambdaRequest, options?: any) {
        return ScheduledLambdasApiFp(this.configuration).updateScheduledLambda(workspace, scheduledLambdaId, body, options)(this.fetch, this.basePath);
    }
}

/**
 * SharedLambdasApi - fetch parameter creator
 * @export
 */
export const SharedLambdasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Execute a public query lambda (full version).
         * @summary Execute a Public Query Lambda
         * @param {string} public_access_id public access ID of the query lambda
         * @param {ExecutePublicQueryLambdaRequest} [body] JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePublicQueryLambdaWithParams(public_access_id: string, body?: ExecutePublicQueryLambdaRequest, options: any = {}): FetchArgs {
            // verify required parameter 'public_access_id' is not null or undefined
            if (public_access_id === null || public_access_id === undefined) {
                throw new RequiredError('public_access_id','Required parameter public_access_id was null or undefined when calling executePublicQueryLambdaWithParams.');
            }
            const localVarPath = `/v1/public/shared_lambdas/{public_access_id}`
                .replace(`{${"public_access_id"}}`, encodeURIComponent(String(public_access_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ExecutePublicQueryLambdaRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};
/**
 * SharedLambdasApi - functional programming interface
 * @export
 */
export const SharedLambdasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Execute a public query lambda (full version).
         * @summary Execute a Public Query Lambda
         * @param {string} public_access_id public access ID of the query lambda
         * @param {ExecutePublicQueryLambdaRequest} [body] JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePublicQueryLambdaWithParams(public_access_id: string, body?: ExecutePublicQueryLambdaRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryResponse> {
            const localVarFetchArgs = SharedLambdasApiFetchParamCreator(configuration).executePublicQueryLambdaWithParams(public_access_id, body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SharedLambdasApi - factory interface
 * @export
 */
export const SharedLambdasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Execute a public query lambda (full version).
         * @summary Execute a Public Query Lambda
         * @param {string} public_access_id public access ID of the query lambda
         * @param {ExecutePublicQueryLambdaRequest} [body] JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePublicQueryLambdaWithParams(public_access_id: string, body?: ExecutePublicQueryLambdaRequest, options?: any) {
            return SharedLambdasApiFp(configuration).executePublicQueryLambdaWithParams(public_access_id, body, options)(fetch, basePath);
        },
    };
};
/**
 * SharedLambdasApi - object-oriented interface
 * @export
 * @class SharedLambdasApi
 * @extends {BaseAPI}
 */
export class SharedLambdasApi extends BaseAPI {
    /**
     * Execute a public query lambda (full version).
     * @summary Execute a Public Query Lambda
     * @param {string} public_access_id public access ID of the query lambda
     * @param {ExecutePublicQueryLambdaRequest} [body] JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedLambdasApi
     */
    public executePublicQueryLambdaWithParams(public_access_id: string, body?: ExecutePublicQueryLambdaRequest, options?: any) {
        return SharedLambdasApiFp(this.configuration).executePublicQueryLambdaWithParams(public_access_id, body, options)(this.fetch, this.basePath);
    }
}

/**
 * SourcesApi - fetch parameter creator
 * @export
 */
export const SourcesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new source in a collection.
         * @summary Create a source
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {Source} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSource(workspace: string, collection: string, body: Source, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling createSource.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling createSource.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createSource.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/sources`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Source" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a collection source
         * @summary Delete Collection source
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {string} source id of source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource(workspace: string, collection: string, source: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling deleteSource.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling deleteSource.');
            }
            // verify required parameter 'source' is not null or undefined
            if (source === null || source === undefined) {
                throw new RequiredError('source','Required parameter source was null or undefined when calling deleteSource.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/sources/{source}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"source"}}`, encodeURIComponent(String(source)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details about a collection source.
         * @summary Retrieve source
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {string} source id of source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSource(workspace: string, collection: string, source: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling getSource.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling getSource.');
            }
            // verify required parameter 'source' is not null or undefined
            if (source === null || source === undefined) {
                throw new RequiredError('source','Required parameter source was null or undefined when calling getSource.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/sources/{source}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"source"}}`, encodeURIComponent(String(source)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all sources in a collection.
         * @summary List sources in collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollectionSources(workspace: string, collection: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling listCollectionSources.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling listCollectionSources.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/sources`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resume source ingest
         * @summary Resume source ingest
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {string} source id of source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeSource(workspace: string, collection: string, source: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling resumeSource.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling resumeSource.');
            }
            // verify required parameter 'source' is not null or undefined
            if (source === null || source === undefined) {
                throw new RequiredError('source','Required parameter source was null or undefined when calling resumeSource.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/sources/{source}/resume`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"source"}}`, encodeURIComponent(String(source)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Suspend source ingest
         * @summary Suspend source ingest
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {string} source id of source
         * @param {SuspendSourceRequest} [body] JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suspendSource(workspace: string, collection: string, source: string, body?: SuspendSourceRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling suspendSource.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling suspendSource.');
            }
            // verify required parameter 'source' is not null or undefined
            if (source === null || source === undefined) {
                throw new RequiredError('source','Required parameter source was null or undefined when calling suspendSource.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/sources/{source}/suspend`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"source"}}`, encodeURIComponent(String(source)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SuspendSourceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update details about a collection source.
         * @summary Update a collection source
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {string} source id of source
         * @param {SourceBase} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSource(workspace: string, collection: string, source: string, body: SourceBase, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling updateSource.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling updateSource.');
            }
            // verify required parameter 'source' is not null or undefined
            if (source === null || source === undefined) {
                throw new RequiredError('source','Required parameter source was null or undefined when calling updateSource.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateSource.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/sources/{source}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"source"}}`, encodeURIComponent(String(source)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SourceBase" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};
/**
 * SourcesApi - functional programming interface
 * @export
 */
export const SourcesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create new source in a collection.
         * @summary Create a source
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {Source} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSource(workspace: string, collection: string, body: Source, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSourceResponse> {
            const localVarFetchArgs = SourcesApiFetchParamCreator(configuration).createSource(workspace, collection, body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a collection source
         * @summary Delete Collection source
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {string} source id of source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource(workspace: string, collection: string, source: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteSourceResponse> {
            const localVarFetchArgs = SourcesApiFetchParamCreator(configuration).deleteSource(workspace, collection, source, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get details about a collection source.
         * @summary Retrieve source
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {string} source id of source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSource(workspace: string, collection: string, source: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSourceResponse> {
            const localVarFetchArgs = SourcesApiFetchParamCreator(configuration).getSource(workspace, collection, source, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all sources in a collection.
         * @summary List sources in collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollectionSources(workspace: string, collection: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListSourcesResponse> {
            const localVarFetchArgs = SourcesApiFetchParamCreator(configuration).listCollectionSources(workspace, collection, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Resume source ingest
         * @summary Resume source ingest
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {string} source id of source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeSource(workspace: string, collection: string, source: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSourceResponse> {
            const localVarFetchArgs = SourcesApiFetchParamCreator(configuration).resumeSource(workspace, collection, source, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Suspend source ingest
         * @summary Suspend source ingest
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {string} source id of source
         * @param {SuspendSourceRequest} [body] JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suspendSource(workspace: string, collection: string, source: string, body?: SuspendSourceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSourceResponse> {
            const localVarFetchArgs = SourcesApiFetchParamCreator(configuration).suspendSource(workspace, collection, source, body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update details about a collection source.
         * @summary Update a collection source
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {string} source id of source
         * @param {SourceBase} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSource(workspace: string, collection: string, source: string, body: SourceBase, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSourceResponse> {
            const localVarFetchArgs = SourcesApiFetchParamCreator(configuration).updateSource(workspace, collection, source, body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SourcesApi - factory interface
 * @export
 */
export const SourcesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create new source in a collection.
         * @summary Create a source
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {Source} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSource(workspace: string, collection: string, body: Source, options?: any) {
            return SourcesApiFp(configuration).createSource(workspace, collection, body, options)(fetch, basePath);
        },
        /**
         * Delete a collection source
         * @summary Delete Collection source
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {string} source id of source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource(workspace: string, collection: string, source: string, options?: any) {
            return SourcesApiFp(configuration).deleteSource(workspace, collection, source, options)(fetch, basePath);
        },
        /**
         * Get details about a collection source.
         * @summary Retrieve source
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {string} source id of source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSource(workspace: string, collection: string, source: string, options?: any) {
            return SourcesApiFp(configuration).getSource(workspace, collection, source, options)(fetch, basePath);
        },
        /**
         * Retrieve all sources in a collection.
         * @summary List sources in collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollectionSources(workspace: string, collection: string, options?: any) {
            return SourcesApiFp(configuration).listCollectionSources(workspace, collection, options)(fetch, basePath);
        },
        /**
         * Resume source ingest
         * @summary Resume source ingest
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {string} source id of source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeSource(workspace: string, collection: string, source: string, options?: any) {
            return SourcesApiFp(configuration).resumeSource(workspace, collection, source, options)(fetch, basePath);
        },
        /**
         * Suspend source ingest
         * @summary Suspend source ingest
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {string} source id of source
         * @param {SuspendSourceRequest} [body] JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suspendSource(workspace: string, collection: string, source: string, body?: SuspendSourceRequest, options?: any) {
            return SourcesApiFp(configuration).suspendSource(workspace, collection, source, body, options)(fetch, basePath);
        },
        /**
         * Update details about a collection source.
         * @summary Update a collection source
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {string} source id of source
         * @param {SourceBase} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSource(workspace: string, collection: string, source: string, body: SourceBase, options?: any) {
            return SourcesApiFp(configuration).updateSource(workspace, collection, source, body, options)(fetch, basePath);
        },
    };
};
/**
 * SourcesApi - object-oriented interface
 * @export
 * @class SourcesApi
 * @extends {BaseAPI}
 */
export class SourcesApi extends BaseAPI {
    /**
     * Create new source in a collection.
     * @summary Create a source
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {Source} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public createSource(workspace: string, collection: string, body: Source, options?: any) {
        return SourcesApiFp(this.configuration).createSource(workspace, collection, body, options)(this.fetch, this.basePath);
    }
    /**
     * Delete a collection source
     * @summary Delete Collection source
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {string} source id of source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public deleteSource(workspace: string, collection: string, source: string, options?: any) {
        return SourcesApiFp(this.configuration).deleteSource(workspace, collection, source, options)(this.fetch, this.basePath);
    }
    /**
     * Get details about a collection source.
     * @summary Retrieve source
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {string} source id of source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public getSource(workspace: string, collection: string, source: string, options?: any) {
        return SourcesApiFp(this.configuration).getSource(workspace, collection, source, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve all sources in a collection.
     * @summary List sources in collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public listCollectionSources(workspace: string, collection: string, options?: any) {
        return SourcesApiFp(this.configuration).listCollectionSources(workspace, collection, options)(this.fetch, this.basePath);
    }
    /**
     * Resume source ingest
     * @summary Resume source ingest
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {string} source id of source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public resumeSource(workspace: string, collection: string, source: string, options?: any) {
        return SourcesApiFp(this.configuration).resumeSource(workspace, collection, source, options)(this.fetch, this.basePath);
    }
    /**
     * Suspend source ingest
     * @summary Suspend source ingest
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {string} source id of source
     * @param {SuspendSourceRequest} [body] JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public suspendSource(workspace: string, collection: string, source: string, body?: SuspendSourceRequest, options?: any) {
        return SourcesApiFp(this.configuration).suspendSource(workspace, collection, source, body, options)(this.fetch, this.basePath);
    }
    /**
     * Update details about a collection source.
     * @summary Update a collection source
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {string} source id of source
     * @param {SourceBase} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourcesApi
     */
    public updateSource(workspace: string, collection: string, source: string, body: SourceBase, options?: any) {
        return SourcesApiFp(this.configuration).updateSource(workspace, collection, source, body, options)(this.fetch, this.basePath);
    }
}

/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new user for an organization.
         * @summary Create User
         * @param {CreateUserRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: CreateUserRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createUser.');
            }
            const localVarPath = `/v1/orgs/self/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateUserRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user from an organization.
         * @summary Delete User
         * @param {string} user user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(user: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/v1/orgs/self/users/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve currently authenticated user.
         * @summary Retrieve Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/users/self`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve user by email.
         * @summary Retrieve User
         * @param {string} user user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(user: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling getUser.');
            }
            const localVarPath = `/v1/orgs/self/users/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all notification preferences.
         * @summary Retrieve Notification Preferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUnsubscribePreferences(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/users/self/preferences`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all users for an organization.
         * @summary List Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update notification preference.
         * @summary Update Notification Preferences
         * @param {UpdateUnsubscribePreferencesRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUnsubscribePreferences(body: UpdateUnsubscribePreferencesRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateUnsubscribePreferences.');
            }
            const localVarPath = `/v1/orgs/self/users/self/preferences`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUnsubscribePreferencesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user in an organization.
         * @summary Update User
         * @param {string} user email of the user to update
         * @param {UpdateUserRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(user: string, body: UpdateUserRequest, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling updateUser.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateUser.');
            }
            const localVarPath = `/v1/orgs/self/users/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUserRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};
/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new user for an organization.
         * @summary Create User
         * @param {CreateUserRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: CreateUserRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateUserResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).createUser(body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a user from an organization.
         * @summary Delete User
         * @param {string} user user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteUserResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).deleteUser(user, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve currently authenticated user.
         * @summary Retrieve Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getCurrentUser(options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve user by email.
         * @summary Retrieve User
         * @param {string} user user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUser(user, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all notification preferences.
         * @summary Retrieve Notification Preferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUnsubscribePreferences(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListUnsubscribePreferencesResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).listUnsubscribePreferences(options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all users for an organization.
         * @summary List Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListUsersResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).listUsers(options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update notification preference.
         * @summary Update Notification Preferences
         * @param {UpdateUnsubscribePreferencesRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUnsubscribePreferences(body: UpdateUnsubscribePreferencesRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpdateUnsubscribePreferencesResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).updateUnsubscribePreferences(body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a user in an organization.
         * @summary Update User
         * @param {string} user email of the user to update
         * @param {UpdateUserRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(user: string, body: UpdateUserRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).updateUser(user, body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new user for an organization.
         * @summary Create User
         * @param {CreateUserRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: CreateUserRequest, options?: any) {
            return UsersApiFp(configuration).createUser(body, options)(fetch, basePath);
        },
        /**
         * Delete a user from an organization.
         * @summary Delete User
         * @param {string} user user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(user: string, options?: any) {
            return UsersApiFp(configuration).deleteUser(user, options)(fetch, basePath);
        },
        /**
         * Retrieve currently authenticated user.
         * @summary Retrieve Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: any) {
            return UsersApiFp(configuration).getCurrentUser(options)(fetch, basePath);
        },
        /**
         * Retrieve user by email.
         * @summary Retrieve User
         * @param {string} user user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(user: string, options?: any) {
            return UsersApiFp(configuration).getUser(user, options)(fetch, basePath);
        },
        /**
         * Get all notification preferences.
         * @summary Retrieve Notification Preferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUnsubscribePreferences(options?: any) {
            return UsersApiFp(configuration).listUnsubscribePreferences(options)(fetch, basePath);
        },
        /**
         * Retrieve all users for an organization.
         * @summary List Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(options?: any) {
            return UsersApiFp(configuration).listUsers(options)(fetch, basePath);
        },
        /**
         * Update notification preference.
         * @summary Update Notification Preferences
         * @param {UpdateUnsubscribePreferencesRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUnsubscribePreferences(body: UpdateUnsubscribePreferencesRequest, options?: any) {
            return UsersApiFp(configuration).updateUnsubscribePreferences(body, options)(fetch, basePath);
        },
        /**
         * Update a user in an organization.
         * @summary Update User
         * @param {string} user email of the user to update
         * @param {UpdateUserRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(user: string, body: UpdateUserRequest, options?: any) {
            return UsersApiFp(configuration).updateUser(user, body, options)(fetch, basePath);
        },
    };
};
/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Create a new user for an organization.
     * @summary Create User
     * @param {CreateUserRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(body: CreateUserRequest, options?: any) {
        return UsersApiFp(this.configuration).createUser(body, options)(this.fetch, this.basePath);
    }
    /**
     * Delete a user from an organization.
     * @summary Delete User
     * @param {string} user user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(user: string, options?: any) {
        return UsersApiFp(this.configuration).deleteUser(user, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve currently authenticated user.
     * @summary Retrieve Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getCurrentUser(options?: any) {
        return UsersApiFp(this.configuration).getCurrentUser(options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve user by email.
     * @summary Retrieve User
     * @param {string} user user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(user: string, options?: any) {
        return UsersApiFp(this.configuration).getUser(user, options)(this.fetch, this.basePath);
    }
    /**
     * Get all notification preferences.
     * @summary Retrieve Notification Preferences
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUnsubscribePreferences(options?: any) {
        return UsersApiFp(this.configuration).listUnsubscribePreferences(options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve all users for an organization.
     * @summary List Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUsers(options?: any) {
        return UsersApiFp(this.configuration).listUsers(options)(this.fetch, this.basePath);
    }
    /**
     * Update notification preference.
     * @summary Update Notification Preferences
     * @param {UpdateUnsubscribePreferencesRequest} body JSON Object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUnsubscribePreferences(body: UpdateUnsubscribePreferencesRequest, options?: any) {
        return UsersApiFp(this.configuration).updateUnsubscribePreferences(body, options)(this.fetch, this.basePath);
    }
    /**
     * Update a user in an organization.
     * @summary Update User
     * @param {string} user email of the user to update
     * @param {UpdateUserRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(user: string, body: UpdateUserRequest, options?: any) {
        return UsersApiFp(this.configuration).updateUser(user, body, options)(this.fetch, this.basePath);
    }
}

/**
 * ViewsApi - fetch parameter creator
 * @export
 */
export const ViewsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a view
         * @summary Create View
         * @param {string} workspace name of the workspace
         * @param {CreateViewRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createView(workspace: string, body: CreateViewRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling createView.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createView.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/views`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateViewRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a view
         * @summary Delete View
         * @param {string} workspace name of the workspace
         * @param {string} view name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteView(workspace: string, view: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling deleteView.');
            }
            // verify required parameter 'view' is not null or undefined
            if (view === null || view === undefined) {
                throw new RequiredError('view','Required parameter view was null or undefined when calling deleteView.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/views/{view}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"view"}}`, encodeURIComponent(String(view)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details about a view
         * @summary Retrieve View
         * @param {string} workspace name of the workspace
         * @param {string} view name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getView(workspace: string, view: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling getView.');
            }
            // verify required parameter 'view' is not null or undefined
            if (view === null || view === undefined) {
                throw new RequiredError('view','Required parameter view was null or undefined when calling getView.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/views/{view}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"view"}}`, encodeURIComponent(String(view)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all views in an organization
         * @summary List Views
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listViews(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/views`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a view
         * @summary Update View
         * @param {string} workspace name of the workspace
         * @param {string} view name of the view
         * @param {UpdateViewRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateView(workspace: string, view: string, body: UpdateViewRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling updateView.');
            }
            // verify required parameter 'view' is not null or undefined
            if (view === null || view === undefined) {
                throw new RequiredError('view','Required parameter view was null or undefined when calling updateView.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateView.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/views/{view}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"view"}}`, encodeURIComponent(String(view)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateViewRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all views in a workspace.
         * @summary List Views in Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceViews(workspace: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling workspaceViews.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/views`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};
/**
 * ViewsApi - functional programming interface
 * @export
 */
export const ViewsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a view
         * @summary Create View
         * @param {string} workspace name of the workspace
         * @param {CreateViewRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createView(workspace: string, body: CreateViewRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateViewResponse> {
            const localVarFetchArgs = ViewsApiFetchParamCreator(configuration).createView(workspace, body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a view
         * @summary Delete View
         * @param {string} workspace name of the workspace
         * @param {string} view name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteView(workspace: string, view: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteViewResponse> {
            const localVarFetchArgs = ViewsApiFetchParamCreator(configuration).deleteView(workspace, view, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get details about a view
         * @summary Retrieve View
         * @param {string} workspace name of the workspace
         * @param {string} view name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getView(workspace: string, view: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetViewResponse> {
            const localVarFetchArgs = ViewsApiFetchParamCreator(configuration).getView(workspace, view, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all views in an organization
         * @summary List Views
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listViews(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListViewsResponse> {
            const localVarFetchArgs = ViewsApiFetchParamCreator(configuration).listViews(options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a view
         * @summary Update View
         * @param {string} workspace name of the workspace
         * @param {string} view name of the view
         * @param {UpdateViewRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateView(workspace: string, view: string, body: UpdateViewRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpdateViewResponse> {
            const localVarFetchArgs = ViewsApiFetchParamCreator(configuration).updateView(workspace, view, body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all views in a workspace.
         * @summary List Views in Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceViews(workspace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListViewsResponse> {
            const localVarFetchArgs = ViewsApiFetchParamCreator(configuration).workspaceViews(workspace, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ViewsApi - factory interface
 * @export
 */
export const ViewsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a view
         * @summary Create View
         * @param {string} workspace name of the workspace
         * @param {CreateViewRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createView(workspace: string, body: CreateViewRequest, options?: any) {
            return ViewsApiFp(configuration).createView(workspace, body, options)(fetch, basePath);
        },
        /**
         * Delete a view
         * @summary Delete View
         * @param {string} workspace name of the workspace
         * @param {string} view name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteView(workspace: string, view: string, options?: any) {
            return ViewsApiFp(configuration).deleteView(workspace, view, options)(fetch, basePath);
        },
        /**
         * Get details about a view
         * @summary Retrieve View
         * @param {string} workspace name of the workspace
         * @param {string} view name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getView(workspace: string, view: string, options?: any) {
            return ViewsApiFp(configuration).getView(workspace, view, options)(fetch, basePath);
        },
        /**
         * Retrieve all views in an organization
         * @summary List Views
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listViews(options?: any) {
            return ViewsApiFp(configuration).listViews(options)(fetch, basePath);
        },
        /**
         * Update a view
         * @summary Update View
         * @param {string} workspace name of the workspace
         * @param {string} view name of the view
         * @param {UpdateViewRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateView(workspace: string, view: string, body: UpdateViewRequest, options?: any) {
            return ViewsApiFp(configuration).updateView(workspace, view, body, options)(fetch, basePath);
        },
        /**
         * Retrieve all views in a workspace.
         * @summary List Views in Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceViews(workspace: string, options?: any) {
            return ViewsApiFp(configuration).workspaceViews(workspace, options)(fetch, basePath);
        },
    };
};
/**
 * ViewsApi - object-oriented interface
 * @export
 * @class ViewsApi
 * @extends {BaseAPI}
 */
export class ViewsApi extends BaseAPI {
    /**
     * Create a view
     * @summary Create View
     * @param {string} workspace name of the workspace
     * @param {CreateViewRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public createView(workspace: string, body: CreateViewRequest, options?: any) {
        return ViewsApiFp(this.configuration).createView(workspace, body, options)(this.fetch, this.basePath);
    }
    /**
     * Delete a view
     * @summary Delete View
     * @param {string} workspace name of the workspace
     * @param {string} view name of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public deleteView(workspace: string, view: string, options?: any) {
        return ViewsApiFp(this.configuration).deleteView(workspace, view, options)(this.fetch, this.basePath);
    }
    /**
     * Get details about a view
     * @summary Retrieve View
     * @param {string} workspace name of the workspace
     * @param {string} view name of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public getView(workspace: string, view: string, options?: any) {
        return ViewsApiFp(this.configuration).getView(workspace, view, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve all views in an organization
     * @summary List Views
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public listViews(options?: any) {
        return ViewsApiFp(this.configuration).listViews(options)(this.fetch, this.basePath);
    }
    /**
     * Update a view
     * @summary Update View
     * @param {string} workspace name of the workspace
     * @param {string} view name of the view
     * @param {UpdateViewRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public updateView(workspace: string, view: string, body: UpdateViewRequest, options?: any) {
        return ViewsApiFp(this.configuration).updateView(workspace, view, body, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve all views in a workspace.
     * @summary List Views in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public workspaceViews(workspace: string, options?: any) {
        return ViewsApiFp(this.configuration).workspaceViews(workspace, options)(this.fetch, this.basePath);
    }
}

/**
 * VirtualInstancesApi - fetch parameter creator
 * @export
 */
export const VirtualInstancesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create virtual instance
         * @summary Create Virtual Instance
         * @param {CreateVirtualInstanceRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualInstance(body: CreateVirtualInstanceRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createVirtualInstance.');
            }
            const localVarPath = `/v1/orgs/self/virtualinstances`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateVirtualInstanceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a virtual instance.
         * @summary Delete Virtual Instance
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVirtualInstance(virtualInstanceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'virtualInstanceId' is not null or undefined
            if (virtualInstanceId === null || virtualInstanceId === undefined) {
                throw new RequiredError('virtualInstanceId','Required parameter virtualInstanceId was null or undefined when calling deleteVirtualInstance.');
            }
            const localVarPath = `/v1/orgs/self/virtualinstances/{virtualInstanceId}`
                .replace(`{${"virtualInstanceId"}}`, encodeURIComponent(String(virtualInstanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a mount on this virtual instance.
         * @summary Get Collection Mount
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {string} collectionPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionMount(virtualInstanceId: string, collectionPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'virtualInstanceId' is not null or undefined
            if (virtualInstanceId === null || virtualInstanceId === undefined) {
                throw new RequiredError('virtualInstanceId','Required parameter virtualInstanceId was null or undefined when calling getCollectionMount.');
            }
            // verify required parameter 'collectionPath' is not null or undefined
            if (collectionPath === null || collectionPath === undefined) {
                throw new RequiredError('collectionPath','Required parameter collectionPath was null or undefined when calling getCollectionMount.');
            }
            const localVarPath = `/v1/orgs/self/virtualinstances/{virtualInstanceId}/mounts/{collectionPath}`
                .replace(`{${"virtualInstanceId"}}`, encodeURIComponent(String(virtualInstanceId)))
                .replace(`{${"collectionPath"}}`, encodeURIComponent(String(collectionPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Determines if the collection includes data at or after the specified fence(s) for close read-after-write semantics.
         * @summary Get Collection Commit
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {string} collectionPath 
         * @param {GetCollectionCommitRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMountOffsets(virtualInstanceId: string, collectionPath: string, body: GetCollectionCommitRequest, options: any = {}): FetchArgs {
            // verify required parameter 'virtualInstanceId' is not null or undefined
            if (virtualInstanceId === null || virtualInstanceId === undefined) {
                throw new RequiredError('virtualInstanceId','Required parameter virtualInstanceId was null or undefined when calling getMountOffsets.');
            }
            // verify required parameter 'collectionPath' is not null or undefined
            if (collectionPath === null || collectionPath === undefined) {
                throw new RequiredError('collectionPath','Required parameter collectionPath was null or undefined when calling getMountOffsets.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getMountOffsets.');
            }
            const localVarPath = `/v1/orgs/self/virtualinstances/{virtualInstanceId}/mounts/{collectionPath}/offsets/commit`
                .replace(`{${"virtualInstanceId"}}`, encodeURIComponent(String(virtualInstanceId)))
                .replace(`{${"collectionPath"}}`, encodeURIComponent(String(collectionPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GetCollectionCommitRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details about a virtual instance.
         * @summary Retrieve Virtual Instance
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualInstance(virtualInstanceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'virtualInstanceId' is not null or undefined
            if (virtualInstanceId === null || virtualInstanceId === undefined) {
                throw new RequiredError('virtualInstanceId','Required parameter virtualInstanceId was null or undefined when calling getVirtualInstance.');
            }
            const localVarPath = `/v1/orgs/self/virtualinstances/{virtualInstanceId}`
                .replace(`{${"virtualInstanceId"}}`, encodeURIComponent(String(virtualInstanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists actively queued and running queries for a particular Virtual Instance.
         * @summary List Queries
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualInstanceQueries(virtualInstanceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'virtualInstanceId' is not null or undefined
            if (virtualInstanceId === null || virtualInstanceId === undefined) {
                throw new RequiredError('virtualInstanceId','Required parameter virtualInstanceId was null or undefined when calling getVirtualInstanceQueries.');
            }
            const localVarPath = `/v1/orgs/self/virtualinstances/{virtualInstanceId}/queries`
                .replace(`{${"virtualInstanceId"}}`, encodeURIComponent(String(virtualInstanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List collection mounts for a particular VI.
         * @summary List Collection Mounts
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollectionMounts(virtualInstanceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'virtualInstanceId' is not null or undefined
            if (virtualInstanceId === null || virtualInstanceId === undefined) {
                throw new RequiredError('virtualInstanceId','Required parameter virtualInstanceId was null or undefined when calling listCollectionMounts.');
            }
            const localVarPath = `/v1/orgs/self/virtualinstances/{virtualInstanceId}/mounts`
                .replace(`{${"virtualInstanceId"}}`, encodeURIComponent(String(virtualInstanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all virtual instances in an organization.
         * @summary List Virtual Instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVirtualInstances(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/virtualinstances`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mount a collection to this virtual instance.
         * @summary Mount Collections
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {CreateCollectionMountRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mountCollection(virtualInstanceId: string, body: CreateCollectionMountRequest, options: any = {}): FetchArgs {
            // verify required parameter 'virtualInstanceId' is not null or undefined
            if (virtualInstanceId === null || virtualInstanceId === undefined) {
                throw new RequiredError('virtualInstanceId','Required parameter virtualInstanceId was null or undefined when calling mountCollection.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling mountCollection.');
            }
            const localVarPath = `/v1/orgs/self/virtualinstances/{virtualInstanceId}/mounts`
                .replace(`{${"virtualInstanceId"}}`, encodeURIComponent(String(virtualInstanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateCollectionMountRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Make a SQL query to Rockset.
         * @summary Execute SQL Query on a specific Virtual Instance
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {QueryRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryVirtualInstance(virtualInstanceId: string, body: QueryRequest, options: any = {}): FetchArgs {
            // verify required parameter 'virtualInstanceId' is not null or undefined
            if (virtualInstanceId === null || virtualInstanceId === undefined) {
                throw new RequiredError('virtualInstanceId','Required parameter virtualInstanceId was null or undefined when calling queryVirtualInstance.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling queryVirtualInstance.');
            }
            const localVarPath = `/v1/orgs/self/virtualinstances/{virtualInstanceId}/queries`
                .replace(`{${"virtualInstanceId"}}`, encodeURIComponent(String(virtualInstanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QueryRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resume a virtual instance.
         * @summary Resume Virtual Instance
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeVirtualInstance(virtualInstanceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'virtualInstanceId' is not null or undefined
            if (virtualInstanceId === null || virtualInstanceId === undefined) {
                throw new RequiredError('virtualInstanceId','Required parameter virtualInstanceId was null or undefined when calling resumeVirtualInstance.');
            }
            const localVarPath = `/v1/orgs/self/virtualinstances/{virtualInstanceId}/resume`
                .replace(`{${"virtualInstanceId"}}`, encodeURIComponent(String(virtualInstanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the properties of a virtual instance.
         * @summary Update Virtual Instance
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {UpdateVirtualInstanceRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setVirtualInstance(virtualInstanceId: string, body: UpdateVirtualInstanceRequest, options: any = {}): FetchArgs {
            // verify required parameter 'virtualInstanceId' is not null or undefined
            if (virtualInstanceId === null || virtualInstanceId === undefined) {
                throw new RequiredError('virtualInstanceId','Required parameter virtualInstanceId was null or undefined when calling setVirtualInstance.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setVirtualInstance.');
            }
            const localVarPath = `/v1/orgs/self/virtualinstances/{virtualInstanceId}`
                .replace(`{${"virtualInstanceId"}}`, encodeURIComponent(String(virtualInstanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateVirtualInstanceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Suspend a virtual instance.
         * @summary Suspend Virtual Instance
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suspendVirtualInstance(virtualInstanceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'virtualInstanceId' is not null or undefined
            if (virtualInstanceId === null || virtualInstanceId === undefined) {
                throw new RequiredError('virtualInstanceId','Required parameter virtualInstanceId was null or undefined when calling suspendVirtualInstance.');
            }
            const localVarPath = `/v1/orgs/self/virtualinstances/{virtualInstanceId}/suspend`
                .replace(`{${"virtualInstanceId"}}`, encodeURIComponent(String(virtualInstanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unmount a collection from this virtual instance.
         * @summary Unmount Collection
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {string} collectionPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unmountCollection(virtualInstanceId: string, collectionPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'virtualInstanceId' is not null or undefined
            if (virtualInstanceId === null || virtualInstanceId === undefined) {
                throw new RequiredError('virtualInstanceId','Required parameter virtualInstanceId was null or undefined when calling unmountCollection.');
            }
            // verify required parameter 'collectionPath' is not null or undefined
            if (collectionPath === null || collectionPath === undefined) {
                throw new RequiredError('collectionPath','Required parameter collectionPath was null or undefined when calling unmountCollection.');
            }
            const localVarPath = `/v1/orgs/self/virtualinstances/{virtualInstanceId}/mounts/{collectionPath}`
                .replace(`{${"virtualInstanceId"}}`, encodeURIComponent(String(virtualInstanceId)))
                .replace(`{${"collectionPath"}}`, encodeURIComponent(String(collectionPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};
/**
 * VirtualInstancesApi - functional programming interface
 * @export
 */
export const VirtualInstancesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create virtual instance
         * @summary Create Virtual Instance
         * @param {CreateVirtualInstanceRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualInstance(body: CreateVirtualInstanceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateVirtualInstanceResponse> {
            const localVarFetchArgs = VirtualInstancesApiFetchParamCreator(configuration).createVirtualInstance(body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a virtual instance.
         * @summary Delete Virtual Instance
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVirtualInstance(virtualInstanceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteVirtualInstanceResponse> {
            const localVarFetchArgs = VirtualInstancesApiFetchParamCreator(configuration).deleteVirtualInstance(virtualInstanceId, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve a mount on this virtual instance.
         * @summary Get Collection Mount
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {string} collectionPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionMount(virtualInstanceId: string, collectionPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CollectionMountResponse> {
            const localVarFetchArgs = VirtualInstancesApiFetchParamCreator(configuration).getCollectionMount(virtualInstanceId, collectionPath, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Determines if the collection includes data at or after the specified fence(s) for close read-after-write semantics.
         * @summary Get Collection Commit
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {string} collectionPath 
         * @param {GetCollectionCommitRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMountOffsets(virtualInstanceId: string, collectionPath: string, body: GetCollectionCommitRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCollectionCommit> {
            const localVarFetchArgs = VirtualInstancesApiFetchParamCreator(configuration).getMountOffsets(virtualInstanceId, collectionPath, body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get details about a virtual instance.
         * @summary Retrieve Virtual Instance
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualInstance(virtualInstanceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetVirtualInstanceResponse> {
            const localVarFetchArgs = VirtualInstancesApiFetchParamCreator(configuration).getVirtualInstance(virtualInstanceId, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists actively queued and running queries for a particular Virtual Instance.
         * @summary List Queries
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualInstanceQueries(virtualInstanceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueriesResponse> {
            const localVarFetchArgs = VirtualInstancesApiFetchParamCreator(configuration).getVirtualInstanceQueries(virtualInstanceId, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List collection mounts for a particular VI.
         * @summary List Collection Mounts
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollectionMounts(virtualInstanceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListCollectionMountsResponse> {
            const localVarFetchArgs = VirtualInstancesApiFetchParamCreator(configuration).listCollectionMounts(virtualInstanceId, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all virtual instances in an organization.
         * @summary List Virtual Instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVirtualInstances(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListVirtualInstancesResponse> {
            const localVarFetchArgs = VirtualInstancesApiFetchParamCreator(configuration).listVirtualInstances(options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Mount a collection to this virtual instance.
         * @summary Mount Collections
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {CreateCollectionMountRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mountCollection(virtualInstanceId: string, body: CreateCollectionMountRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateCollectionMountsResponse> {
            const localVarFetchArgs = VirtualInstancesApiFetchParamCreator(configuration).mountCollection(virtualInstanceId, body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Make a SQL query to Rockset.
         * @summary Execute SQL Query on a specific Virtual Instance
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {QueryRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryVirtualInstance(virtualInstanceId: string, body: QueryRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryResponse> {
            const localVarFetchArgs = VirtualInstancesApiFetchParamCreator(configuration).queryVirtualInstance(virtualInstanceId, body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Resume a virtual instance.
         * @summary Resume Virtual Instance
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeVirtualInstance(virtualInstanceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResumeVirtualInstanceResponse> {
            const localVarFetchArgs = VirtualInstancesApiFetchParamCreator(configuration).resumeVirtualInstance(virtualInstanceId, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the properties of a virtual instance.
         * @summary Update Virtual Instance
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {UpdateVirtualInstanceRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setVirtualInstance(virtualInstanceId: string, body: UpdateVirtualInstanceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpdateVirtualInstanceResponse> {
            const localVarFetchArgs = VirtualInstancesApiFetchParamCreator(configuration).setVirtualInstance(virtualInstanceId, body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Suspend a virtual instance.
         * @summary Suspend Virtual Instance
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suspendVirtualInstance(virtualInstanceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SuspendVirtualInstanceResponse> {
            const localVarFetchArgs = VirtualInstancesApiFetchParamCreator(configuration).suspendVirtualInstance(virtualInstanceId, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Unmount a collection from this virtual instance.
         * @summary Unmount Collection
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {string} collectionPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unmountCollection(virtualInstanceId: string, collectionPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CollectionMountResponse> {
            const localVarFetchArgs = VirtualInstancesApiFetchParamCreator(configuration).unmountCollection(virtualInstanceId, collectionPath, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VirtualInstancesApi - factory interface
 * @export
 */
export const VirtualInstancesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create virtual instance
         * @summary Create Virtual Instance
         * @param {CreateVirtualInstanceRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVirtualInstance(body: CreateVirtualInstanceRequest, options?: any) {
            return VirtualInstancesApiFp(configuration).createVirtualInstance(body, options)(fetch, basePath);
        },
        /**
         * Delete a virtual instance.
         * @summary Delete Virtual Instance
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVirtualInstance(virtualInstanceId: string, options?: any) {
            return VirtualInstancesApiFp(configuration).deleteVirtualInstance(virtualInstanceId, options)(fetch, basePath);
        },
        /**
         * Retrieve a mount on this virtual instance.
         * @summary Get Collection Mount
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {string} collectionPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionMount(virtualInstanceId: string, collectionPath: string, options?: any) {
            return VirtualInstancesApiFp(configuration).getCollectionMount(virtualInstanceId, collectionPath, options)(fetch, basePath);
        },
        /**
         * Determines if the collection includes data at or after the specified fence(s) for close read-after-write semantics.
         * @summary Get Collection Commit
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {string} collectionPath 
         * @param {GetCollectionCommitRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMountOffsets(virtualInstanceId: string, collectionPath: string, body: GetCollectionCommitRequest, options?: any) {
            return VirtualInstancesApiFp(configuration).getMountOffsets(virtualInstanceId, collectionPath, body, options)(fetch, basePath);
        },
        /**
         * Get details about a virtual instance.
         * @summary Retrieve Virtual Instance
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualInstance(virtualInstanceId: string, options?: any) {
            return VirtualInstancesApiFp(configuration).getVirtualInstance(virtualInstanceId, options)(fetch, basePath);
        },
        /**
         * Lists actively queued and running queries for a particular Virtual Instance.
         * @summary List Queries
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualInstanceQueries(virtualInstanceId: string, options?: any) {
            return VirtualInstancesApiFp(configuration).getVirtualInstanceQueries(virtualInstanceId, options)(fetch, basePath);
        },
        /**
         * List collection mounts for a particular VI.
         * @summary List Collection Mounts
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollectionMounts(virtualInstanceId: string, options?: any) {
            return VirtualInstancesApiFp(configuration).listCollectionMounts(virtualInstanceId, options)(fetch, basePath);
        },
        /**
         * Retrieve all virtual instances in an organization.
         * @summary List Virtual Instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVirtualInstances(options?: any) {
            return VirtualInstancesApiFp(configuration).listVirtualInstances(options)(fetch, basePath);
        },
        /**
         * Mount a collection to this virtual instance.
         * @summary Mount Collections
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {CreateCollectionMountRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mountCollection(virtualInstanceId: string, body: CreateCollectionMountRequest, options?: any) {
            return VirtualInstancesApiFp(configuration).mountCollection(virtualInstanceId, body, options)(fetch, basePath);
        },
        /**
         * Make a SQL query to Rockset.
         * @summary Execute SQL Query on a specific Virtual Instance
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {QueryRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryVirtualInstance(virtualInstanceId: string, body: QueryRequest, options?: any) {
            return VirtualInstancesApiFp(configuration).queryVirtualInstance(virtualInstanceId, body, options)(fetch, basePath);
        },
        /**
         * Resume a virtual instance.
         * @summary Resume Virtual Instance
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeVirtualInstance(virtualInstanceId: string, options?: any) {
            return VirtualInstancesApiFp(configuration).resumeVirtualInstance(virtualInstanceId, options)(fetch, basePath);
        },
        /**
         * Update the properties of a virtual instance.
         * @summary Update Virtual Instance
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {UpdateVirtualInstanceRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setVirtualInstance(virtualInstanceId: string, body: UpdateVirtualInstanceRequest, options?: any) {
            return VirtualInstancesApiFp(configuration).setVirtualInstance(virtualInstanceId, body, options)(fetch, basePath);
        },
        /**
         * Suspend a virtual instance.
         * @summary Suspend Virtual Instance
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suspendVirtualInstance(virtualInstanceId: string, options?: any) {
            return VirtualInstancesApiFp(configuration).suspendVirtualInstance(virtualInstanceId, options)(fetch, basePath);
        },
        /**
         * Unmount a collection from this virtual instance.
         * @summary Unmount Collection
         * @param {string} virtualInstanceId Virtual Instance RRN
         * @param {string} collectionPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unmountCollection(virtualInstanceId: string, collectionPath: string, options?: any) {
            return VirtualInstancesApiFp(configuration).unmountCollection(virtualInstanceId, collectionPath, options)(fetch, basePath);
        },
    };
};
/**
 * VirtualInstancesApi - object-oriented interface
 * @export
 * @class VirtualInstancesApi
 * @extends {BaseAPI}
 */
export class VirtualInstancesApi extends BaseAPI {
    /**
     * Create virtual instance
     * @summary Create Virtual Instance
     * @param {CreateVirtualInstanceRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    public createVirtualInstance(body: CreateVirtualInstanceRequest, options?: any) {
        return VirtualInstancesApiFp(this.configuration).createVirtualInstance(body, options)(this.fetch, this.basePath);
    }
    /**
     * Delete a virtual instance.
     * @summary Delete Virtual Instance
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    public deleteVirtualInstance(virtualInstanceId: string, options?: any) {
        return VirtualInstancesApiFp(this.configuration).deleteVirtualInstance(virtualInstanceId, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve a mount on this virtual instance.
     * @summary Get Collection Mount
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {string} collectionPath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    public getCollectionMount(virtualInstanceId: string, collectionPath: string, options?: any) {
        return VirtualInstancesApiFp(this.configuration).getCollectionMount(virtualInstanceId, collectionPath, options)(this.fetch, this.basePath);
    }
    /**
     * Determines if the collection includes data at or after the specified fence(s) for close read-after-write semantics.
     * @summary Get Collection Commit
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {string} collectionPath 
     * @param {GetCollectionCommitRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    public getMountOffsets(virtualInstanceId: string, collectionPath: string, body: GetCollectionCommitRequest, options?: any) {
        return VirtualInstancesApiFp(this.configuration).getMountOffsets(virtualInstanceId, collectionPath, body, options)(this.fetch, this.basePath);
    }
    /**
     * Get details about a virtual instance.
     * @summary Retrieve Virtual Instance
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    public getVirtualInstance(virtualInstanceId: string, options?: any) {
        return VirtualInstancesApiFp(this.configuration).getVirtualInstance(virtualInstanceId, options)(this.fetch, this.basePath);
    }
    /**
     * Lists actively queued and running queries for a particular Virtual Instance.
     * @summary List Queries
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    public getVirtualInstanceQueries(virtualInstanceId: string, options?: any) {
        return VirtualInstancesApiFp(this.configuration).getVirtualInstanceQueries(virtualInstanceId, options)(this.fetch, this.basePath);
    }
    /**
     * List collection mounts for a particular VI.
     * @summary List Collection Mounts
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    public listCollectionMounts(virtualInstanceId: string, options?: any) {
        return VirtualInstancesApiFp(this.configuration).listCollectionMounts(virtualInstanceId, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve all virtual instances in an organization.
     * @summary List Virtual Instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    public listVirtualInstances(options?: any) {
        return VirtualInstancesApiFp(this.configuration).listVirtualInstances(options)(this.fetch, this.basePath);
    }
    /**
     * Mount a collection to this virtual instance.
     * @summary Mount Collections
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {CreateCollectionMountRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    public mountCollection(virtualInstanceId: string, body: CreateCollectionMountRequest, options?: any) {
        return VirtualInstancesApiFp(this.configuration).mountCollection(virtualInstanceId, body, options)(this.fetch, this.basePath);
    }
    /**
     * Make a SQL query to Rockset.
     * @summary Execute SQL Query on a specific Virtual Instance
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {QueryRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    public queryVirtualInstance(virtualInstanceId: string, body: QueryRequest, options?: any) {
        return VirtualInstancesApiFp(this.configuration).queryVirtualInstance(virtualInstanceId, body, options)(this.fetch, this.basePath);
    }
    /**
     * Resume a virtual instance.
     * @summary Resume Virtual Instance
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    public resumeVirtualInstance(virtualInstanceId: string, options?: any) {
        return VirtualInstancesApiFp(this.configuration).resumeVirtualInstance(virtualInstanceId, options)(this.fetch, this.basePath);
    }
    /**
     * Update the properties of a virtual instance.
     * @summary Update Virtual Instance
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {UpdateVirtualInstanceRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    public setVirtualInstance(virtualInstanceId: string, body: UpdateVirtualInstanceRequest, options?: any) {
        return VirtualInstancesApiFp(this.configuration).setVirtualInstance(virtualInstanceId, body, options)(this.fetch, this.basePath);
    }
    /**
     * Suspend a virtual instance.
     * @summary Suspend Virtual Instance
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    public suspendVirtualInstance(virtualInstanceId: string, options?: any) {
        return VirtualInstancesApiFp(this.configuration).suspendVirtualInstance(virtualInstanceId, options)(this.fetch, this.basePath);
    }
    /**
     * Unmount a collection from this virtual instance.
     * @summary Unmount Collection
     * @param {string} virtualInstanceId Virtual Instance RRN
     * @param {string} collectionPath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    public unmountCollection(virtualInstanceId: string, collectionPath: string, options?: any) {
        return VirtualInstancesApiFp(this.configuration).unmountCollection(virtualInstanceId, collectionPath, options)(this.fetch, this.basePath);
    }
}

/**
 * WorkspacesApi - fetch parameter creator
 * @export
 */
export const WorkspacesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new workspace.
         * @summary Create Workspace
         * @param {CreateWorkspaceRequest} body workspace details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace(body: CreateWorkspaceRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createWorkspace.');
            }
            const localVarPath = `/v1/orgs/self/ws`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateWorkspaceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a workspace.
         * @summary Delete Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace(workspace: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling deleteWorkspace.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a single workspace.
         * @summary Retrieve Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspace(workspace: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling getWorkspace.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all workspaces in an organization.
         * @summary List Workspaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaces(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/ws`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};
/**
 * WorkspacesApi - functional programming interface
 * @export
 */
export const WorkspacesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new workspace.
         * @summary Create Workspace
         * @param {CreateWorkspaceRequest} body workspace details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace(body: CreateWorkspaceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateWorkspaceResponse> {
            const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).createWorkspace(body, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove a workspace.
         * @summary Delete Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace(workspace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteWorkspaceResponse> {
            const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).deleteWorkspace(workspace, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information about a single workspace.
         * @summary Retrieve Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspace(workspace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetWorkspaceResponse> {
            const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).getWorkspace(workspace, options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all workspaces in an organization.
         * @summary List Workspaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaces(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListWorkspacesResponse> {
            const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).listWorkspaces(options);
            return (fetch: FetchAPI = fetchPonyfill.fetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WorkspacesApi - factory interface
 * @export
 */
export const WorkspacesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new workspace.
         * @summary Create Workspace
         * @param {CreateWorkspaceRequest} body workspace details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace(body: CreateWorkspaceRequest, options?: any) {
            return WorkspacesApiFp(configuration).createWorkspace(body, options)(fetch, basePath);
        },
        /**
         * Remove a workspace.
         * @summary Delete Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace(workspace: string, options?: any) {
            return WorkspacesApiFp(configuration).deleteWorkspace(workspace, options)(fetch, basePath);
        },
        /**
         * Get information about a single workspace.
         * @summary Retrieve Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspace(workspace: string, options?: any) {
            return WorkspacesApiFp(configuration).getWorkspace(workspace, options)(fetch, basePath);
        },
        /**
         * List all workspaces in an organization.
         * @summary List Workspaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaces(options?: any) {
            return WorkspacesApiFp(configuration).listWorkspaces(options)(fetch, basePath);
        },
    };
};
/**
 * WorkspacesApi - object-oriented interface
 * @export
 * @class WorkspacesApi
 * @extends {BaseAPI}
 */
export class WorkspacesApi extends BaseAPI {
    /**
     * Create a new workspace.
     * @summary Create Workspace
     * @param {CreateWorkspaceRequest} body workspace details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public createWorkspace(body: CreateWorkspaceRequest, options?: any) {
        return WorkspacesApiFp(this.configuration).createWorkspace(body, options)(this.fetch, this.basePath);
    }
    /**
     * Remove a workspace.
     * @summary Delete Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public deleteWorkspace(workspace: string, options?: any) {
        return WorkspacesApiFp(this.configuration).deleteWorkspace(workspace, options)(this.fetch, this.basePath);
    }
    /**
     * Get information about a single workspace.
     * @summary Retrieve Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public getWorkspace(workspace: string, options?: any) {
        return WorkspacesApiFp(this.configuration).getWorkspace(workspace, options)(this.fetch, this.basePath);
    }
    /**
     * List all workspaces in an organization.
     * @summary List Workspaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public listWorkspaces(options?: any) {
        return WorkspacesApiFp(this.configuration).listWorkspaces(options)(this.fetch, this.basePath);
    }
}

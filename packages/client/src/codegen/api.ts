/**
 * REST API
 * Rockset's REST API allows for creating and managing all resources in Rockset. Each supported endpoint is documented below.  All requests must be authorized with a Rockset API key, which can be created in the [Rockset console](https://console.rockset.com). The API key must be provided as `ApiKey <api_key>` in the `Authorization` request header. For example: ``` Authorization: ApiKey aB35kDjg93J5nsf4GjwMeErAVd832F7ad4vhsW1S02kfZiab42sTsfW5Sxt25asT ```  All endpoints are only accessible via https.  Build something awesome!
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://api.rs2.usw2.rockset.com".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AddDocumentsRequest
 */
export interface AddDocumentsRequest {
    /**
     * Array of documents to be added to the collection.
     * @type {Array<any>}
     * @memberof AddDocumentsRequest
     */
    data: Array<any>;
}

/**
 * 
 * @export
 * @interface AddDocumentsResponse
 */
export interface AddDocumentsResponse {
    /**
     * information about the added documents
     * @type {Array<DocumentStatus>}
     * @memberof AddDocumentsResponse
     */
    data?: Array<DocumentStatus>;
    /**
     * A string representing the collection offset after completing the write
     * @type {string}
     * @memberof AddDocumentsResponse
     */
    last_offset?: string;
}

/**
 * 
 * @export
 * @interface Alias
 */
export interface Alias {
    /**
     * name of the alias
     * @type {string}
     * @memberof Alias
     */
    name?: string;
    /**
     * alias description
     * @type {string}
     * @memberof Alias
     */
    description?: string;
    /**
     * name of the workspace
     * @type {string}
     * @memberof Alias
     */
    workspace?: string;
    /**
     * email of the creator
     * @type {string}
     * @memberof Alias
     */
    creator_email?: string;
    /**
     * list of fully qualified collection names referenced by alias
     * @type {Array<string>}
     * @memberof Alias
     */
    collections?: Array<string>;
    /**
     * state of the alias
     * @type {string}
     * @memberof Alias
     */
    state?: Alias.StateEnum;
    /**
     * ISO-8601 date
     * @type {string}
     * @memberof Alias
     */
    created_at?: string;
    /**
     * ISO-8601 date
     * @type {string}
     * @memberof Alias
     */
    modified_at?: string;
}

/**
 * @export
 * @namespace Alias
 */
export namespace Alias {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        CREATED = <any> 'CREATED',
        DELETED = <any> 'DELETED'
    }
}

/**
 * API keys are used to authenticate requests to Rockset's API. An API key is tied to the user who creates it.
 * @export
 * @interface ApiKey
 */
export interface ApiKey {
    /**
     * Date that API key was created (ISO-8601 format).
     * @type {string}
     * @memberof ApiKey
     */
    created_at?: string;
    /**
     * Name of the API key.
     * @type {string}
     * @memberof ApiKey
     */
    name: string;
    /**
     * API key string of 64 alphanumeric characters.
     * @type {string}
     * @memberof ApiKey
     */
    key: string;
    /**
     * Date that API key was most recently used (ISO-8601 format).
     * @type {string}
     * @memberof ApiKey
     */
    last_access_time?: string;
    /**
     * Role specifying access control. If not specified, API key will have access to all of the associated user's roles.
     * @type {string}
     * @memberof ApiKey
     */
    role?: string;
    /**
     * Email of API key owner.
     * @type {string}
     * @memberof ApiKey
     */
    created_by?: string;
    /**
     * current state of this key
     * @type {string}
     * @memberof ApiKey
     */
    state?: ApiKey.StateEnum;
}

/**
 * @export
 * @namespace ApiKey
 */
export namespace ApiKey {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        ACTIVE = <any> 'ACTIVE',
        SUSPENDED = <any> 'SUSPENDED'
    }
}

/**
 * 
 * @export
 * @interface AwsAccessKey
 */
export interface AwsAccessKey {
    /**
     * AWS access key ID
     * @type {string}
     * @memberof AwsAccessKey
     */
    aws_access_key_id: string;
    /**
     * AWS secret access key
     * @type {string}
     * @memberof AwsAccessKey
     */
    aws_secret_access_key: string;
}

/**
 * 
 * @export
 * @interface AwsRole
 */
export interface AwsRole {
    /**
     * ARN of rockset-role created in your account
     * @type {string}
     * @memberof AwsRole
     */
    aws_role_arn: string;
}

/**
 * 
 * @export
 * @interface BodyPart
 */
export interface BodyPart {
    /**
     * 
     * @type {ContentDisposition}
     * @memberof BodyPart
     */
    contentDisposition?: ContentDisposition;
    /**
     * 
     * @type {any}
     * @memberof BodyPart
     */
    entity?: any;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof BodyPart
     */
    headers?: { [key: string]: Array<string>; };
    /**
     * 
     * @type {MediaType}
     * @memberof BodyPart
     */
    mediaType?: MediaType;
    /**
     * 
     * @type {MessageBodyWorkers}
     * @memberof BodyPart
     */
    messageBodyWorkers?: MessageBodyWorkers;
    /**
     * 
     * @type {MultiPart}
     * @memberof BodyPart
     */
    parent?: MultiPart;
    /**
     * 
     * @type {Providers}
     * @memberof BodyPart
     */
    providers?: Providers;
    /**
     * 
     * @type {{ [key: string]: Array<ParameterizedHeader>; }}
     * @memberof BodyPart
     */
    parameterizedHeaders?: { [key: string]: Array<ParameterizedHeader>; };
}

/**
 * 
 * @export
 * @interface Cluster
 */
export interface Cluster {
    /**
     * unique identifier for the cluster
     * @type {string}
     * @memberof Cluster
     */
    id?: string;
    /**
     * cluster type
     * @type {string}
     * @memberof Cluster
     */
    cluster_type?: Cluster.ClusterTypeEnum;
    /**
     * aws region
     * @type {string}
     * @memberof Cluster
     */
    aws_region?: string;
    /**
     * domain of org using cluster
     * @type {string}
     * @memberof Cluster
     */
    domain?: string;
    /**
     * top level domain of org using cluster
     * @type {string}
     * @memberof Cluster
     */
    top_level_domain?: string;
    /**
     * api server url for cluster
     * @type {string}
     * @memberof Cluster
     */
    apiserver_url?: string;
}

/**
 * @export
 * @namespace Cluster
 */
export namespace Cluster {
    /**
     * @export
     * @enum {string}
     */
    export enum ClusterTypeEnum {
        PUBLIC = <any> 'PUBLIC',
        PRIVATE = <any> 'PRIVATE'
    }
}

/**
 * 
 * @export
 * @interface Collection
 */
export interface Collection {
    /**
     * ISO-8601 date
     * @type {string}
     * @memberof Collection
     */
    created_at?: string;
    /**
     * email of user who created the collection
     * @type {string}
     * @memberof Collection
     */
    created_by?: string;
    /**
     * unique identifer for collection, can contain alphanumeric or dash characters
     * @type {string}
     * @memberof Collection
     */
    name?: string;
    /**
     * text describing the collection
     * @type {string}
     * @memberof Collection
     */
    description?: string;
    /**
     * name of the workspace that the collection is in
     * @type {string}
     * @memberof Collection
     */
    workspace?: string;
    /**
     * current status of collection, one of: CREATED, READY, DELETED
     * @type {string}
     * @memberof Collection
     */
    status?: Collection.StatusEnum;
    /**
     * list of sources from which collection ingests
     * @type {Array<Source>}
     * @memberof Collection
     */
    sources?: Array<Source>;
    /**
     * metrics about the collection
     * @type {CollectionStats}
     * @memberof Collection
     */
    stats?: CollectionStats;
    /**
     * number of seconds after which data is purged based on event time
     * @type {number}
     * @memberof Collection
     */
    retention_secs?: number;
    /**
     * list of mappings applied on all documents in a collection
     * @type {Array<FieldMappingV2>}
     * @memberof Collection
     */
    field_mappings?: Array<FieldMappingV2>;
    /**
     * Field mapping for a collection
     * @type {FieldMappingQuery}
     * @memberof Collection
     */
    field_mapping_query?: FieldMappingQuery;
    /**
     * list of partitions for a collection
     * @type {Array<FieldPartition>}
     * @memberof Collection
     */
    field_partitions?: Array<FieldPartition>;
    /**
     * list of clustering fields for a collection
     * @type {Array<FieldPartition>}
     * @memberof Collection
     */
    clustering_key?: Array<FieldPartition>;
    /**
     * list of aliases for a collection
     * @type {Array<Alias>}
     * @memberof Collection
     */
    aliases?: Array<Alias>;
    /**
     * list of field schemas 
     * @type {Array<FieldSchema>}
     * @memberof Collection
     */
    field_schemas?: Array<FieldSchema>;
    /**
     * inverted index group encoding options
     * @type {InvertedIndexGroupEncodingOptions}
     * @memberof Collection
     */
    inverted_index_group_encoding_options?: InvertedIndexGroupEncodingOptions;
    /**
     * Whether the collection is insert only or not
     * @type {boolean}
     * @memberof Collection
     */
    insert_only?: boolean;
    /**
     * If true, exactly-once write semantics is enabled.
     * @type {boolean}
     * @memberof Collection
     */
    enable_exactly_once_writes?: boolean;
}

/**
 * @export
 * @namespace Collection
 */
export namespace Collection {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        INITIALIZED = <any> 'INITIALIZED',
        CREATED = <any> 'CREATED',
        READY = <any> 'READY',
        PAUSED = <any> 'PAUSED',
        DELETED = <any> 'DELETED',
        PAUSING = <any> 'PAUSING',
        RESUMING = <any> 'RESUMING',
        PREPARINGBULK = <any> 'PREPARING_BULK',
        BULKINGESTMODE = <any> 'BULK_INGEST_MODE',
        EXITINGBULKINGESTMODE = <any> 'EXITING_BULK_INGEST_MODE',
        UNKNOWN = <any> 'UNKNOWN'
    }
}

/**
 * 
 * @export
 * @interface CollectionMetric
 */
export interface CollectionMetric {
    /**
     * 
     * @type {string}
     * @memberof CollectionMetric
     */
    collection_path?: string;
    /**
     * 
     * @type {number}
     * @memberof CollectionMetric
     */
    doc_count?: number;
    /**
     * 
     * @type {number}
     * @memberof CollectionMetric
     */
    total_index_size?: number;
    /**
     * 
     * @type {number}
     * @memberof CollectionMetric
     */
    total_bytes_ingested?: number;
    /**
     * 
     * @type {number}
     * @memberof CollectionMetric
     */
    ingest_parse_errors?: number;
    /**
     * 
     * @type {number}
     * @memberof CollectionMetric
     */
    ingest_source_total_time_ms?: number;
    /**
     * 
     * @type {number}
     * @memberof CollectionMetric
     */
    ingest_source_measurements?: number;
    /**
     * 
     * @type {number}
     * @memberof CollectionMetric
     */
    leaf_ingest_total_time_ms?: number;
    /**
     * 
     * @type {number}
     * @memberof CollectionMetric
     */
    leaf_ingest_measurements?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CollectionMetric
     */
    is_bulk_ingest?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CollectionMetric
     */
    time?: number;
}

/**
 * 
 * @export
 * @interface CollectionStats
 */
export interface CollectionStats {
    /**
     * number of documents in the collection
     * @type {number}
     * @memberof CollectionStats
     */
    doc_count?: number;
    /**
     * number of documents purged from the collection
     * @type {number}
     * @memberof CollectionStats
     */
    purged_doc_count?: number;
    /**
     * number between 0 and 1 that indicates progress of collection creation
     * @type {number}
     * @memberof CollectionStats
     */
    fill_progress?: number;
    /**
     * milliseconds since Unix epoch Jan 1, 1970
     * @type {number}
     * @memberof CollectionStats
     */
    last_queried_ms?: number;
    /**
     * milliseconds since Unix epoch Jan 1, 1970
     * @type {number}
     * @memberof CollectionStats
     */
    last_updated_ms?: number;
    /**
     * total collection size in bytes
     * @type {number}
     * @memberof CollectionStats
     */
    total_size?: number;
    /**
     * total collection index size in bytes
     * @type {number}
     * @memberof CollectionStats
     */
    total_index_size?: number;
    /**
     * total collection row index size in bytes
     * @type {number}
     * @memberof CollectionStats
     */
    row_index_size?: number;
    /**
     * total collection column index size in bytes
     * @type {number}
     * @memberof CollectionStats
     */
    column_index_size?: number;
    /**
     * total collection inverted index size in bytes
     * @type {number}
     * @memberof CollectionStats
     */
    inverted_index_size?: number;
    /**
     * total collection range index size in bytes
     * @type {number}
     * @memberof CollectionStats
     */
    range_index_size?: number;
    /**
     * total size of bytes purged in bytes
     * @type {number}
     * @memberof CollectionStats
     */
    purged_doc_size?: number;
    /**
     * total number of bytes inserted into the collection
     * @type {number}
     * @memberof CollectionStats
     */
    bytes_inserted?: number;
    /**
     * total number of bytes overwritten in writing into the collection
     * @type {number}
     * @memberof CollectionStats
     */
    bytes_overwritten?: number;
    /**
     * total number of bytes inserted into the collection during bulk
     * @type {number}
     * @memberof CollectionStats
     */
    bulk_bytes_inserted?: number;
    /**
     * total number of bytes overwritten in writing into the collection during bulk
     * @type {number}
     * @memberof CollectionStats
     */
    bulk_bytes_overwritten?: number;
}

/**
 * 
 * @export
 * @interface ComputeUsage
 */
export interface ComputeUsage {
    /**
     * 
     * @type {number}
     * @memberof ComputeUsage
     */
    minutes: number;
    /**
     * 
     * @type {number}
     * @memberof ComputeUsage
     */
    total_compute_cost: number;
}

/**
 * 
 * @export
 * @interface ContactSalesRequest
 */
export interface ContactSalesRequest {
    /**
     * email to cc, determined by user
     * @type {string}
     * @memberof ContactSalesRequest
     */
    cc_email?: string;
    /**
     * user phone number
     * @type {string}
     * @memberof ContactSalesRequest
     */
    phone_number?: string;
    /**
     * category user is contacting us about
     * @type {string}
     * @memberof ContactSalesRequest
     */
    category?: string;
    /**
     * message from user
     * @type {string}
     * @memberof ContactSalesRequest
     */
    message?: string;
    /**
     * source of contact sales trigger
     * @type {string}
     * @memberof ContactSalesRequest
     */
    source?: string;
}

/**
 * 
 * @export
 * @interface ContactSupportRequest
 */
export interface ContactSupportRequest {
    /**
     * subject of support ticket
     * @type {string}
     * @memberof ContactSupportRequest
     */
    subject?: string;
    /**
     * description of support ticket
     * @type {string}
     * @memberof ContactSupportRequest
     */
    description?: string;
}

/**
 * 
 * @export
 * @interface ContentDisposition
 */
export interface ContentDisposition {
    /**
     * 
     * @type {string}
     * @memberof ContentDisposition
     */
    type?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ContentDisposition
     */
    parameters?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ContentDisposition
     */
    fileName?: string;
    /**
     * 
     * @type {Date}
     * @memberof ContentDisposition
     */
    creationDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ContentDisposition
     */
    modificationDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ContentDisposition
     */
    readDate?: Date;
    /**
     * 
     * @type {number}
     * @memberof ContentDisposition
     */
    size?: number;
}

/**
 * 
 * @export
 * @interface CreateAliasRequest
 */
export interface CreateAliasRequest {
    /**
     * Alias name
     * @type {string}
     * @memberof CreateAliasRequest
     */
    name: string;
    /**
     * optional description
     * @type {string}
     * @memberof CreateAliasRequest
     */
    description?: string;
    /**
     * list of fully qualified collection names referenced by alias
     * @type {Array<string>}
     * @memberof CreateAliasRequest
     */
    collections: Array<string>;
}

/**
 * 
 * @export
 * @interface CreateAliasResponse
 */
export interface CreateAliasResponse {
    /**
     * alias that was created
     * @type {Alias}
     * @memberof CreateAliasResponse
     */
    data?: Alias;
}

/**
 * 
 * @export
 * @interface CreateApiKeyRequest
 */
export interface CreateApiKeyRequest {
    /**
     * Name for this API key.
     * @type {string}
     * @memberof CreateApiKeyRequest
     */
    name: string;
    /**
     * Role specifying access control. If not specified, API key will have access to all of the associated user's roles.
     * @type {string}
     * @memberof CreateApiKeyRequest
     */
    role?: string;
}

/**
 * 
 * @export
 * @interface CreateApiKeyResponse
 */
export interface CreateApiKeyResponse {
    /**
     * The API key that was created.
     * @type {ApiKey}
     * @memberof CreateApiKeyResponse
     */
    data?: ApiKey;
}

/**
 * 
 * @export
 * @interface CreateCollectionRequest
 */
export interface CreateCollectionRequest {
    /**
     * unique identifier for collection, can contain alphanumeric or dash characters
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    name: string;
    /**
     * text describing the collection
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    description?: string;
    /**
     * list of sources from which to ingest data
     * @type {Array<Source>}
     * @memberof CreateCollectionRequest
     */
    sources?: Array<Source>;
    /**
     * number of seconds after which data is purged, based on event time
     * @type {number}
     * @memberof CreateCollectionRequest
     */
    retention_secs?: number;
    /**
     * If non-null, the collection will be time partitioned and each partition will be time_partition_resolution_secs wide.
     * @type {number}
     * @memberof CreateCollectionRequest
     */
    time_partition_resolution_secs?: number;
    /**
     * If true disallows updates and deletes, but makes indexing more efficient
     * @type {boolean}
     * @memberof CreateCollectionRequest
     */
    insert_only?: boolean;
    /**
     * If true, exactly-once write semantics is enabled.
     * @type {boolean}
     * @memberof CreateCollectionRequest
     */
    enable_exactly_once_writes?: boolean;
    /**
     * configuration for event data
     * @type {EventTimeInfo}
     * @memberof CreateCollectionRequest
     */
    event_time_info?: EventTimeInfo;
    /**
     * list of mappings
     * @type {Array<FieldMappingV2>}
     * @memberof CreateCollectionRequest
     */
    field_mappings?: Array<FieldMappingV2>;
    /**
     * Mapping of fields for a collection
     * @type {FieldMappingQuery}
     * @memberof CreateCollectionRequest
     */
    field_mapping_query?: FieldMappingQuery;
    /**
     * list of field partitions
     * @type {Array<FieldPartition>}
     * @memberof CreateCollectionRequest
     */
    field_partitions?: Array<FieldPartition>;
    /**
     * list of clustering fields
     * @type {Array<FieldPartition>}
     * @memberof CreateCollectionRequest
     */
    clustering_key?: Array<FieldPartition>;
    /**
     * list of field schemas
     * @type {Array<FieldSchema>}
     * @memberof CreateCollectionRequest
     */
    field_schemas?: Array<FieldSchema>;
    /**
     * inverted index group encoding options
     * @type {InvertedIndexGroupEncodingOptions}
     * @memberof CreateCollectionRequest
     */
    inverted_index_group_encoding_options?: InvertedIndexGroupEncodingOptions;
    /**
     * override value for bulk ingest state
     * @type {boolean}
     * @memberof CreateCollectionRequest
     */
    bulk_load_override?: boolean;
    /**
     * Virtual instance type, chosen at first collection creation
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    instance_type?: CreateCollectionRequest.InstanceTypeEnum;
}

/**
 * @export
 * @namespace CreateCollectionRequest
 */
export namespace CreateCollectionRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum InstanceTypeEnum {
        FREE = <any> 'FREE',
        SHARED = <any> 'SHARED',
        SMALL = <any> 'SMALL',
        MEDIUM = <any> 'MEDIUM',
        LARGE = <any> 'LARGE',
        XLARGE = <any> 'XLARGE',
        XLARGE2 = <any> 'XLARGE2',
        XLARGE4 = <any> 'XLARGE4',
        XLARGE8 = <any> 'XLARGE8',
        XLARGE16 = <any> 'XLARGE16'
    }
}

/**
 * 
 * @export
 * @interface CreateCollectionResponse
 */
export interface CreateCollectionResponse {
    /**
     * collection that was created
     * @type {Collection}
     * @memberof CreateCollectionResponse
     */
    data?: Collection;
}

/**
 * 
 * @export
 * @interface CreateIntegrationRequest
 */
export interface CreateIntegrationRequest {
    /**
     * descriptive label
     * @type {string}
     * @memberof CreateIntegrationRequest
     */
    name: string;
    /**
     * longer explanation for the integration
     * @type {string}
     * @memberof CreateIntegrationRequest
     */
    description?: string;
    /**
     * Amazon S3 details, must have one of aws_access_key or aws_role
     * @type {S3Integration}
     * @memberof CreateIntegrationRequest
     */
    s3?: S3Integration;
    /**
     * Amazon Kinesis details, must have one of aws_access_key or aws_role
     * @type {KinesisIntegration}
     * @memberof CreateIntegrationRequest
     */
    kinesis?: KinesisIntegration;
    /**
     * Amazon DynamoDB details, must have one of aws_access_key or aws_role
     * @type {DynamodbIntegration}
     * @memberof CreateIntegrationRequest
     */
    dynamodb?: DynamodbIntegration;
    /**
     * Amazon Redshift details
     * @type {RedshiftIntegration}
     * @memberof CreateIntegrationRequest
     */
    redshift?: RedshiftIntegration;
    /**
     * GCS details
     * @type {GcsIntegration}
     * @memberof CreateIntegrationRequest
     */
    gcs?: GcsIntegration;
    /**
     * 
     * @type {SegmentIntegration}
     * @memberof CreateIntegrationRequest
     */
    segment?: SegmentIntegration;
    /**
     * 
     * @type {KafkaIntegration}
     * @memberof CreateIntegrationRequest
     */
    kafka?: KafkaIntegration;
    /**
     * MongoDb details
     * @type {MongoDbIntegration}
     * @memberof CreateIntegrationRequest
     */
    mongodb?: MongoDbIntegration;
}

/**
 * 
 * @export
 * @interface CreateIntegrationResponse
 */
export interface CreateIntegrationResponse {
    /**
     * integration object that was created
     * @type {Integration}
     * @memberof CreateIntegrationResponse
     */
    data?: Integration;
}

/**
 * 
 * @export
 * @interface CreateIpAllowlistRequest
 */
export interface CreateIpAllowlistRequest {
    /**
     * IP Allowlist policy name
     * @type {string}
     * @memberof CreateIpAllowlistRequest
     */
    name: string;
    /**
     * optional description
     * @type {string}
     * @memberof CreateIpAllowlistRequest
     */
    description?: string;
    /**
     * individual IP address or range of IP addresses in CIDR notation
     * @type {string}
     * @memberof CreateIpAllowlistRequest
     */
    ip_address: string;
}

/**
 * 
 * @export
 * @interface CreateIpAllowlistResponse
 */
export interface CreateIpAllowlistResponse {
    /**
     * IP Allowlist network policy entry that was created
     * @type {IpAllowlist}
     * @memberof CreateIpAllowlistResponse
     */
    data?: IpAllowlist;
}

/**
 * 
 * @export
 * @interface CreateOrganizationRequest
 */
export interface CreateOrganizationRequest {
    /**
     * unique identifier for the organization
     * @type {string}
     * @memberof CreateOrganizationRequest
     */
    id?: string;
    /**
     * name of the organization
     * @type {string}
     * @memberof CreateOrganizationRequest
     */
    display_name?: string;
    /**
     * name of the creating user
     * @type {string}
     * @memberof CreateOrganizationRequest
     */
    first_name?: string;
    /**
     * name of the creating user
     * @type {string}
     * @memberof CreateOrganizationRequest
     */
    last_name?: string;
    /**
     * email of the creating user
     * @type {string}
     * @memberof CreateOrganizationRequest
     */
    email?: string;
    /**
     * name of the company
     * @type {string}
     * @memberof CreateOrganizationRequest
     */
    company_name?: string;
    /**
     * phone number of the user
     * @type {string}
     * @memberof CreateOrganizationRequest
     */
    phone_number?: string;
    /**
     * whether plan is a 15 day free trial
     * @type {boolean}
     * @memberof CreateOrganizationRequest
     */
    trial?: boolean;
    /**
     * whether to use KMS for S3 operations
     * @type {boolean}
     * @memberof CreateOrganizationRequest
     */
    use_kms_for_s3?: boolean;
    /**
     * cluster id
     * @type {string}
     * @memberof CreateOrganizationRequest
     */
    cluster_id?: string;
    /**
     * cluster name to determine cluster mapping on org creation
     * @type {string}
     * @memberof CreateOrganizationRequest
     */
    cluster_name?: string;
    /**
     * encyption key
     * @type {string}
     * @memberof CreateOrganizationRequest
     */
    encryption_key?: string;
}

/**
 * 
 * @export
 * @interface CreatePreviewSourceRequest
 */
export interface CreatePreviewSourceRequest {
    /**
     * name of integration to use
     * @type {string}
     * @memberof CreatePreviewSourceRequest
     */
    integration_name?: string;
    /**
     * whether type is file upload
     * @type {boolean}
     * @memberof CreatePreviewSourceRequest
     */
    file_upload?: boolean;
    /**
     * configuration to receive data from kafka
     * @type {SourceKafka}
     * @memberof CreatePreviewSourceRequest
     */
    kafka?: SourceKafka;
}

/**
 * 
 * @export
 * @interface CreatePreviewSourceResponse
 */
export interface CreatePreviewSourceResponse {
    /**
     * details of the created preview source
     * @type {PreviewSource}
     * @memberof CreatePreviewSourceResponse
     */
    data?: PreviewSource;
}

/**
 * 
 * @export
 * @interface CreateQueryLambdaRequest
 */
export interface CreateQueryLambdaRequest {
    /**
     * Query Lambda name
     * @type {string}
     * @memberof CreateQueryLambdaRequest
     */
    name: string;
    /**
     * optional description
     * @type {string}
     * @memberof CreateQueryLambdaRequest
     */
    description?: string;
    /**
     * Query Lambda SQL query
     * @type {QueryLambdaSql}
     * @memberof CreateQueryLambdaRequest
     */
    sql: QueryLambdaSql;
}

/**
 * 
 * @export
 * @interface CreateQueryLambdaTagRequest
 */
export interface CreateQueryLambdaTagRequest {
    /**
     * name of Query Lambda tag
     * @type {string}
     * @memberof CreateQueryLambdaTagRequest
     */
    tag_name: string;
    /**
     * hash identifying a Query Lambda tag
     * @type {string}
     * @memberof CreateQueryLambdaTagRequest
     */
    version: string;
}

/**
 * 
 * @export
 * @interface CreateRoleRequest
 */
export interface CreateRoleRequest {
    /**
     * Unique identifier for the role.
     * @type {string}
     * @memberof CreateRoleRequest
     */
    role_name?: string;
    /**
     * Description for the role.
     * @type {string}
     * @memberof CreateRoleRequest
     */
    description?: string;
    /**
     * List of privileges that will be associated with the role.
     * @type {Array<Privilege>}
     * @memberof CreateRoleRequest
     */
    privileges?: Array<Privilege>;
}

/**
 * 
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     * user email, must be unique
     * @type {string}
     * @memberof CreateUserRequest
     */
    email: string;
    /**
     * List of roles for a given user
     * @type {Array<string>}
     * @memberof CreateUserRequest
     */
    roles: Array<string>;
}

/**
 * 
 * @export
 * @interface CreateUserResponse
 */
export interface CreateUserResponse {
    /**
     * user that was created
     * @type {User}
     * @memberof CreateUserResponse
     */
    data?: User;
}

/**
 * 
 * @export
 * @interface CreateViewRequest
 */
export interface CreateViewRequest {
    /**
     * View name
     * @type {string}
     * @memberof CreateViewRequest
     */
    name: string;
    /**
     * optional description
     * @type {string}
     * @memberof CreateViewRequest
     */
    description?: string;
    /**
     * SQL for this view
     * @type {string}
     * @memberof CreateViewRequest
     */
    query: string;
}

/**
 * 
 * @export
 * @interface CreateViewResponse
 */
export interface CreateViewResponse {
    /**
     * view that was updated
     * @type {View}
     * @memberof CreateViewResponse
     */
    data?: View;
}

/**
 * 
 * @export
 * @interface CreateWorkspaceRequest
 */
export interface CreateWorkspaceRequest {
    /**
     * descriptive label and unique identifier
     * @type {string}
     * @memberof CreateWorkspaceRequest
     */
    name: string;
    /**
     * longer explanation for the workspace
     * @type {string}
     * @memberof CreateWorkspaceRequest
     */
    description?: string;
}

/**
 * 
 * @export
 * @interface CreateWorkspaceResponse
 */
export interface CreateWorkspaceResponse {
    /**
     * the workspace that was created
     * @type {Workspace}
     * @memberof CreateWorkspaceResponse
     */
    data?: Workspace;
}

/**
 * 
 * @export
 * @interface Credit
 */
export interface Credit {
    /**
     * 
     * @type {number}
     * @memberof Credit
     */
    credit_id?: number;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    org_id?: string;
    /**
     * 
     * @type {number}
     * @memberof Credit
     */
    credit_start?: number;
    /**
     * 
     * @type {number}
     * @memberof Credit
     */
    credit_end?: number;
    /**
     * 
     * @type {number}
     * @memberof Credit
     */
    value?: number;
    /**
     * 
     * @type {number}
     * @memberof Credit
     */
    value_used?: number;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Credit
     */
    credit_type?: Credit.CreditTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof Credit
     */
    max_monthly_application?: number;
}

/**
 * @export
 * @namespace Credit
 */
export namespace Credit {
    /**
     * @export
     * @enum {string}
     */
    export enum CreditTypeEnum {
        GENERIC = <any> 'GENERIC',
        COMPUTE = <any> 'COMPUTE',
        INGEST = <any> 'INGEST',
        STORAGE = <any> 'STORAGE'
    }
}

/**
 * 
 * @export
 * @interface CsvParams
 */
export interface CsvParams {
    /**
     * If the first line in every object specifies the column names
     * @type {boolean}
     * @memberof CsvParams
     */
    firstLineAsColumnNames?: boolean;
    /**
     * a single character that is the column separator
     * @type {string}
     * @memberof CsvParams
     */
    separator?: string;
    /**
     * can be one of: UTF-8, ISO_8859_1, UTF-16
     * @type {string}
     * @memberof CsvParams
     */
    encoding?: string;
    /**
     * names of columns
     * @type {Array<string>}
     * @memberof CsvParams
     */
    columnNames?: Array<string>;
    /**
     * names of columns
     * @type {Array<string>}
     * @memberof CsvParams
     */
    columnTypes?: Array<CsvParams.ColumnTypesEnum>;
    /**
     * character within which a cell value is enclosed,null character if no such character, default is '\"'
     * @type {string}
     * @memberof CsvParams
     */
    quoteChar?: string;
    /**
     * escape character removes any special meaning from the following character,default is '\\'
     * @type {string}
     * @memberof CsvParams
     */
    escapeChar?: string;
}

/**
 * @export
 * @namespace CsvParams
 */
export namespace CsvParams {
    /**
     * @export
     * @enum {string}
     */
    export enum ColumnTypesEnum {
        UNKNOWN = <any> 'UNKNOWN',
        BOOLEAN = <any> 'BOOLEAN',
        BOOL = <any> 'BOOL',
        INTEGER = <any> 'INTEGER',
        INT = <any> 'INT',
        FLOAT = <any> 'FLOAT',
        TIME = <any> 'TIME',
        DATE = <any> 'DATE',
        DATETIME = <any> 'DATETIME',
        TIMESTAMP = <any> 'TIMESTAMP',
        STRING = <any> 'STRING'
    }
}

/**
 * 
 * @export
 * @interface DeleteAliasResponse
 */
export interface DeleteAliasResponse {
    /**
     * alias that was deleted
     * @type {Alias}
     * @memberof DeleteAliasResponse
     */
    data?: Alias;
}

/**
 * 
 * @export
 * @interface DeleteApiKeyResponse
 */
export interface DeleteApiKeyResponse {
    /**
     * The API key that was deleted.
     * @type {ApiKey}
     * @memberof DeleteApiKeyResponse
     */
    data?: ApiKey;
}

/**
 * 
 * @export
 * @interface DeleteCollectionResponse
 */
export interface DeleteCollectionResponse {
    /**
     * collection that was deleted
     * @type {Collection}
     * @memberof DeleteCollectionResponse
     */
    data?: Collection;
}

/**
 * 
 * @export
 * @interface DeleteDocumentsRequest
 */
export interface DeleteDocumentsRequest {
    /**
     * Array of IDs of documents to be deleted
     * @type {Array<DeleteDocumentsRequestData>}
     * @memberof DeleteDocumentsRequest
     */
    data: Array<DeleteDocumentsRequestData>;
}

/**
 * 
 * @export
 * @interface DeleteDocumentsRequestData
 */
export interface DeleteDocumentsRequestData {
    /**
     * unique document ID
     * @type {string}
     * @memberof DeleteDocumentsRequestData
     */
    _id: string;
}

/**
 * 
 * @export
 * @interface DeleteDocumentsResponse
 */
export interface DeleteDocumentsResponse {
    /**
     * information about deleted documents
     * @type {Array<DocumentStatus>}
     * @memberof DeleteDocumentsResponse
     */
    data?: Array<DocumentStatus>;
}

/**
 * 
 * @export
 * @interface DeleteIntegrationResponse
 */
export interface DeleteIntegrationResponse {
    /**
     * integration object that was deleted
     * @type {Integration}
     * @memberof DeleteIntegrationResponse
     */
    data?: Integration;
}

/**
 * 
 * @export
 * @interface DeleteIpAllowlistRequest
 */
export interface DeleteIpAllowlistRequest {
    /**
     * Org ID of the org for which we want to delete an entry
     * @type {string}
     * @memberof DeleteIpAllowlistRequest
     */
    org_id?: string;
}

/**
 * 
 * @export
 * @interface DeleteIpAllowlistResponse
 */
export interface DeleteIpAllowlistResponse {
    /**
     * IP Allowlist network policy entry that was deleted
     * @type {IpAllowlist}
     * @memberof DeleteIpAllowlistResponse
     */
    data?: IpAllowlist;
}

/**
 * 
 * @export
 * @interface DeleteQueryLambdaResponse
 */
export interface DeleteQueryLambdaResponse {
    /**
     * Query Lambda details
     * @type {QueryLambda}
     * @memberof DeleteQueryLambdaResponse
     */
    data?: QueryLambda;
}

/**
 * 
 * @export
 * @interface DeleteUserResponse
 */
export interface DeleteUserResponse {
    /**
     * user object that was deleted
     * @type {User}
     * @memberof DeleteUserResponse
     */
    data?: User;
}

/**
 * 
 * @export
 * @interface DeleteViewResponse
 */
export interface DeleteViewResponse {
    /**
     * view that was deleted
     * @type {View}
     * @memberof DeleteViewResponse
     */
    data?: View;
}

/**
 * 
 * @export
 * @interface DeleteWorkspaceResponse
 */
export interface DeleteWorkspaceResponse {
    /**
     * the workspace that was deleted
     * @type {Workspace}
     * @memberof DeleteWorkspaceResponse
     */
    data?: Workspace;
}

/**
 * 
 * @export
 * @interface DocumentStatus
 */
export interface DocumentStatus {
    /**
     * collection name
     * @type {string}
     * @memberof DocumentStatus
     */
    _collection?: string;
    /**
     * error message, if any
     * @type {ErrorModel}
     * @memberof DocumentStatus
     */
    error?: ErrorModel;
    /**
     * unique document ID
     * @type {string}
     * @memberof DocumentStatus
     */
    _id?: string;
    /**
     * status, one of ADDED, REPLACED, DELETED, ERROR
     * @type {string}
     * @memberof DocumentStatus
     */
    status?: DocumentStatus.StatusEnum;
    /**
     * unique id used to represent each patch request
     * @type {string}
     * @memberof DocumentStatus
     */
    patch_id?: string;
}

/**
 * @export
 * @namespace DocumentStatus
 */
export namespace DocumentStatus {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        ADDED = <any> 'ADDED',
        REPLACED = <any> 'REPLACED',
        DELETED = <any> 'DELETED',
        PATCHED = <any> 'PATCHED',
        ERROR = <any> 'ERROR'
    }
}

/**
 * 
 * @export
 * @interface DynamodbIntegration
 */
export interface DynamodbIntegration {
    /**
     * credentials for an AWS access key integration
     * @type {AwsAccessKey}
     * @memberof DynamodbIntegration
     */
    aws_access_key?: AwsAccessKey;
    /**
     * role used for external id type authentication
     * @type {AwsRole}
     * @memberof DynamodbIntegration
     */
    aws_role?: AwsRole;
    /**
     * S3 bucket used for export during collection initial dump
     * @type {string}
     * @memberof DynamodbIntegration
     */
    s3_export_bucket_name?: string;
}

/**
 * Describes details about an error
 * @export
 * @interface ErrorModel
 */
export interface ErrorModel {
    /**
     * descriptive message about the error
     * @type {string}
     * @memberof ErrorModel
     */
    message?: string;
    /**
     * category of the error
     * @type {string}
     * @memberof ErrorModel
     */
    type?: ErrorModel.TypeEnum;
    /**
     * Line where the error happened (if applicable)
     * @type {number}
     * @memberof ErrorModel
     */
    line?: number;
    /**
     * Column where the error happened (if applicable)
     * @type {number}
     * @memberof ErrorModel
     */
    column?: number;
    /**
     * Internal trace ID to help with debugging
     * @type {string}
     * @memberof ErrorModel
     */
    trace_id?: string;
    /**
     * ID of the error
     * @type {string}
     * @memberof ErrorModel
     */
    error_id?: string;
}

/**
 * @export
 * @namespace ErrorModel
 */
export namespace ErrorModel {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        AUTHEXCEPTION = <any> 'AUTHEXCEPTION',
        VERSIONEXCEPTION = <any> 'VERSIONEXCEPTION',
        INTERNALERROR = <any> 'INTERNALERROR',
        INVALIDINPUT = <any> 'INVALIDINPUT',
        NOTIMPLEMENTEDYET = <any> 'NOTIMPLEMENTEDYET',
        RESOURCEEXCEEDED = <any> 'RESOURCEEXCEEDED',
        ALREADYEXISTS = <any> 'ALREADYEXISTS',
        NOTALLOWED = <any> 'NOTALLOWED',
        NOTACCEPTABLE = <any> 'NOTACCEPTABLE',
        NOTSUPPORTED = <any> 'NOTSUPPORTED',
        NOTFOUND = <any> 'NOTFOUND',
        DEPENDENTRESOURCES = <any> 'DEPENDENTRESOURCES',
        QUERYERROR = <any> 'QUERY_ERROR',
        NOTREADY = <any> 'NOT_READY',
        FORBIDDEN = <any> 'FORBIDDEN',
        QUERYTIMEOUT = <any> 'QUERY_TIMEOUT',
        ROLENOTFOUND = <any> 'ROLE_NOT_FOUND',
        CONNECTIONERROR = <any> 'CONNECTION_ERROR',
        CREATING = <any> 'CREATING',
        BADREQUEST = <any> 'BADREQUEST',
        SERVICEUNAVAILABLE = <any> 'SERVICEUNAVAILABLE',
        RATELIMITEXCEEDED = <any> 'RATELIMITEXCEEDED',
        QUERYCANCELLED = <any> 'QUERY_CANCELLED',
        CLIENTCONNECTIONERROR = <any> 'CLIENT_CONNECTION_ERROR'
    }
}

/**
 * 
 * @export
 * @interface EventTimeInfo
 */
export interface EventTimeInfo {
    /**
     * name of the field containing event time
     * @type {string}
     * @memberof EventTimeInfo
     */
    field: string;
    /**
     * format of time field, can be one of: milliseconds_since_epoch, seconds_since_epoch
     * @type {string}
     * @memberof EventTimeInfo
     */
    format?: string;
    /**
     * default time zone, in standard IANA format
     * @type {string}
     * @memberof EventTimeInfo
     */
    time_zone?: string;
}

/**
 * 
 * @export
 * @interface ExecuteQueryLambdaRequest
 */
export interface ExecuteQueryLambdaRequest {
    /**
     * list of named parameters
     * @type {Array<QueryParameter>}
     * @memberof ExecuteQueryLambdaRequest
     */
    parameters?: Array<QueryParameter>;
    /**
     * Row limit to use if no limit specified in the SQL query text
     * @type {number}
     * @memberof ExecuteQueryLambdaRequest
     */
    default_row_limit?: number;
    /**
     * Whether to generate warnings
     * @type {boolean}
     * @memberof ExecuteQueryLambdaRequest
     */
    generate_warnings?: boolean;
    /**
     * Flag to paginate and store the results of this query for later / sequential retrieval.
     * @type {boolean}
     * @memberof ExecuteQueryLambdaRequest
     */
    paginate?: boolean;
    /**
     * Number of documents to return in addition to paginating for this query call. Only relevant if `paginate` flag is also set.
     * @type {number}
     * @memberof ExecuteQueryLambdaRequest
     */
    initial_paginate_response_doc_count?: number;
}

/**
 * 
 * @export
 * @interface FieldMapping
 */
export interface FieldMapping {
}

/**
 * 
 * @export
 * @interface FieldMappingQuery
 */
export interface FieldMappingQuery {
    /**
     * SELECT * EXCEPT (name), SHA256(name) AS name_anon FROM _input
     * @type {string}
     * @memberof FieldMappingQuery
     */
    sql?: string;
}

/**
 * 
 * @export
 * @interface FieldMappingV2
 */
export interface FieldMappingV2 {
    /**
     * A user specified string that is a name for this mapping
     * @type {string}
     * @memberof FieldMappingV2
     */
    name?: string;
    /**
     * A boolean that determines whether to drop all fields in this document. If set, input and output fields should not be set
     * @type {boolean}
     * @memberof FieldMappingV2
     */
    is_drop_all_fields?: boolean;
    /**
     * A List of InputField for this mapping
     * @type {Array<InputField>}
     * @memberof FieldMappingV2
     */
    input_fields?: Array<InputField>;
    /**
     * An OutputField for this mapping
     * @type {OutputField}
     * @memberof FieldMappingV2
     */
    output_field?: OutputField;
}

/**
 * 
 * @export
 * @interface FieldMask
 */
export interface FieldMask {
    /**
     * 
     * @type {Array<string>}
     * @memberof FieldMask
     */
    input_path: Array<string>;
    /**
     * 
     * @type {FieldMaskMask}
     * @memberof FieldMask
     */
    mask?: FieldMaskMask;
}

/**
 * Field masking function name + args. The args is a JSON object.
 * @export
 * @interface FieldMaskMask
 */
export interface FieldMaskMask {
    /**
     * 
     * @type {string}
     * @memberof FieldMaskMask
     */
    name: string;
    /**
     * 
     * @type {any}
     * @memberof FieldMaskMask
     */
    args?: any;
}

/**
 * 
 * @export
 * @interface FieldOptions
 */
export interface FieldOptions {
    /**
     *  index or no_index
     * @type {string}
     * @memberof FieldOptions
     */
    index_mode?: string;
    /**
     *  v1_index or no_index
     * @type {string}
     * @memberof FieldOptions
     */
    range_index_mode?: string;
    /**
     *  index or no_index
     * @type {string}
     * @memberof FieldOptions
     */
    type_index_mode?: string;
    /**
     *  store or no_store
     * @type {string}
     * @memberof FieldOptions
     */
    column_index_mode?: string;
}

/**
 * 
 * @export
 * @interface FieldPartition
 */
export interface FieldPartition {
    /**
     * The name of a field, parsed as a SQL qualified name
     * @type {string}
     * @memberof FieldPartition
     */
    field_name?: string;
    /**
     * The type of partitions on a field
     * @type {string}
     * @memberof FieldPartition
     */
    type?: FieldPartition.TypeEnum;
    /**
     * The values for partitioning of a field
     * @type {Array<string>}
     * @memberof FieldPartition
     */
    keys?: Array<string>;
}

/**
 * @export
 * @namespace FieldPartition
 */
export namespace FieldPartition {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        AUTO = <any> 'AUTO'
    }
}

/**
 * 
 * @export
 * @interface FieldSchema
 */
export interface FieldSchema {
    /**
     * The name of a field, parsed as a SQL qualified name
     * @type {string}
     * @memberof FieldSchema
     */
    field_name?: string;
    /**
     * The indexing options for a field
     * @type {FieldOptions}
     * @memberof FieldSchema
     */
    field_options?: FieldOptions;
}

/**
 * 
 * @export
 * @interface FileUploadStatus
 */
export interface FileUploadStatus {
    /**
     * name of the file uploaded
     * @type {string}
     * @memberof FileUploadStatus
     */
    file_name?: string;
    /**
     * ISO-8601 date
     * @type {string}
     * @memberof FileUploadStatus
     */
    uploaded_at?: string;
    /**
     * id used to identify a file upload request
     * @type {string}
     * @memberof FileUploadStatus
     */
    file_upload_id?: string;
}

/**
 * 
 * @export
 * @interface FormDataBodyPart
 */
export interface FormDataBodyPart {
    /**
     * 
     * @type {ContentDisposition}
     * @memberof FormDataBodyPart
     */
    contentDisposition?: ContentDisposition;
    /**
     * 
     * @type {any}
     * @memberof FormDataBodyPart
     */
    entity?: any;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof FormDataBodyPart
     */
    headers?: { [key: string]: Array<string>; };
    /**
     * 
     * @type {MediaType}
     * @memberof FormDataBodyPart
     */
    mediaType?: MediaType;
    /**
     * 
     * @type {MessageBodyWorkers}
     * @memberof FormDataBodyPart
     */
    messageBodyWorkers?: MessageBodyWorkers;
    /**
     * 
     * @type {MultiPart}
     * @memberof FormDataBodyPart
     */
    parent?: MultiPart;
    /**
     * 
     * @type {Providers}
     * @memberof FormDataBodyPart
     */
    providers?: Providers;
    /**
     * 
     * @type {boolean}
     * @memberof FormDataBodyPart
     */
    simple?: boolean;
    /**
     * 
     * @type {FormDataContentDisposition}
     * @memberof FormDataBodyPart
     */
    formDataContentDisposition?: FormDataContentDisposition;
    /**
     * 
     * @type {string}
     * @memberof FormDataBodyPart
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FormDataBodyPart
     */
    value?: string;
    /**
     * 
     * @type {{ [key: string]: Array<ParameterizedHeader>; }}
     * @memberof FormDataBodyPart
     */
    parameterizedHeaders?: { [key: string]: Array<ParameterizedHeader>; };
}

/**
 * 
 * @export
 * @interface FormDataContentDisposition
 */
export interface FormDataContentDisposition {
    /**
     * 
     * @type {string}
     * @memberof FormDataContentDisposition
     */
    type?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof FormDataContentDisposition
     */
    parameters?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof FormDataContentDisposition
     */
    fileName?: string;
    /**
     * 
     * @type {Date}
     * @memberof FormDataContentDisposition
     */
    creationDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof FormDataContentDisposition
     */
    modificationDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof FormDataContentDisposition
     */
    readDate?: Date;
    /**
     * 
     * @type {number}
     * @memberof FormDataContentDisposition
     */
    size?: number;
    /**
     * 
     * @type {string}
     * @memberof FormDataContentDisposition
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface FormatParams
 */
export interface FormatParams {
    /**
     * source data is in json format
     * @type {boolean}
     * @memberof FormatParams
     */
    json?: boolean;
    /**
     * 
     * @type {CsvParams}
     * @memberof FormatParams
     */
    csv?: CsvParams;
    /**
     * 
     * @type {XmlParams}
     * @memberof FormatParams
     */
    xml?: XmlParams;
    /**
     * 
     * @type {boolean}
     * @memberof FormatParams
     */
    mysql_dms?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FormatParams
     */
    postgres_dms?: boolean;
}

/**
 * 
 * @export
 * @interface GcpServiceAccount
 */
export interface GcpServiceAccount {
    /**
     * Contents of JSON Service Account key file
     * @type {string}
     * @memberof GcpServiceAccount
     */
    service_account_key_file_json: string;
}

/**
 * 
 * @export
 * @interface GcsIntegration
 */
export interface GcsIntegration {
    /**
     * credentials for an AWS key integration
     * @type {GcpServiceAccount}
     * @memberof GcsIntegration
     */
    gcp_service_account?: GcpServiceAccount;
}

/**
 * 
 * @export
 * @interface GetActivityResponse
 */
export interface GetActivityResponse {
    /**
     * list of activity details
     * @type {Array<any>}
     * @memberof GetActivityResponse
     */
    activities?: Array<any>;
}

/**
 * 
 * @export
 * @interface GetAliasResponse
 */
export interface GetAliasResponse {
    /**
     * alias that was requested
     * @type {Alias}
     * @memberof GetAliasResponse
     */
    data?: Alias;
}

/**
 * 
 * @export
 * @interface GetApiKeyResponse
 */
export interface GetApiKeyResponse {
    /**
     * The requested API key object.
     * @type {ApiKey}
     * @memberof GetApiKeyResponse
     */
    data?: ApiKey;
}

/**
 * 
 * @export
 * @interface GetCollectionCommit
 */
export interface GetCollectionCommit {
    /**
     * 
     * @type {GetCollectionCommitData}
     * @memberof GetCollectionCommit
     */
    data?: GetCollectionCommitData;
    /**
     * 
     * @type {Offsets}
     * @memberof GetCollectionCommit
     */
    offsets?: Offsets;
}

/**
 * 
 * @export
 * @interface GetCollectionCommitData
 */
export interface GetCollectionCommitData {
    /**
     * 
     * @type {string}
     * @memberof GetCollectionCommitData
     */
    fence?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetCollectionCommitData
     */
    passed?: boolean;
}

/**
 * 
 * @export
 * @interface GetCollectionResponse
 */
export interface GetCollectionResponse {
    /**
     * collection that was requested
     * @type {Collection}
     * @memberof GetCollectionResponse
     */
    data?: Collection;
}

/**
 * 
 * @export
 * @interface GetIntegrationResponse
 */
export interface GetIntegrationResponse {
    /**
     * integration object
     * @type {Integration}
     * @memberof GetIntegrationResponse
     */
    data?: Integration;
}

/**
 * 
 * @export
 * @interface GetIpAllowlistResponse
 */
export interface GetIpAllowlistResponse {
    /**
     * IP Allowlist entry that was requested
     * @type {IpAllowlist}
     * @memberof GetIpAllowlistResponse
     */
    data?: IpAllowlist;
}

/**
 * 
 * @export
 * @interface GetUserTosResponse
 */
export interface GetUserTosResponse {
    /**
     * date user has accepted ToS
     * @type {string}
     * @memberof GetUserTosResponse
     */
    data?: string;
}

/**
 * 
 * @export
 * @interface GetViewResponse
 */
export interface GetViewResponse {
    /**
     * view that was requested
     * @type {View}
     * @memberof GetViewResponse
     */
    data?: View;
}

/**
 * 
 * @export
 * @interface GetVirtualInstanceMetricsResponse
 */
export interface GetVirtualInstanceMetricsResponse {
    /**
     * virtual instance
     * @type {VirtualInstance}
     * @memberof GetVirtualInstanceMetricsResponse
     */
    virtual_instance?: VirtualInstance;
    /**
     * virtual instance metrics per time
     * @type {Array<VirtualInstanceMetrics>}
     * @memberof GetVirtualInstanceMetricsResponse
     */
    metrics?: Array<VirtualInstanceMetrics>;
}

/**
 * 
 * @export
 * @interface GetVirtualInstanceResponse
 */
export interface GetVirtualInstanceResponse {
    /**
     * virtual instance that was requested
     * @type {VirtualInstance}
     * @memberof GetVirtualInstanceResponse
     */
    data?: VirtualInstance;
}

/**
 * 
 * @export
 * @interface GetWorkspaceResponse
 */
export interface GetWorkspaceResponse {
    /**
     * the workspace that was requested
     * @type {Workspace}
     * @memberof GetWorkspaceResponse
     */
    data?: Workspace;
}

/**
 * 
 * @export
 * @interface IngestUsage
 */
export interface IngestUsage {
    /**
     * 
     * @type {Array<IngestUsagePrice>}
     * @memberof IngestUsage
     */
    states: Array<IngestUsagePrice>;
    /**
     * 
     * @type {number}
     * @memberof IngestUsage
     */
    total_cost: number;
}

/**
 * 
 * @export
 * @interface IngestUsagePrice
 */
export interface IngestUsagePrice {
    /**
     * 
     * @type {number}
     * @memberof IngestUsagePrice
     */
    price?: number;
    /**
     * 
     * @type {number}
     * @memberof IngestUsagePrice
     */
    total_bytes_ingested?: number;
    /**
     * 
     * @type {number}
     * @memberof IngestUsagePrice
     */
    total_cost?: number;
}

/**
 * 
 * @export
 * @interface InputField
 */
export interface InputField {
    /**
     * The name of a field, parsed as a SQL qualified name
     * @type {string}
     * @memberof InputField
     */
    field_name?: string;
    /**
     * Define the behaviour if fieldName is missing or is null
     * @type {string}
     * @memberof InputField
     */
    if_missing?: InputField.IfMissingEnum;
    /**
     * If true, then drop fieldName from the document
     * @type {boolean}
     * @memberof InputField
     */
    is_drop?: boolean;
    /**
     * Sql parameter name
     * @type {string}
     * @memberof InputField
     */
    param?: string;
}

/**
 * @export
 * @namespace InputField
 */
export namespace InputField {
    /**
     * @export
     * @enum {string}
     */
    export enum IfMissingEnum {
        SKIP = <any> 'SKIP',
        PASS = <any> 'PASS'
    }
}

/**
 * 
 * @export
 * @interface InputStream
 */
export interface InputStream {
}

/**
 * Instance
 * @export
 * @interface Instance
 */
export interface Instance {
    /**
     * id
     * @type {string}
     * @memberof Instance
     */
    id?: string;
    /**
     * instance plan
     * @type {string}
     * @memberof Instance
     */
    instance_plan?: Instance.InstancePlanEnum;
    /**
     * instance type
     * @type {string}
     * @memberof Instance
     */
    instance_type?: Instance.InstanceTypeEnum;
    /**
     * hourly compute
     * @type {number}
     * @memberof Instance
     */
    hourly_compute?: number;
    /**
     * compute usage
     * @type {ComputeUsage}
     * @memberof Instance
     */
    compute_usage?: ComputeUsage;
    /**
     * leaf group
     * @type {LeafGroup}
     * @memberof Instance
     */
    leaf_group?: LeafGroup;
}

/**
 * @export
 * @namespace Instance
 */
export namespace Instance {
    /**
     * @export
     * @enum {string}
     */
    export enum InstancePlanEnum {
        RESERVED = <any> 'RESERVED',
        ONDEMAND = <any> 'ON_DEMAND'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum InstanceTypeEnum {
        FREE = <any> 'FREE',
        SHARED = <any> 'SHARED',
        SMALL = <any> 'SMALL',
        MEDIUM = <any> 'MEDIUM',
        LARGE = <any> 'LARGE',
        XLARGE = <any> 'XLARGE',
        XLARGE2 = <any> 'XLARGE2',
        XLARGE4 = <any> 'XLARGE4',
        XLARGE8 = <any> 'XLARGE8',
        XLARGE16 = <any> 'XLARGE16'
    }
}

/**
 * Integrations that can be associated with data sources to create collections. Only one type of integration may be specified.
 * @export
 * @interface Integration
 */
export interface Integration {
    /**
     * descriptive label and unique identifier
     * @type {string}
     * @memberof Integration
     */
    name: string;
    /**
     * longer explanation for the integration
     * @type {string}
     * @memberof Integration
     */
    description?: string;
    /**
     * list of collections that use the integration
     * @type {Array<Collection>}
     * @memberof Integration
     */
    collections?: Array<Collection>;
    /**
     * email of user who created the integration
     * @type {string}
     * @memberof Integration
     */
    created_by: string;
    /**
     * ISO-8601 date
     * @type {string}
     * @memberof Integration
     */
    created_at?: string;
    /**
     * Amazon S3 details, must have one of aws_access_key or aws_role
     * @type {S3Integration}
     * @memberof Integration
     */
    s3?: S3Integration;
    /**
     * Amazon Kinesis details, must have one of aws_access_key or aws_role
     * @type {KinesisIntegration}
     * @memberof Integration
     */
    kinesis?: KinesisIntegration;
    /**
     * Amazon DynamoDB details, must have one of aws_access_key or aws_role
     * @type {DynamodbIntegration}
     * @memberof Integration
     */
    dynamodb?: DynamodbIntegration;
    /**
     * Amazon Redshift details
     * @type {RedshiftIntegration}
     * @memberof Integration
     */
    redshift?: RedshiftIntegration;
    /**
     * GCS details
     * @type {GcsIntegration}
     * @memberof Integration
     */
    gcs?: GcsIntegration;
    /**
     * Segment details
     * @type {SegmentIntegration}
     * @memberof Integration
     */
    segment?: SegmentIntegration;
    /**
     * Kafka details
     * @type {KafkaIntegration}
     * @memberof Integration
     */
    kafka?: KafkaIntegration;
    /**
     * MongoDb details
     * @type {MongoDbIntegration}
     * @memberof Integration
     */
    mongodb?: MongoDbIntegration;
}

/**
 * 
 * @export
 * @interface InvertedIndexGroupEncodingOptions
 */
export interface InvertedIndexGroupEncodingOptions {
    /**
     * 
     * @type {number}
     * @memberof InvertedIndexGroupEncodingOptions
     */
    format_version?: number;
    /**
     * 
     * @type {number}
     * @memberof InvertedIndexGroupEncodingOptions
     */
    group_size?: number;
    /**
     * 
     * @type {number}
     * @memberof InvertedIndexGroupEncodingOptions
     */
    restart_length?: number;
    /**
     * 
     * @type {string}
     * @memberof InvertedIndexGroupEncodingOptions
     */
    event_time_codec?: string;
    /**
     * 
     * @type {string}
     * @memberof InvertedIndexGroupEncodingOptions
     */
    doc_id_codec?: string;
}

/**
 * 
 * @export
 * @interface InviteState
 */
export interface InviteState {
    /**
     * state of user
     * @type {string}
     * @memberof InviteState
     */
    data?: InviteState.DataEnum;
}

/**
 * @export
 * @namespace InviteState
 */
export namespace InviteState {
    /**
     * @export
     * @enum {string}
     */
    export enum DataEnum {
        PENDING = <any> 'PENDING',
        ACCEPTED = <any> 'ACCEPTED',
        EXPIRED = <any> 'EXPIRED',
        CANCELLED = <any> 'CANCELLED'
    }
}

/**
 * An invoice created by Stripe.
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * total amount billed
     * @type {number}
     * @memberof Invoice
     */
    amount_paid?: number;
    /**
     * total amount billed
     * @type {number}
     * @memberof Invoice
     */
    amount_due?: number;
    /**
     * time in microseconds charge occured
     * @type {number}
     * @memberof Invoice
     */
    date?: number;
    /**
     * pdf link for full invoice with line items
     * @type {string}
     * @memberof Invoice
     */
    pdf_link?: string;
}

/**
 * 
 * @export
 * @interface IpAllowlist
 */
export interface IpAllowlist {
    /**
     * IP Allowlist policy name
     * @type {string}
     * @memberof IpAllowlist
     */
    name: string;
    /**
     * optional description
     * @type {string}
     * @memberof IpAllowlist
     */
    description?: string;
    /**
     * email of the creator
     * @type {string}
     * @memberof IpAllowlist
     */
    creator_email?: string;
    /**
     * individual IP address or range of IP addresses in CIDR notation
     * @type {string}
     * @memberof IpAllowlist
     */
    ip_address: string;
    /**
     * ISO-8601 date
     * @type {string}
     * @memberof IpAllowlist
     */
    created_at?: string;
}

/**
 * 
 * @export
 * @interface KafkaIntegration
 */
export interface KafkaIntegration {
    /**
     * Kafka topics to tail
     * @type {Array<string>}
     * @memberof KafkaIntegration
     */
    kafka_topic_names?: Array<string>;
    /**
     * The status of the Kafka source by topic
     * @type {{ [key: string]: StatusKafka; }}
     * @memberof KafkaIntegration
     */
    source_status_by_topic?: { [key: string]: StatusKafka; };
    /**
     * The format of the Kafka topics being tailed
     * @type {string}
     * @memberof KafkaIntegration
     */
    kafka_data_format?: KafkaIntegration.KafkaDataFormatEnum;
    /**
     * kafka connection string
     * @type {string}
     * @memberof KafkaIntegration
     */
    connection_string?: string;
    /**
     * Whether to use v3 integration
     * @type {boolean}
     * @memberof KafkaIntegration
     */
    use_v3?: boolean;
    /**
     * The Kafka bootstrap server url(s). Required only for V3 integration.
     * @type {string}
     * @memberof KafkaIntegration
     */
    bootstrap_servers?: string;
    /**
     * Kafka security configurations. Required only for V3 integration.
     * @type {KafkaV3SecurityConfig}
     * @memberof KafkaIntegration
     */
    security_config?: KafkaV3SecurityConfig;
}

/**
 * @export
 * @namespace KafkaIntegration
 */
export namespace KafkaIntegration {
    /**
     * @export
     * @enum {string}
     */
    export enum KafkaDataFormatEnum {
        JSON = <any> 'JSON',
        AVRO = <any> 'AVRO'
    }
}

/**
 * 
 * @export
 * @interface KafkaV3SecurityConfig
 */
export interface KafkaV3SecurityConfig {
    /**
     * The secure API key
     * @type {string}
     * @memberof KafkaV3SecurityConfig
     */
    api_key: string;
    /**
     * The secure API password
     * @type {string}
     * @memberof KafkaV3SecurityConfig
     */
    secret: string;
}

/**
 * 
 * @export
 * @interface KinesisIntegration
 */
export interface KinesisIntegration {
    /**
     * credentials for an AWS access key integration
     * @type {AwsAccessKey}
     * @memberof KinesisIntegration
     */
    aws_access_key?: AwsAccessKey;
    /**
     * details of an AWS cross-account role integration
     * @type {AwsRole}
     * @memberof KinesisIntegration
     */
    aws_role?: AwsRole;
}

/**
 * Leaf Group
 * @export
 * @interface LeafGroup
 */
export interface LeafGroup {
    /**
     * pod type
     * @type {string}
     * @memberof LeafGroup
     */
    pod_type?: LeafGroup.PodTypeEnum;
    /**
     * pod count
     * @type {number}
     * @memberof LeafGroup
     */
    pod_count?: number;
    /**
     * cpu count
     * @type {number}
     * @memberof LeafGroup
     */
    cpu_count?: number;
}

/**
 * @export
 * @namespace LeafGroup
 */
export namespace LeafGroup {
    /**
     * @export
     * @enum {string}
     */
    export enum PodTypeEnum {
        C5D9XLARGE32CPU = <any> 'C5D_9XLARGE_32CPU',
        I32XLARGE4CPU = <any> 'I3_2XLARGE_4CPU',
        I32XLARGE2CPU = <any> 'I3_2XLARGE_2CPU'
    }
}

/**
 * 
 * @export
 * @interface LineItem
 */
export interface LineItem {
    /**
     * 
     * @type {number}
     * @memberof LineItem
     */
    start?: number;
    /**
     * 
     * @type {number}
     * @memberof LineItem
     */
    end?: number;
    /**
     * 
     * @type {string}
     * @memberof LineItem
     */
    region?: string;
    /**
     * 
     * @type {number}
     * @memberof LineItem
     */
    cost?: number;
    /**
     * 
     * @type {number}
     * @memberof LineItem
     */
    quantity?: number;
    /**
     * 
     * @type {string}
     * @memberof LineItem
     */
    unit?: string;
    /**
     * 
     * @type {number}
     * @memberof LineItem
     */
    rate?: number;
    /**
     * 
     * @type {string}
     * @memberof LineItem
     */
    rate_unit?: string;
    /**
     * 
     * @type {string}
     * @memberof LineItem
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof LineItem
     */
    type?: LineItem.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof LineItem
     */
    readable_line_item?: string;
}

/**
 * @export
 * @namespace LineItem
 */
export namespace LineItem {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        COMPUTEFREE = <any> 'COMPUTE_FREE',
        COMPUTESHARED = <any> 'COMPUTE_SHARED',
        COMPUTESMALL = <any> 'COMPUTE_SMALL',
        COMPUTEMEDIUM = <any> 'COMPUTE_MEDIUM',
        COMPUTELARGE = <any> 'COMPUTE_LARGE',
        COMPUTEXLARGE = <any> 'COMPUTE_XLARGE',
        COMPUTEXLARGE2 = <any> 'COMPUTE_XLARGE2',
        COMPUTEXLARGE4 = <any> 'COMPUTE_XLARGE4',
        COMPUTEXLARGE8 = <any> 'COMPUTE_XLARGE8',
        COMPUTEXLARGE16 = <any> 'COMPUTE_XLARGE16',
        STORAGE = <any> 'STORAGE',
        INGEST = <any> 'INGEST',
        CREDITCOMPUTE = <any> 'CREDIT_COMPUTE',
        CREDITSTORAGE = <any> 'CREDIT_STORAGE',
        CREDITINGEST = <any> 'CREDIT_INGEST',
        CREDIT = <any> 'CREDIT'
    }
}

/**
 * 
 * @export
 * @interface LineItems
 */
export interface LineItems {
    /**
     * 
     * @type {string}
     * @memberof LineItems
     */
    org_id?: string;
    /**
     * 
     * @type {number}
     * @memberof LineItems
     */
    start?: number;
    /**
     * 
     * @type {number}
     * @memberof LineItems
     */
    end?: number;
    /**
     * 
     * @type {Array<LineItem>}
     * @memberof LineItems
     */
    line_items?: Array<LineItem>;
    /**
     * 
     * @type {number}
     * @memberof LineItems
     */
    total_cost?: number;
}

/**
 * 
 * @export
 * @interface LineItemsResponse
 */
export interface LineItemsResponse {
    /**
     * billing line items
     * @type {LineItems}
     * @memberof LineItemsResponse
     */
    data?: LineItems;
}

/**
 * 
 * @export
 * @interface ListAliasesResponse
 */
export interface ListAliasesResponse {
    /**
     * list of all aliases
     * @type {Array<Alias>}
     * @memberof ListAliasesResponse
     */
    data?: Array<Alias>;
}

/**
 * 
 * @export
 * @interface ListAllQueryPagesResponse
 */
export interface ListAllQueryPagesResponse {
    /**
     * 
     * @type {Array<QueryPageInfo>}
     * @memberof ListAllQueryPagesResponse
     */
    data?: Array<QueryPageInfo>;
}

/**
 * 
 * @export
 * @interface ListApiKeysResponse
 */
export interface ListApiKeysResponse {
    /**
     * List of API key objects.
     * @type {Array<ApiKey>}
     * @memberof ListApiKeysResponse
     */
    data?: Array<ApiKey>;
}

/**
 * 
 * @export
 * @interface ListCollectionsResponse
 */
export interface ListCollectionsResponse {
    /**
     * list of all collections
     * @type {Array<Collection>}
     * @memberof ListCollectionsResponse
     */
    data?: Array<Collection>;
}

/**
 * 
 * @export
 * @interface ListCreditsResponse
 */
export interface ListCreditsResponse {
    /**
     * 
     * @type {Array<Credit>}
     * @memberof ListCreditsResponse
     */
    data?: Array<Credit>;
}

/**
 * 
 * @export
 * @interface ListIntegrationsResponse
 */
export interface ListIntegrationsResponse {
    /**
     * list of integration objects
     * @type {Array<Integration>}
     * @memberof ListIntegrationsResponse
     */
    data?: Array<Integration>;
}

/**
 * 
 * @export
 * @interface ListIpAllowlistsResponse
 */
export interface ListIpAllowlistsResponse {
    /**
     * list of all IP Allowlist network policies
     * @type {Array<IpAllowlist>}
     * @memberof ListIpAllowlistsResponse
     */
    data?: Array<IpAllowlist>;
}

/**
 * 
 * @export
 * @interface ListQueryLambdaTagsResponse
 */
export interface ListQueryLambdaTagsResponse {
    /**
     * list of all tags associated with a Query Lambda
     * @type {Array<QueryLambdaTag>}
     * @memberof ListQueryLambdaTagsResponse
     */
    data?: Array<QueryLambdaTag>;
}

/**
 * 
 * @export
 * @interface ListQueryLambdaVersionsResponse
 */
export interface ListQueryLambdaVersionsResponse {
    /**
     * list of all versions for a particular Query Lambda
     * @type {Array<QueryLambdaVersion>}
     * @memberof ListQueryLambdaVersionsResponse
     */
    data?: Array<QueryLambdaVersion>;
}

/**
 * 
 * @export
 * @interface ListQueryLambdasResponse
 */
export interface ListQueryLambdasResponse {
    /**
     * list of all Query Lambdas
     * @type {Array<QueryLambda>}
     * @memberof ListQueryLambdasResponse
     */
    data?: Array<QueryLambda>;
}

/**
 * 
 * @export
 * @interface ListQueryPagesResponse
 */
export interface ListQueryPagesResponse {
    /**
     * 
     * @type {QueryPageInfo}
     * @memberof ListQueryPagesResponse
     */
    data?: QueryPageInfo;
}

/**
 * 
 * @export
 * @interface ListRolesResponse
 */
export interface ListRolesResponse {
    /**
     * List of all roles.
     * @type {Array<Role>}
     * @memberof ListRolesResponse
     */
    data?: Array<Role>;
}

/**
 * 
 * @export
 * @interface ListUnsubscribePreferencesResponse
 */
export interface ListUnsubscribePreferencesResponse {
    /**
     * List of notification preferences
     * @type {Array<UnsubscribePreference>}
     * @memberof ListUnsubscribePreferencesResponse
     */
    data?: Array<UnsubscribePreference>;
}

/**
 * 
 * @export
 * @interface ListUsersResponse
 */
export interface ListUsersResponse {
    /**
     * list of users
     * @type {Array<User>}
     * @memberof ListUsersResponse
     */
    data?: Array<User>;
}

/**
 * 
 * @export
 * @interface ListViewsResponse
 */
export interface ListViewsResponse {
    /**
     * list of all views
     * @type {Array<View>}
     * @memberof ListViewsResponse
     */
    data?: Array<View>;
}

/**
 * 
 * @export
 * @interface ListVirtualInstancesResponse
 */
export interface ListVirtualInstancesResponse {
    /**
     * list of all virtual instances
     * @type {Array<VirtualInstance>}
     * @memberof ListVirtualInstancesResponse
     */
    data?: Array<VirtualInstance>;
}

/**
 * 
 * @export
 * @interface ListWorkspacesResponse
 */
export interface ListWorkspacesResponse {
    /**
     * list of workspaces
     * @type {Array<Workspace>}
     * @memberof ListWorkspacesResponse
     */
    data?: Array<Workspace>;
}

/**
 * 
 * @export
 * @interface MarketplaceSubscriptionRequest
 */
export interface MarketplaceSubscriptionRequest {
    /**
     * 
     * @type {string}
     * @memberof MarketplaceSubscriptionRequest
     */
    aws_marketplace_token: string;
}

/**
 * 
 * @export
 * @interface MediaType
 */
export interface MediaType {
    /**
     * 
     * @type {string}
     * @memberof MediaType
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaType
     */
    subtype?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof MediaType
     */
    parameters?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof MediaType
     */
    wildcardType?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaType
     */
    wildcardSubtype?: boolean;
}

/**
 * 
 * @export
 * @interface MessageBodyWorkers
 */
export interface MessageBodyWorkers {
}

/**
 * 
 * @export
 * @interface MongoDbIntegration
 */
export interface MongoDbIntegration {
    /**
     * MongoDB connection URI string
     * @type {string}
     * @memberof MongoDbIntegration
     */
    connection_uri: string;
}

/**
 * 
 * @export
 * @interface MultiPart
 */
export interface MultiPart {
    /**
     * 
     * @type {ContentDisposition}
     * @memberof MultiPart
     */
    contentDisposition?: ContentDisposition;
    /**
     * 
     * @type {any}
     * @memberof MultiPart
     */
    entity?: any;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof MultiPart
     */
    headers?: { [key: string]: Array<string>; };
    /**
     * 
     * @type {MediaType}
     * @memberof MultiPart
     */
    mediaType?: MediaType;
    /**
     * 
     * @type {MessageBodyWorkers}
     * @memberof MultiPart
     */
    messageBodyWorkers?: MessageBodyWorkers;
    /**
     * 
     * @type {MultiPart}
     * @memberof MultiPart
     */
    parent?: MultiPart;
    /**
     * 
     * @type {Providers}
     * @memberof MultiPart
     */
    providers?: Providers;
    /**
     * 
     * @type {Array<BodyPart>}
     * @memberof MultiPart
     */
    bodyParts?: Array<BodyPart>;
    /**
     * 
     * @type {{ [key: string]: Array<ParameterizedHeader>; }}
     * @memberof MultiPart
     */
    parameterizedHeaders?: { [key: string]: Array<ParameterizedHeader>; };
}

/**
 * 
 * @export
 * @interface Offsets
 */
export interface Offsets {
    /**
     * 
     * @type {string}
     * @memberof Offsets
     */
    commit?: string;
}

/**
 * 
 * @export
 * @interface OperatorStats
 */
export interface OperatorStats {
    /**
     * The id of the worker this operator ran on
     * @type {string}
     * @memberof OperatorStats
     */
    worker?: string;
    /**
     * The id of the fragment this operator belonged to
     * @type {number}
     * @memberof OperatorStats
     */
    fragment?: number;
    /**
     * The id of the task this operator belonged to
     * @type {string}
     * @memberof OperatorStats
     */
    task?: string;
    /**
     * The id of this operator in the task
     * @type {number}
     * @memberof OperatorStats
     */
    operator_id?: number;
    /**
     * The class name of this operator
     * @type {string}
     * @memberof OperatorStats
     */
    operator_name?: string;
    /**
     * Microseconds since UNIX epoch of the first time data was received from any of this operator's inputs
     * @type {number}
     * @memberof OperatorStats
     */
    start_time_us?: number;
    /**
     * Microseconds since UNIX epoch of the last time data was sent to any of this operator's outputs
     * @type {number}
     * @memberof OperatorStats
     */
    end_time_us?: number;
    /**
     * Maximum memory used by this operator during execution
     * @type {number}
     * @memberof OperatorStats
     */
    max_memory?: number;
    /**
     * Total bytes received across all inputs
     * @type {number}
     * @memberof OperatorStats
     */
    input_bytes?: number;
    /**
     * Total rows received across all inputs
     * @type {number}
     * @memberof OperatorStats
     */
    input_rows?: number;
    /**
     * Total bytes sent across all outputs
     * @type {number}
     * @memberof OperatorStats
     */
    output_bytes?: number;
    /**
     * Total rows sent across all outputs
     * @type {number}
     * @memberof OperatorStats
     */
    output_rows?: number;
    /**
     * Total time in microseconds spent doing useful work
     * @type {number}
     * @memberof OperatorStats
     */
    processing_time_us?: number;
    /**
     * Number of times InvertedIndexLazyMergeOperator is invoked to perform lazy merge
     * @type {number}
     * @memberof OperatorStats
     */
    term_iterator_merge_count?: number;
    /**
     * Number of operands InvertedIndexLazyMergeOperator merged in total
     * @type {number}
     * @memberof OperatorStats
     */
    term_iterator_merge_operand_count?: number;
    /**
     * Time spent in the merge operation in InvertedIndexLazyMergeOperator
     * @type {number}
     * @memberof OperatorStats
     */
    term_iterator_merge_duration_secs?: number;
    /**
     * Max size of value merged by InvertedIndexLazyMergeOperator
     * @type {number}
     * @memberof OperatorStats
     */
    term_iterator_max_merged_value_size?: number;
}

/**
 * 
 * @export
 * @interface OrgBillingPortalResponse
 */
export interface OrgBillingPortalResponse {
    /**
     * 
     * @type {string}
     * @memberof OrgBillingPortalResponse
     */
    portal_url?: string;
}

/**
 * 
 * @export
 * @interface OrgCompute
 */
export interface OrgCompute {
    /**
     * 
     * @type {number}
     * @memberof OrgCompute
     */
    compute_cost: number;
    /**
     * 
     * @type {Array<Instance>}
     * @memberof OrgCompute
     */
    instances: Array<Instance>;
}

/**
 * 
 * @export
 * @interface OrgComputeResponse
 */
export interface OrgComputeResponse {
    /**
     * OrgCompute object
     * @type {OrgCompute}
     * @memberof OrgComputeResponse
     */
    data?: OrgCompute;
}

/**
 * 
 * @export
 * @interface OrgIngestResponse
 */
export interface OrgIngestResponse {
    /**
     * OrgIngest object
     * @type {IngestUsage}
     * @memberof OrgIngestResponse
     */
    data?: IngestUsage;
}

/**
 * Invoice history for an organization.
 * @export
 * @interface OrgInvoices
 */
export interface OrgInvoices {
    /**
     * list of historical invoices
     * @type {Array<Invoice>}
     * @memberof OrgInvoices
     */
    invoices?: Array<Invoice>;
}

/**
 * 
 * @export
 * @interface OrgInvoicesResponse
 */
export interface OrgInvoicesResponse {
    /**
     * OrgInvoices object
     * @type {OrgInvoices}
     * @memberof OrgInvoicesResponse
     */
    data?: OrgInvoices;
}

/**
 * 
 * @export
 * @interface OrgMembership
 */
export interface OrgMembership {
    /**
     * 
     * @type {Organization}
     * @memberof OrgMembership
     */
    organization: Organization;
    /**
     * 
     * @type {Array<string>}
     * @memberof OrgMembership
     */
    roles: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof OrgMembership
     */
    invite_state: OrgMembership.InviteStateEnum;
    /**
     * 
     * @type {string}
     * @memberof OrgMembership
     */
    invited_by: string;
    /**
     * email of the user
     * @type {string}
     * @memberof OrgMembership
     */
    email?: string;
    /**
     * ISO-8601 date
     * @type {string}
     * @memberof OrgMembership
     */
    expires_at: string;
    /**
     * ISO-8601 date
     * @type {string}
     * @memberof OrgMembership
     */
    created_at: string;
}

/**
 * @export
 * @namespace OrgMembership
 */
export namespace OrgMembership {
    /**
     * @export
     * @enum {string}
     */
    export enum InviteStateEnum {
        PENDING = <any> 'PENDING',
        ACCEPTED = <any> 'ACCEPTED',
        EXPIRED = <any> 'EXPIRED',
        CANCELLED = <any> 'CANCELLED'
    }
}

/**
 * Information related to payment for an organization.
 * @export
 * @interface OrgPaymentMethod
 */
export interface OrgPaymentMethod {
    /**
     * stripe source ID associated with credit card
     * @type {string}
     * @memberof OrgPaymentMethod
     */
    card_source_id?: string;
    /**
     * brand of credit card
     * @type {string}
     * @memberof OrgPaymentMethod
     */
    card_brand?: string;
    /**
     * origin country of credit card
     * @type {string}
     * @memberof OrgPaymentMethod
     */
    card_country?: string;
    /**
     * credit card expiration month
     * @type {string}
     * @memberof OrgPaymentMethod
     */
    card_exp_month?: string;
    /**
     * credit card expiration year
     * @type {string}
     * @memberof OrgPaymentMethod
     */
    card_exp_year?: string;
    /**
     * debit or credit
     * @type {string}
     * @memberof OrgPaymentMethod
     */
    card_funding?: string;
    /**
     * last 4 digits of credit card
     * @type {string}
     * @memberof OrgPaymentMethod
     */
    card_last4?: string;
    /**
     * status of credit card
     * @type {string}
     * @memberof OrgPaymentMethod
     */
    card_status?: string;
    /**
     * stripe customer id. not a secret.
     * @type {string}
     * @memberof OrgPaymentMethod
     */
    customer_id?: string;
}

/**
 * 
 * @export
 * @interface OrgPaymentMethodResponse
 */
export interface OrgPaymentMethodResponse {
    /**
     * OrgPaymentMethod object
     * @type {OrgPaymentMethod}
     * @memberof OrgPaymentMethodResponse
     */
    data?: OrgPaymentMethod;
}

/**
 * Settings for an organization.
 * @export
 * @interface OrgSettings
 */
export interface OrgSettings {
    /**
     * Max number of aggregators per query
     * @type {number}
     * @memberof OrgSettings
     */
    aggregator_parallelism?: number;
    /**
     * collection limit per organization
     * @type {number}
     * @memberof OrgSettings
     */
    collection_limit?: number;
    /**
     * alias limit per organization
     * @type {number}
     * @memberof OrgSettings
     */
    alias_limit?: number;
    /**
     * IP allowlist limit per organization
     * @type {number}
     * @memberof OrgSettings
     */
    ip_allowlist_limit?: number;
    /**
     * Console metrics days limit per organization
     * @type {number}
     * @memberof OrgSettings
     */
    console_metrics_days_limit?: number;
    /**
     * Custom roles limit per organization
     * @type {number}
     * @memberof OrgSettings
     */
    custom_role_limit?: number;
    /**
     * Query Lambda limit per organization
     * @type {number}
     * @memberof OrgSettings
     */
    query_lambda_count_limit?: number;
    /**
     * version limit per Query Lambda
     * @type {number}
     * @memberof OrgSettings
     */
    query_lambda_version_count_limit?: number;
    /**
     * Unique tag limit per organization
     * @type {number}
     * @memberof OrgSettings
     */
    unique_tag_count_limit?: number;
    /**
     * concurrent queries limit per organization
     * @type {number}
     * @memberof OrgSettings
     */
    concurrent_queries_limit?: number;
    /**
     * concurrent query execution limit per organization
     * @type {number}
     * @memberof OrgSettings
     */
    concurrent_query_execution_limit?: number;
    /**
     * identifier for encryption key for org
     * @type {string}
     * @memberof OrgSettings
     */
    encryption_key?: string;
    /**
     * number of file uploads allowed per collection
     * @type {number}
     * @memberof OrgSettings
     */
    file_upload_limit_per_collection?: number;
    /**
     * input rate limit in megabytes per second
     * @type {number}
     * @memberof OrgSettings
     */
    input_rate_limit_kbps?: number;
    /**
     * number of partitions in the log store for each collection
     * @type {number}
     * @memberof OrgSettings
     */
    log_partitions_per_collection?: number;
    /**
     * custom unit price for ingest
     * @type {number}
     * @memberof OrgSettings
     */
    custom_ingest_price?: number;
    /**
     * custom trial credit amount
     * @type {number}
     * @memberof OrgSettings
     */
    custom_trial_credit?: number;
    /**
     * hourly compute price
     * @type {number}
     * @memberof OrgSettings
     */
    hourly_compute_price?: number;
    /**
     * the minimum monthly bill for an organization
     * @type {number}
     * @memberof OrgSettings
     */
    min_monthly_bill?: number;
    /**
     * Pending invites limit per organization
     * @type {number}
     * @memberof OrgSettings
     */
    pending_invites_limit?: number;
    /**
     * Total users limit per organization
     * @type {number}
     * @memberof OrgSettings
     */
    total_users_limit?: number;
    /**
     * Max amount of memory allocated per query per worker node
     * @type {number}
     * @memberof OrgSettings
     */
    query_memory_limit_bytes?: number;
    /**
     * whether role-based access control is enabled
     * @type {number}
     * @memberof OrgSettings
     */
    replication_factor?: number;
    /**
     * min number of shards in Rockset for each collection
     * @type {number}
     * @memberof OrgSettings
     */
    min_shards_per_collection?: number;
    /**
     * max number of shards in Rockset for each collection
     * @type {number}
     * @memberof OrgSettings
     */
    max_shards_per_collection?: number;
    /**
     * storage size limit in bytes
     * @type {number}
     * @memberof OrgSettings
     */
    size_limit_bytes?: number;
    /**
     * whether Single Sign On is enabled
     * @type {boolean}
     * @memberof OrgSettings
     */
    sso_enabled?: boolean;
    /**
     * state of the org
     * @type {string}
     * @memberof OrgSettings
     */
    state?: OrgSettings.StateEnum;
    /**
     * edition of the org
     * @type {string}
     * @memberof OrgSettings
     */
    edition?: OrgSettings.EditionEnum;
    /**
     * data when trial ends
     * @type {number}
     * @memberof OrgSettings
     */
    trial_end?: number;
    /**
     * date when trial began
     * @type {number}
     * @memberof OrgSettings
     */
    trial_start?: number;
    /**
     * list of console feature flags that are on
     * @type {Array<string>}
     * @memberof OrgSettings
     */
    console_flags?: Array<string>;
    /**
     * whether users from specified domains can be auto-provisioned with accounts
     * @type {boolean}
     * @memberof OrgSettings
     */
    auto_provision?: boolean;
    /**
     * default role for autoprovisioned users
     * @type {string}
     * @memberof OrgSettings
     */
    auto_provision_role?: string;
    /**
     * domain for which accounts can be autoprovisioned
     * @type {string}
     * @memberof OrgSettings
     */
    auto_provision_domain?: string;
    /**
     * connection name of SSO connection
     * @type {string}
     * @memberof OrgSettings
     */
    sso_connection?: string;
    /**
     * whether or not SSO is the only permitted form of auth
     * @type {boolean}
     * @memberof OrgSettings
     */
    sso_only?: boolean;
    /**
     * organization is allowed to use MFA
     * @type {boolean}
     * @memberof OrgSettings
     */
    mfa_enabled?: boolean;
    /**
     * organization requires MFA
     * @type {boolean}
     * @memberof OrgSettings
     */
    mfa_restricted?: boolean;
    /**
     * whether or not instance-based pricing is enabled for this org
     * @type {boolean}
     * @memberof OrgSettings
     */
    instance_pricing?: boolean;
}

/**
 * @export
 * @namespace OrgSettings
 */
export namespace OrgSettings {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        FREE = <any> 'FREE',
        PAID = <any> 'PAID',
        TRIAL = <any> 'TRIAL',
        TRIALEXPIRED = <any> 'TRIAL_EXPIRED',
        TRIALDEPLETED = <any> 'TRIAL_DEPLETED',
        INACTIVE = <any> 'INACTIVE',
        DELETED = <any> 'DELETED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum EditionEnum {
        STANDARD = <any> 'STANDARD',
        PREMIUM = <any> 'PREMIUM'
    }
}

/**
 * 
 * @export
 * @interface OrgSettingsResponse
 */
export interface OrgSettingsResponse {
    /**
     * OrgSettings object
     * @type {OrgSettings}
     * @memberof OrgSettingsResponse
     */
    data?: OrgSettings;
}

/**
 * 
 * @export
 * @interface OrgStorage
 */
export interface OrgStorage {
    /**
     * 
     * @type {{ [key: string]: Usage; }}
     * @memberof OrgStorage
     */
    series: { [key: string]: Usage; };
    /**
     * 
     * @type {number}
     * @memberof OrgStorage
     */
    cost: number;
}

/**
 * 
 * @export
 * @interface OrgStorageResponse
 */
export interface OrgStorageResponse {
    /**
     * OrgUsage object
     * @type {OrgStorage}
     * @memberof OrgStorageResponse
     */
    data?: OrgStorage;
}

/**
 * 
 * @export
 * @interface OrgTrialUsage
 */
export interface OrgTrialUsage {
    /**
     * 
     * @type {number}
     * @memberof OrgTrialUsage
     */
    trial_credit_used: number;
    /**
     * 
     * @type {number}
     * @memberof OrgTrialUsage
     */
    trial_credit_remaining: number;
    /**
     * 
     * @type {number}
     * @memberof OrgTrialUsage
     */
    trial_start: number;
    /**
     * 
     * @type {number}
     * @memberof OrgTrialUsage
     */
    trial_end: number;
    /**
     * 
     * @type {number}
     * @memberof OrgTrialUsage
     */
    month_credit_used: number;
}

/**
 * 
 * @export
 * @interface OrgTrialUsageResponse
 */
export interface OrgTrialUsageResponse {
    /**
     * OrgTrialUsage object
     * @type {OrgTrialUsage}
     * @memberof OrgTrialUsageResponse
     */
    data?: OrgTrialUsage;
}

/**
 * Usage statistics for an organization.
 * @export
 * @interface OrgUsage
 */
export interface OrgUsage {
    /**
     * number of active documents
     * @type {number}
     * @memberof OrgUsage
     */
    active_document_count?: number;
    /**
     * number of collections
     * @type {number}
     * @memberof OrgUsage
     */
    collection_count?: number;
    /**
     * number of users
     * @type {number}
     * @memberof OrgUsage
     */
    user_count?: number;
    /**
     * number of integrations
     * @type {number}
     * @memberof OrgUsage
     */
    integration_count?: number;
    /**
     * timestamp of last update
     * @type {string}
     * @memberof OrgUsage
     */
    last_updated_ms?: string;
    /**
     * timestamp of last query
     * @type {string}
     * @memberof OrgUsage
     */
    last_queried_ms?: string;
    /**
     * total size in bytes of all collections
     * @type {number}
     * @memberof OrgUsage
     */
    total_size_bytes?: number;
    /**
     * 
     * @type {number}
     * @memberof OrgUsage
     */
    total_index_size?: number;
    /**
     * total queries performed in org
     * @type {number}
     * @memberof OrgUsage
     */
    total_queries?: number;
}

/**
 * 
 * @export
 * @interface OrgUsageResponse
 */
export interface OrgUsageResponse {
    /**
     * OrgUsage object
     * @type {OrgUsage}
     * @memberof OrgUsageResponse
     */
    data?: OrgUsage;
}

/**
 * An organization in Rockset is a container for users and collections.
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * Rockset's global AWS user
     * @type {string}
     * @memberof Organization
     */
    rockset_user?: string;
    /**
     * organization's unique external ID within Rockset
     * @type {string}
     * @memberof Organization
     */
    external_id?: string;
    /**
     * name of the company
     * @type {string}
     * @memberof Organization
     */
    company_name?: string;
    /**
     * org state
     * @type {string}
     * @memberof Organization
     */
    state?: Organization.StateEnum;
    /**
     * org edition
     * @type {string}
     * @memberof Organization
     */
    edition?: Organization.EditionEnum;
    /**
     * AWS Marketplace Customer ID
     * @type {string}
     * @memberof Organization
     */
    aws_marketplace_customer_id?: string;
    /**
     * list of clusters associated with this org
     * @type {Array<Cluster>}
     * @memberof Organization
     */
    clusters?: Array<Cluster>;
    /**
     * Org is MFA restricted
     * @type {boolean}
     * @memberof Organization
     */
    mfa_restricted?: boolean;
    /**
     * unique identifier for the organization
     * @type {string}
     * @memberof Organization
     */
    id?: string;
    /**
     * ISO-8601 date
     * @type {string}
     * @memberof Organization
     */
    created_at?: string;
    /**
     * name of the organization
     * @type {string}
     * @memberof Organization
     */
    display_name?: string;
    /**
     * org deletion scheduled at
     * @type {string}
     * @memberof Organization
     */
    deletion_scheduled_at?: string;
}

/**
 * @export
 * @namespace Organization
 */
export namespace Organization {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        FREE = <any> 'FREE',
        PAID = <any> 'PAID',
        TRIAL = <any> 'TRIAL',
        TRIALEXPIRED = <any> 'TRIAL_EXPIRED',
        TRIALDEPLETED = <any> 'TRIAL_DEPLETED',
        INACTIVE = <any> 'INACTIVE',
        DELETED = <any> 'DELETED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum EditionEnum {
        STANDARD = <any> 'STANDARD',
        PREMIUM = <any> 'PREMIUM'
    }
}

/**
 * 
 * @export
 * @interface OrganizationResponse
 */
export interface OrganizationResponse {
    /**
     * Organization object
     * @type {Organization}
     * @memberof OrganizationResponse
     */
    data?: Organization;
}

/**
 * 
 * @export
 * @interface OutputField
 */
export interface OutputField {
    /**
     * The name of a field, parsed as a SQL qualified name 
     * @type {string}
     * @memberof OutputField
     */
    field_name?: string;
    /**
     * The name of a sql function
     * @type {SqlExpression}
     * @memberof OutputField
     */
    value?: SqlExpression;
    /**
     * Error in Mapping execution: 'skip' or 'fail' 
     * @type {string}
     * @memberof OutputField
     */
    on_error?: OutputField.OnErrorEnum;
}

/**
 * @export
 * @namespace OutputField
 */
export namespace OutputField {
    /**
     * @export
     * @enum {string}
     */
    export enum OnErrorEnum {
        SKIP = <any> 'SKIP',
        FAIL = <any> 'FAIL'
    }
}

/**
 * 
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * Cursor for the first doc in this query
     * @type {string}
     * @memberof Pagination
     */
    start_cursor?: string;
}

/**
 * 
 * @export
 * @interface PaginationInfo
 */
export interface PaginationInfo {
    /**
     * Number of documents returned in this result set
     * @type {number}
     * @memberof PaginationInfo
     */
    current_page_doc_count?: number;
    /**
     * The doc offset that next_cursor starts at.
     * @type {number}
     * @memberof PaginationInfo
     */
    next_cursor_offset?: number;
    /**
     * Cursor used to retrieve the first set of documents.
     * @type {string}
     * @memberof PaginationInfo
     */
    start_cursor?: string;
    /**
     * Cursor to use to get the list of documents
     * @type {string}
     * @memberof PaginationInfo
     */
    next_cursor?: string;
}

/**
 * 
 * @export
 * @interface ParameterizedHeader
 */
export interface ParameterizedHeader {
    /**
     * 
     * @type {string}
     * @memberof ParameterizedHeader
     */
    value?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ParameterizedHeader
     */
    parameters?: { [key: string]: string; };
}

/**
 * 
 * @export
 * @interface PatchDocument
 */
export interface PatchDocument {
    /**
     * Unique ID of the document to be patched.
     * @type {string}
     * @memberof PatchDocument
     */
    _id: string;
    /**
     * List of patch operations.
     * @type {Array<PatchOperation>}
     * @memberof PatchDocument
     */
    patch: Array<PatchOperation>;
}

/**
 * 
 * @export
 * @interface PatchDocumentsRequest
 */
export interface PatchDocumentsRequest {
    /**
     * List of patches to be applied.
     * @type {Array<PatchDocument>}
     * @memberof PatchDocumentsRequest
     */
    data: Array<PatchDocument>;
}

/**
 * 
 * @export
 * @interface PatchDocumentsResponse
 */
export interface PatchDocumentsResponse {
    /**
     * 
     * @type {Array<DocumentStatus>}
     * @memberof PatchDocumentsResponse
     */
    data: Array<DocumentStatus>;
}

/**
 * 
 * @export
 * @interface PatchOperation
 */
export interface PatchOperation {
    /**
     * [JSON Patch operation](https://datatracker.ietf.org/doc/html/rfc6902#page-4) to be performed in this patch. Case insensitive.
     * @type {string}
     * @memberof PatchOperation
     */
    op: PatchOperation.OpEnum;
    /**
     * [JSON Pointer](https://datatracker.ietf.org/doc/html/rfc6901) referencing a location in the target document where the operation is performed
     * @type {string}
     * @memberof PatchOperation
     */
    path: string;
    /**
     * Value used in the patch operation. Required for `ADD`, `REPLACE`, `TEST`, and `INCREMENT` operations.
     * @type {any}
     * @memberof PatchOperation
     */
    value?: any;
    /**
     * [JSON Pointer](https://datatracker.ietf.org/doc/html/rfc6901) referencing a location in the target document. Required for `COPY` and `MOVE` operations.
     * @type {string}
     * @memberof PatchOperation
     */
    from?: string;
}

/**
 * @export
 * @namespace PatchOperation
 */
export namespace PatchOperation {
    /**
     * @export
     * @enum {string}
     */
    export enum OpEnum {
        ADD = <any> 'ADD',
        REPLACE = <any> 'REPLACE',
        REMOVE = <any> 'REMOVE',
        COPY = <any> 'COPY',
        MOVE = <any> 'MOVE',
        TEST = <any> 'TEST',
        INCREMENT = <any> 'INCREMENT'
    }
}

/**
 * 
 * @export
 * @interface PreviewCollectionRequest
 */
export interface PreviewCollectionRequest {
    /**
     * list of sources from which to ingest data
     * @type {Array<Source>}
     * @memberof PreviewCollectionRequest
     */
    sources?: Array<Source>;
    /**
     * configuration for event data
     * @type {EventTimeInfo}
     * @memberof PreviewCollectionRequest
     */
    event_time_info?: EventTimeInfo;
    /**
     * list of mappings
     * @type {Array<FieldMappingV2>}
     * @memberof PreviewCollectionRequest
     */
    field_mappings?: Array<FieldMappingV2>;
}

/**
 * 
 * @export
 * @interface PreviewCollectionResponse
 */
export interface PreviewCollectionResponse {
    /**
     * sample documents
     * @type {Array<Array<any>>}
     * @memberof PreviewCollectionResponse
     */
    sample_documents?: Array<Array<any>>;
    /**
     * mapped_fields
     * @type {Array<string>}
     * @memberof PreviewCollectionResponse
     */
    mapped_fields?: Array<string>;
}

/**
 * 
 * @export
 * @interface PreviewSource
 */
export interface PreviewSource {
    /**
     * UUID unique to the source
     * @type {string}
     * @memberof PreviewSource
     */
    preview_source_id?: string;
    /**
     * integration used for this source
     * @type {string}
     * @memberof PreviewSource
     */
    integration_name?: string;
    /**
     * whether type is file upload
     * @type {boolean}
     * @memberof PreviewSource
     */
    file_upload?: boolean;
    /**
     * configuration for receiving data from kafka
     * @type {SourceKafka}
     * @memberof PreviewSource
     */
    kafka?: SourceKafka;
    /**
     * time at which this preview source expires (ISO-8601 format)
     * @type {string}
     * @memberof PreviewSource
     */
    expire_at?: string;
}

/**
 * 
 * @export
 * @interface Privilege
 */
export interface Privilege {
    /**
     * The action allowed by this privilege.
     * @type {string}
     * @memberof Privilege
     */
    action?: Privilege.ActionEnum;
    /**
     * The resources on which the action is allowed. Defaults to '*All*' if not specified.
     * @type {string}
     * @memberof Privilege
     */
    resource_name?: string;
    /**
     * Cluster ID (`rs2` for us-west-2, `use1a1` for us-east-1) for which the action is allowed. Defaults to '*All*' if not specified.
     * @type {string}
     * @memberof Privilege
     */
    cluster?: string;
    /**
     * The Virtual Instances on which the action is allowed. Defaults to '*All*' if not specified.
     * @type {string}
     * @memberof Privilege
     */
    virtual_instance?: string;
}

/**
 * @export
 * @namespace Privilege
 */
export namespace Privilege {
    /**
     * @export
     * @enum {string}
     */
    export enum ActionEnum {
        ALLGLOBALACTIONS = <any> 'ALL_GLOBAL_ACTIONS',
        GETORGGLOBAL = <any> 'GET_ORG_GLOBAL',
        GETCURRENTUSERGLOBAL = <any> 'GET_CURRENT_USER_GLOBAL',
        INVITEUSERGLOBAL = <any> 'INVITE_USER_GLOBAL',
        DELETEUSERGLOBAL = <any> 'DELETE_USER_GLOBAL',
        LISTUSERSGLOBAL = <any> 'LIST_USERS_GLOBAL',
        GETBILLINGGLOBAL = <any> 'GET_BILLING_GLOBAL',
        UPDATEBILLINGGLOBAL = <any> 'UPDATE_BILLING_GLOBAL',
        UPDATESETTINGSGLOBAL = <any> 'UPDATE_SETTINGS_GLOBAL',
        GETMETRICSGLOBAL = <any> 'GET_METRICS_GLOBAL',
        UPDATEVIGLOBAL = <any> 'UPDATE_VI_GLOBAL',
        LISTVIGLOBAL = <any> 'LIST_VI_GLOBAL',
        CREATEWSGLOBAL = <any> 'CREATE_WS_GLOBAL',
        LISTWSGLOBAL = <any> 'LIST_WS_GLOBAL',
        CREATEINTEGRATIONGLOBAL = <any> 'CREATE_INTEGRATION_GLOBAL',
        DELETEINTEGRATIONGLOBAL = <any> 'DELETE_INTEGRATION_GLOBAL',
        LISTINTEGRATIONSGLOBAL = <any> 'LIST_INTEGRATIONS_GLOBAL',
        UPDATERESOURCEOWNERGLOBAL = <any> 'UPDATE_RESOURCE_OWNER_GLOBAL',
        CREATEAPIKEYGLOBAL = <any> 'CREATE_API_KEY_GLOBAL',
        CREATEROLEGLOBAL = <any> 'CREATE_ROLE_GLOBAL',
        UPDATEROLEGLOBAL = <any> 'UPDATE_ROLE_GLOBAL',
        DELETEROLEGLOBAL = <any> 'DELETE_ROLE_GLOBAL',
        LISTROLESGLOBAL = <any> 'LIST_ROLES_GLOBAL',
        GRANTREVOKEROLEGLOBAL = <any> 'GRANT_REVOKE_ROLE_GLOBAL',
        ALLINTEGRATIONACTIONS = <any> 'ALL_INTEGRATION_ACTIONS',
        CREATECOLLECTIONINTEGRATION = <any> 'CREATE_COLLECTION_INTEGRATION',
        ALLWORKSPACEACTIONS = <any> 'ALL_WORKSPACE_ACTIONS',
        DELETEWS = <any> 'DELETE_WS',
        QUERYDATAWS = <any> 'QUERY_DATA_WS',
        WRITEDATAWS = <any> 'WRITE_DATA_WS',
        CREATECOLLECTIONWS = <any> 'CREATE_COLLECTION_WS',
        DELETECOLLECTIONWS = <any> 'DELETE_COLLECTION_WS',
        CREATEALIASWS = <any> 'CREATE_ALIAS_WS',
        DELETEALIASWS = <any> 'DELETE_ALIAS_WS',
        LISTRESOURCESWS = <any> 'LIST_RESOURCES_WS',
        CREATEQUERYLAMBDAWS = <any> 'CREATE_QUERY_LAMBDA_WS',
        DELETEQUERYLAMBDAWS = <any> 'DELETE_QUERY_LAMBDA_WS',
        EXECUTEQUERYLAMBDAWS = <any> 'EXECUTE_QUERY_LAMBDA_WS',
        CREATEVIEWWS = <any> 'CREATE_VIEW_WS',
        DELETEVIEWWS = <any> 'DELETE_VIEW_WS'
    }
}

/**
 * 
 * @export
 * @interface Providers
 */
export interface Providers {
}

/**
 * 
 * @export
 * @interface QueryError
 */
export interface QueryError {
    /**
     * The type of error
     * @type {string}
     * @memberof QueryError
     */
    type?: string;
    /**
     * A message associated with the error, containing more information about it
     * @type {string}
     * @memberof QueryError
     */
    message?: string;
    /**
     * The HTTP status code associated with this error, had it been sent as the response status code
     * @type {number}
     * @memberof QueryError
     */
    status_code?: number;
}

/**
 * 
 * @export
 * @interface QueryFieldType
 */
export interface QueryFieldType {
    /**
     * name of the field
     * @type {string}
     * @memberof QueryFieldType
     */
    name: string;
    /**
     * data type of the field
     * @type {string}
     * @memberof QueryFieldType
     */
    type: string;
}

/**
 * 
 * @export
 * @interface QueryLambda
 */
export interface QueryLambda {
    /**
     * workspace of this Query Lambda
     * @type {string}
     * @memberof QueryLambda
     */
    workspace?: string;
    /**
     * user that created this Query Lambda
     * @type {string}
     * @memberof QueryLambda
     */
    last_updated_by?: string;
    /**
     * ISO-8601 date of when Query Lambda was last updated
     * @type {string}
     * @memberof QueryLambda
     */
    last_updated?: string;
    /**
     * Query Lambda name
     * @type {string}
     * @memberof QueryLambda
     */
    name?: string;
    /**
     * number of Query Lambda versions
     * @type {number}
     * @memberof QueryLambda
     */
    version_count?: number;
    /**
     * collections/aliases queried by underlying SQL query
     * @type {Array<string>}
     * @memberof QueryLambda
     */
    collections?: Array<string>;
    /**
     * Query Lambda version details for most recently created version
     * @type {QueryLambdaVersion}
     * @memberof QueryLambda
     */
    latest_version?: QueryLambdaVersion;
}

/**
 * 
 * @export
 * @interface QueryLambdaMetric
 */
export interface QueryLambdaMetric {
    /**
     * 
     * @type {string}
     * @memberof QueryLambdaMetric
     */
    query_lambda_name?: string;
    /**
     * 
     * @type {number}
     * @memberof QueryLambdaMetric
     */
    avg_latency?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryLambdaMetric
     */
    avg_throttled_latency?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryLambdaMetric
     */
    query_count?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryLambdaMetric
     */
    err_count?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryLambdaMetric
     */
    err_count_5xx?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryLambdaMetric
     */
    err_count_4xx?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryLambdaMetric
     */
    time?: number;
}

/**
 * 
 * @export
 * @interface QueryLambdaSql
 */
export interface QueryLambdaSql {
    /**
     * SQL text
     * @type {string}
     * @memberof QueryLambdaSql
     */
    query: string;
    /**
     * default parameters for this Query Lambda
     * @type {Array<QueryParameter>}
     * @memberof QueryLambdaSql
     */
    default_parameters?: Array<QueryParameter>;
}

/**
 * 
 * @export
 * @interface QueryLambdaStats
 */
export interface QueryLambdaStats {
    /**
     * ISO-8601 date
     * @type {string}
     * @memberof QueryLambdaStats
     */
    last_executed?: string;
    /**
     * user who last executed Query Lambda
     * @type {string}
     * @memberof QueryLambdaStats
     */
    last_executed_by?: string;
    /**
     * ISO-8601 date of last execution failure
     * @type {string}
     * @memberof QueryLambdaStats
     */
    last_execution_error?: string;
    /**
     * error message associated with last failed execution
     * @type {string}
     * @memberof QueryLambdaStats
     */
    last_execution_error_message?: string;
}

/**
 * 
 * @export
 * @interface QueryLambdaTag
 */
export interface QueryLambdaTag {
    /**
     * name of Query Lambda tag
     * @type {string}
     * @memberof QueryLambdaTag
     */
    tag_name?: string;
    /**
     * query lambda version
     * @type {QueryLambdaVersion}
     * @memberof QueryLambdaTag
     */
    version?: QueryLambdaVersion;
}

/**
 * 
 * @export
 * @interface QueryLambdaTagResponse
 */
export interface QueryLambdaTagResponse {
    /**
     * updated Query Lambda tag
     * @type {QueryLambdaTag}
     * @memberof QueryLambdaTagResponse
     */
    data?: QueryLambdaTag;
}

/**
 * 
 * @export
 * @interface QueryLambdaVersion
 */
export interface QueryLambdaVersion {
    /**
     * workspace of this Query Lambda
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    workspace?: string;
    /**
     * user that created this Query Lambda
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    created_by?: string;
    /**
     * ISO-8601 date of when Query Lambda was created
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    created_at?: string;
    /**
     * Query Lambda name
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    name?: string;
    /**
     * Query Lambda version
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    version?: string;
    /**
     * optional description
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    description?: string;
    /**
     * Query Lambda SQL query
     * @type {QueryLambdaSql}
     * @memberof QueryLambdaVersion
     */
    sql?: QueryLambdaSql;
    /**
     * collections queried by underlying SQL query
     * @type {Array<string>}
     * @memberof QueryLambdaVersion
     */
    collections?: Array<string>;
    /**
     * status of this Query Lambda
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    state?: QueryLambdaVersion.StateEnum;
    /**
     * stats related to this Query Lambda
     * @type {QueryLambdaStats}
     * @memberof QueryLambdaVersion
     */
    stats?: QueryLambdaStats;
}

/**
 * @export
 * @namespace QueryLambdaVersion
 */
export namespace QueryLambdaVersion {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        ACTIVE = <any> 'ACTIVE',
        INVALIDSQL = <any> 'INVALID_SQL'
    }
}

/**
 * 
 * @export
 * @interface QueryLambdaVersionResponse
 */
export interface QueryLambdaVersionResponse {
    /**
     * Query Lambda version details
     * @type {QueryLambdaVersion}
     * @memberof QueryLambdaVersionResponse
     */
    data?: QueryLambdaVersion;
}

/**
 * 
 * @export
 * @interface QueryPageInfo
 */
export interface QueryPageInfo {
    /**
     * Query ID
     * @type {string}
     * @memberof QueryPageInfo
     */
    query_id?: string;
    /**
     * Either RUNNING or FINISHED.
     * @type {string}
     * @memberof QueryPageInfo
     */
    state?: QueryPageInfo.StateEnum;
    /**
     * User who ran the query
     * @type {string}
     * @memberof QueryPageInfo
     */
    run_by?: string;
    /**
     * Time the query results expire
     * @type {string}
     * @memberof QueryPageInfo
     */
    expires_at?: string;
    /**
     * Time the query was run
     * @type {string}
     * @memberof QueryPageInfo
     */
    run_at?: string;
    /**
     * 
     * @type {Stats}
     * @memberof QueryPageInfo
     */
    stats?: Stats;
    /**
     * 
     * @type {Pagination}
     * @memberof QueryPageInfo
     */
    pagination?: Pagination;
}

/**
 * @export
 * @namespace QueryPageInfo
 */
export namespace QueryPageInfo {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        RUNNING = <any> 'RUNNING',
        FINISHED = <any> 'FINISHED'
    }
}

/**
 * 
 * @export
 * @interface QueryPaginationResponse
 */
export interface QueryPaginationResponse {
    /**
     * List of documents returned by the query
     * @type {Array<any>}
     * @memberof QueryPaginationResponse
     */
    results?: Array<any>;
    /**
     * Total documents returned by the query
     * @type {number}
     * @memberof QueryPaginationResponse
     */
    results_total_doc_count?: number;
    /**
     * Pagination metadata
     * @type {PaginationInfo}
     * @memberof QueryPaginationResponse
     */
    pagination?: PaginationInfo;
}

/**
 * 
 * @export
 * @interface QueryParameter
 */
export interface QueryParameter {
    /**
     * name of the field
     * @type {string}
     * @memberof QueryParameter
     */
    name: string;
    /**
     * data type of the field
     * @type {string}
     * @memberof QueryParameter
     */
    type: string;
    /**
     * literal value of the field
     * @type {string}
     * @memberof QueryParameter
     */
    value: string;
}

/**
 * 
 * @export
 * @interface QueryRequest
 */
export interface QueryRequest {
    /**
     * Main query request body.
     * @type {QueryRequestSql}
     * @memberof QueryRequest
     */
    sql: QueryRequestSql;
}

/**
 * 
 * @export
 * @interface QueryRequestSql
 */
export interface QueryRequestSql {
    /**
     * SQL query string.
     * @type {string}
     * @memberof QueryRequestSql
     */
    query: string;
    /**
     * Flag to enable warnings. Warnings can help debug query issues but negatively affect performance.
     * @type {boolean}
     * @memberof QueryRequestSql
     */
    generate_warnings?: boolean;
    /**
     * Flag to generate a performance profile for this query.
     * @type {boolean}
     * @memberof QueryRequestSql
     */
    profiling_enabled?: boolean;
    /**
     * List of named parameters.
     * @type {Array<QueryParameter>}
     * @memberof QueryRequestSql
     */
    parameters?: Array<QueryParameter>;
    /**
     * Row limit to use. Limits specified in the query text will override this default.
     * @type {number}
     * @memberof QueryRequestSql
     */
    default_row_limit?: number;
    /**
     * Flag to paginate and store the results of this query for later / sequential retrieval.
     * @type {boolean}
     * @memberof QueryRequestSql
     */
    paginate?: boolean;
    /**
     * Number of documents to return in addition to paginating for this query call. Only relevant if `paginate` flag is also set.
     * @type {number}
     * @memberof QueryRequestSql
     */
    initial_paginate_response_doc_count?: number;
    /**
     * If this query is being used for ingest transformations we add fixes to make it closer to what the rollup would actually do
     * @type {boolean}
     * @memberof QueryRequestSql
     */
    is_ingest_transformation_preview?: boolean;
}

/**
 * 
 * @export
 * @interface QueryResponse
 */
export interface QueryResponse {
    /**
     * List of aliases referenced in the query.
     * @type {Array<QueryResponseAlias>}
     * @memberof QueryResponse
     */
    aliases?: Array<QueryResponseAlias>;
    /**
     * Unique ID for this query.
     * @type {string}
     * @memberof QueryResponse
     */
    query_id?: string;
    /**
     * List of collections referenced in the query.
     * @type {Array<string>}
     * @memberof QueryResponse
     */
    collections?: Array<string>;
    /**
     * Results from the query.
     * @type {Array<any>}
     * @memberof QueryResponse
     */
    results?: Array<any>;
    /**
     * Meta information about the query including execution latencies.
     * @type {QueryResponseStats}
     * @memberof QueryResponse
     */
    stats?: QueryResponseStats;
    /**
     * Warnings generated by the query. Only populated if `generate_warnings` is specified in the query request.
     * @type {Array<string>}
     * @memberof QueryResponse
     */
    warnings?: Array<string>;
    /**
     * Errors encountered while executing the query.
     * @type {Array<QueryError>}
     * @memberof QueryResponse
     */
    query_errors?: Array<QueryError>;
    /**
     * Meta information about each column in the result set. Not populated in `SELECT *` queries.
     * @type {Array<QueryFieldType>}
     * @memberof QueryResponse
     */
    column_fields?: Array<QueryFieldType>;
    /**
     * Number of results generated by the query
     * @type {number}
     * @memberof QueryResponse
     */
    results_total_doc_count?: number;
    /**
     * Pagination information. Only populated if `paginate` is specified in the query request.
     * @type {PaginationInfo}
     * @memberof QueryResponse
     */
    pagination?: PaginationInfo;
    /**
     * If this was a write query, this is the log offset the query was written to
     * @type {string}
     * @memberof QueryResponse
     */
    last_offset?: string;
}

/**
 * 
 * @export
 * @interface QueryResponseAlias
 */
export interface QueryResponseAlias {
    /**
     * name of the alias
     * @type {string}
     * @memberof QueryResponseAlias
     */
    name: string;
    /**
     * list of fully qualified collection names referenced by the alias
     * @type {Array<string>}
     * @memberof QueryResponseAlias
     */
    collections: Array<string>;
}

/**
 * 
 * @export
 * @interface QueryResponseStats
 */
export interface QueryResponseStats {
    /**
     * query time in milliseconds
     * @type {number}
     * @memberof QueryResponseStats
     */
    elapsed_time_ms?: number;
    /**
     * time query was throttled by admission control
     * @type {number}
     * @memberof QueryResponseStats
     */
    throttled_time_micros?: number;
}

/**
 * 
 * @export
 * @interface QueryStats
 */
export interface QueryStats {
    /**
     * query time in milliseconds
     * @type {number}
     * @memberof QueryStats
     */
    elapsed_time_ms?: number;
    /**
     * rows scanned as part of query execution
     * @type {number}
     * @memberof QueryStats
     */
    rows_scanned?: number;
    /**
     * number of rows returned from the query
     * @type {number}
     * @memberof QueryStats
     */
    rows_returned?: number;
    /**
     * Statistics for each operator from query execution
     * @type {Array<OperatorStats>}
     * @memberof QueryStats
     */
    operators?: Array<OperatorStats>;
    /**
     * Statistics for each exchange source from query execution
     * @type {Array<RpcSourceStats>}
     * @memberof QueryStats
     */
    exchange_sources?: Array<RpcSourceStats>;
    /**
     * Statistics for each exchange sink from query execution
     * @type {Array<RpcSinkStats>}
     * @memberof QueryStats
     */
    exchange_sinks?: Array<RpcSinkStats>;
    /**
     * DOT graph representing the execution steps of this query
     * @type {string}
     * @memberof QueryStats
     */
    execution_graph?: string;
    /**
     * Execution plan (output of EXPLAIN) of this query
     * @type {string}
     * @memberof QueryStats
     */
    execution_plan?: string;
    /**
     * Information about each physical operator, like what fields it is fetching
     * @type {string}
     * @memberof QueryStats
     */
    operator_metadata?: string;
    /**
     * SQL text of Query that was executed
     * @type {string}
     * @memberof QueryStats
     */
    query_text?: string;
}

/**
 * 
 * @export
 * @interface QueryStatsResponse
 */
export interface QueryStatsResponse {
    /**
     * 
     * @type {QueryStats}
     * @memberof QueryStatsResponse
     */
    data?: QueryStats;
}

/**
 * 
 * @export
 * @interface RateCard
 */
export interface RateCard {
    /**
     * 
     * @type {boolean}
     * @memberof RateCard
     */
    active?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RateCard
     */
    small?: number;
    /**
     * 
     * @type {number}
     * @memberof RateCard
     */
    medium?: number;
    /**
     * 
     * @type {number}
     * @memberof RateCard
     */
    large?: number;
    /**
     * 
     * @type {number}
     * @memberof RateCard
     */
    xlarge?: number;
    /**
     * 
     * @type {number}
     * @memberof RateCard
     */
    xlarge2?: number;
    /**
     * 
     * @type {number}
     * @memberof RateCard
     */
    xlarge4?: number;
    /**
     * 
     * @type {number}
     * @memberof RateCard
     */
    xlarge8?: number;
    /**
     * 
     * @type {number}
     * @memberof RateCard
     */
    xlarge16?: number;
}

/**
 * 
 * @export
 * @interface RateCardResponse
 */
export interface RateCardResponse {
    /**
     * 
     * @type {RateCard}
     * @memberof RateCardResponse
     */
    data?: RateCard;
}

/**
 * 
 * @export
 * @interface RecordActivityRequest
 */
export interface RecordActivityRequest {
    /**
     * should this activity trigger a notification message
     * @type {boolean}
     * @memberof RecordActivityRequest
     */
    notify?: boolean;
    /**
     * message to be sent
     * @type {string}
     * @memberof RecordActivityRequest
     */
    message?: string;
    /**
     * details of the activity
     * @type {{ [key: string]: any; }}
     * @memberof RecordActivityRequest
     */
    details?: { [key: string]: any; };
}

/**
 * 
 * @export
 * @interface RedshiftIntegration
 */
export interface RedshiftIntegration {
    /**
     * AWS access key credentials
     * @type {AwsAccessKey}
     * @memberof RedshiftIntegration
     */
    aws_access_key?: AwsAccessKey;
    /**
     * Username associated with Redshift cluster
     * @type {string}
     * @memberof RedshiftIntegration
     */
    username: string;
    /**
     * Password associated with Redshift cluster
     * @type {string}
     * @memberof RedshiftIntegration
     */
    password: string;
    /**
     * Redshift Cluster host
     * @type {string}
     * @memberof RedshiftIntegration
     */
    host: string;
    /**
     * Redshift Cluster port
     * @type {number}
     * @memberof RedshiftIntegration
     */
    port: number;
    /**
     * unload S3 bucket path
     * @type {string}
     * @memberof RedshiftIntegration
     */
    s3_bucket_path: string;
}

/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * Unique identifier for the role.
     * @type {string}
     * @memberof Role
     */
    role_name?: string;
    /**
     * Description for the role.
     * @type {string}
     * @memberof Role
     */
    description?: string;
    /**
     * Email of the user who currently owns the role.
     * @type {string}
     * @memberof Role
     */
    owner_email?: string;
    /**
     * Email of the user who created the role.
     * @type {string}
     * @memberof Role
     */
    created_by?: string;
    /**
     * List of privileges associated with the role.
     * @type {Array<Privilege>}
     * @memberof Role
     */
    privileges?: Array<Privilege>;
    /**
     * ISO-8601 date of when the role was created.
     * @type {string}
     * @memberof Role
     */
    created_at?: string;
}

/**
 * 
 * @export
 * @interface RoleResponse
 */
export interface RoleResponse {
    /**
     * 
     * @type {Role}
     * @memberof RoleResponse
     */
    data?: Role;
}

/**
 * 
 * @export
 * @interface RpcSinkStats
 */
export interface RpcSinkStats {
    /**
     * The id of the worker this operator ran on
     * @type {string}
     * @memberof RpcSinkStats
     */
    worker?: string;
    /**
     * The id of the fragment this operator belonged to
     * @type {number}
     * @memberof RpcSinkStats
     */
    fragment?: number;
    /**
     * The id of the task this operator belonged to
     * @type {string}
     * @memberof RpcSinkStats
     */
    task?: string;
    /**
     * The id of this operator in the task
     * @type {number}
     * @memberof RpcSinkStats
     */
    operator_id?: number;
    /**
     * The class name of upstream operator
     * @type {string}
     * @memberof RpcSinkStats
     */
    src_operator_name?: string;
    /**
     * Total bytes received from the input
     * @type {number}
     * @memberof RpcSinkStats
     */
    input_bytes?: number;
    /**
     * Maximum bytes received in one data chunk
     * @type {number}
     * @memberof RpcSinkStats
     */
    max_input_bytes?: number;
    /**
     * Total rows received from the input
     * @type {number}
     * @memberof RpcSinkStats
     */
    input_rows?: number;
    /**
     * Total data chunks received from the input
     * @type {number}
     * @memberof RpcSinkStats
     */
    input_data_chunks?: number;
    /**
     * Total data chunks sent to the output
     * @type {number}
     * @memberof RpcSinkStats
     */
    output_data_chunks?: number;
    /**
     * Total messages sent to the output
     * @type {number}
     * @memberof RpcSinkStats
     */
    output_messages?: number;
    /**
     * Total time in microseconds spent doing useful work
     * @type {number}
     * @memberof RpcSinkStats
     */
    processing_time_us?: number;
}

/**
 * 
 * @export
 * @interface RpcSourceStats
 */
export interface RpcSourceStats {
    /**
     * The id of the worker this operator ran on
     * @type {string}
     * @memberof RpcSourceStats
     */
    worker?: string;
    /**
     * The id of the fragment this operator belonged to
     * @type {number}
     * @memberof RpcSourceStats
     */
    fragment?: number;
    /**
     * The id of the task this operator belonged to
     * @type {string}
     * @memberof RpcSourceStats
     */
    task?: string;
    /**
     * The id of this operator in the task
     * @type {number}
     * @memberof RpcSourceStats
     */
    operator_id?: number;
    /**
     * The class name of downstream operator
     * @type {string}
     * @memberof RpcSourceStats
     */
    dest_operator_name?: string;
    /**
     * Total bytes received from the input
     * @type {number}
     * @memberof RpcSourceStats
     */
    input_bytes?: number;
    /**
     * Maximum bytes received in one data chunk
     * @type {number}
     * @memberof RpcSourceStats
     */
    max_input_bytes?: number;
    /**
     * Total rows received from the input
     * @type {number}
     * @memberof RpcSourceStats
     */
    input_rows?: number;
    /**
     * Total data chunks received from the input
     * @type {number}
     * @memberof RpcSourceStats
     */
    input_data_chunks?: number;
    /**
     * Total messages received from the input
     * @type {number}
     * @memberof RpcSourceStats
     */
    input_messages?: number;
    /**
     * Total time in microseconds spent doing useful work
     * @type {number}
     * @memberof RpcSourceStats
     */
    processing_time_us?: number;
}

/**
 * 
 * @export
 * @interface S3Integration
 */
export interface S3Integration {
    /**
     * credentials for an AWS access key integration
     * @type {AwsAccessKey}
     * @memberof S3Integration
     */
    aws_access_key?: AwsAccessKey;
    /**
     * details of an AWS cross-account role integration
     * @type {AwsRole}
     * @memberof S3Integration
     */
    aws_role?: AwsRole;
}

/**
 * 
 * @export
 * @interface SegmentIntegration
 */
export interface SegmentIntegration {
    /**
     * segment connection string
     * @type {string}
     * @memberof SegmentIntegration
     */
    connection_string?: string;
}

/**
 * 
 * @export
 * @interface SlowQuery
 */
export interface SlowQuery {
    /**
     * 
     * @type {string}
     * @memberof SlowQuery
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof SlowQuery
     */
    query_lambda_name?: string;
    /**
     * 
     * @type {number}
     * @memberof SlowQuery
     */
    latency_millis?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowQuery
     */
    throttled_latency_micros?: number;
    /**
     * 
     * @type {string}
     * @memberof SlowQuery
     */
    agent?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SlowQuery
     */
    collections?: Array<string>;
    /**
     * 
     * @type {Array<QueryResponseAlias>}
     * @memberof SlowQuery
     */
    aliases?: Array<QueryResponseAlias>;
    /**
     * 
     * @type {string}
     * @memberof SlowQuery
     */
    query?: string;
    /**
     * 
     * @type {string}
     * @memberof SlowQuery
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof SlowQuery
     */
    time?: number;
}

/**
 * 
 * @export
 * @interface SlowQueryCount
 */
export interface SlowQueryCount {
    /**
     * 
     * @type {number}
     * @memberof SlowQueryCount
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof SlowQueryCount
     */
    time?: number;
}

/**
 * Details about the data source for the given collection. Only one of the following fields are allowed to be defined. Only collections can act as data sources for views. 
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * name of integration to use
     * @type {string}
     * @memberof Source
     */
    integration_name: string;
    /**
     * configuration for ingestion from S3
     * @type {SourceS3}
     * @memberof Source
     */
    s3?: SourceS3;
    /**
     * configuration for ingestion from kinesis stream
     * @type {SourceKinesis}
     * @memberof Source
     */
    kinesis?: SourceKinesis;
    /**
     * configuration for ingestion from GCS
     * @type {SourceGcs}
     * @memberof Source
     */
    gcs?: SourceGcs;
    /**
     * configuration for ingestion from Redshift
     * @type {SourceRedshift}
     * @memberof Source
     */
    redshift?: SourceRedshift;
    /**
     * configuration for ingestion from  a dynamodb table
     * @type {SourceDynamoDb}
     * @memberof Source
     */
    dynamodb?: SourceDynamoDb;
    /**
     * file upload details
     * @type {SourceFileUpload}
     * @memberof Source
     */
    file_upload?: SourceFileUpload;
    /**
     * kafka collection identifier
     * @type {SourceKafka}
     * @memberof Source
     */
    kafka?: SourceKafka;
    /**
     * MongoDB collection details
     * @type {SourceMongoDb}
     * @memberof Source
     */
    mongodb?: SourceMongoDb;
    /**
     * the ingest status of this source
     * @type {Status}
     * @memberof Source
     */
    status?: Status;
    /**
     * format parameters for data from this source
     * @type {FormatParams}
     * @memberof Source
     */
    format_params?: FormatParams;
}

/**
 * 
 * @export
 * @interface SourceConfig
 */
export interface SourceConfig {
    /**
     * dynamo source information
     * @type {SourceConfigDynamo}
     * @memberof SourceConfig
     */
    dynamo_config?: SourceConfigDynamo;
    /**
     * mongo source information
     * @type {SourceConfigMongo}
     * @memberof SourceConfig
     */
    mongo_config?: SourceConfigMongo;
}

/**
 * 
 * @export
 * @interface SourceConfigDynamo
 */
export interface SourceConfigDynamo {
    /**
     * RCUs configured on source DynamoDb Table
     * @type {number}
     * @memberof SourceConfigDynamo
     */
    rcu?: number;
    /**
     * estimated time in seconds to scan DynamoDb Table
     * @type {number}
     * @memberof SourceConfigDynamo
     */
    estimated_time_seconds?: number;
    /**
     * size of DynamoDb Table in Bytes
     * @type {number}
     * @memberof SourceConfigDynamo
     */
    table_size_bytes?: number;
    /**
     * number of records in DynamoDb Table
     * @type {number}
     * @memberof SourceConfigDynamo
     */
    num_records?: number;
    /**
     * Whether point-in-time-recovery is enabled at the time of collection creation
     * @type {boolean}
     * @memberof SourceConfigDynamo
     */
    is_pitr_enabled?: boolean;
}

/**
 * 
 * @export
 * @interface SourceConfigMongo
 */
export interface SourceConfigMongo {
    /**
     * size of MongoDB Collection in Bytes
     * @type {number}
     * @memberof SourceConfigMongo
     */
    table_size_bytes?: number;
    /**
     * number of documents in MongoDB Collection
     * @type {number}
     * @memberof SourceConfigMongo
     */
    num_records?: number;
}

/**
 * 
 * @export
 * @interface SourceConfigRequest
 */
export interface SourceConfigRequest {
    /**
     * name of integration to use
     * @type {string}
     * @memberof SourceConfigRequest
     */
    integration_name: string;
    /**
     * configuration for ingestion from a DynamoDB table
     * @type {SourceDynamoDb}
     * @memberof SourceConfigRequest
     */
    dynamodb?: SourceDynamoDb;
    /**
     * configuration for ingestion from a MongoDB collection
     * @type {SourceMongoDb}
     * @memberof SourceConfigRequest
     */
    mongodb?: SourceMongoDb;
}

/**
 * 
 * @export
 * @interface SourceConfigResponse
 */
export interface SourceConfigResponse {
    /**
     * source information that was requested
     * @type {SourceConfig}
     * @memberof SourceConfigResponse
     */
    data?: SourceConfig;
}

/**
 * 
 * @export
 * @interface SourceDynamoDb
 */
export interface SourceDynamoDb {
    /**
     * AWS region name of DynamoDB table, by default us-west-2 is used
     * @type {string}
     * @memberof SourceDynamoDb
     */
    aws_region?: string;
    /**
     * name of DynamoDB table containing data
     * @type {string}
     * @memberof SourceDynamoDb
     */
    table_name: string;
    /**
     * DynamoDB source status v2
     * @type {StatusDynamoDbV2}
     * @memberof SourceDynamoDb
     */
    current_status?: StatusDynamoDbV2;
    /**
     * Max RCU usage for scan
     * @type {number}
     * @memberof SourceDynamoDb
     */
    rcu?: number;
    /**
     * DynamoDB source status
     * @type {StatusDynamoDb}
     * @memberof SourceDynamoDb
     */
    status?: StatusDynamoDb;
    /**
     * Whether to use DynamoDB Scan API for the initial scan
     * @type {boolean}
     * @memberof SourceDynamoDb
     */
    use_scan_api?: boolean;
}

/**
 * 
 * @export
 * @interface SourceFileUpload
 */
export interface SourceFileUpload {
    /**
     * name of the file
     * @type {string}
     * @memberof SourceFileUpload
     */
    file_name: string;
    /**
     * size of the file in bytes
     * @type {number}
     * @memberof SourceFileUpload
     */
    file_size: number;
    /**
     * time of file upload
     * @type {string}
     * @memberof SourceFileUpload
     */
    file_upload_time: string;
}

/**
 * 
 * @export
 * @interface SourceGcs
 */
export interface SourceGcs {
    /**
     * name of GCS bucket you want to ingest from
     * @type {string}
     * @memberof SourceGcs
     */
    bucket?: string;
    /**
     * Prefix that selects keys to ingest.
     * @type {string}
     * @memberof SourceGcs
     */
    prefix?: string;
    /**
     * 
     * @type {number}
     * @memberof SourceGcs
     */
    object_count_downloaded?: number;
    /**
     * 
     * @type {number}
     * @memberof SourceGcs
     */
    object_count_total?: number;
    /**
     * 
     * @type {number}
     * @memberof SourceGcs
     */
    object_bytes_total?: number;
}

/**
 * 
 * @export
 * @interface SourceKafka
 */
export interface SourceKafka {
    /**
     * The Kafka topic to be tailed
     * @type {string}
     * @memberof SourceKafka
     */
    kafka_topic_name: string;
    /**
     * Kafka source status
     * @type {StatusKafka}
     * @memberof SourceKafka
     */
    status?: StatusKafka;
    /**
     * Whether to use v3 integration
     * @type {boolean}
     * @memberof SourceKafka
     */
    use_v3?: boolean;
    /**
     * The offset reset policy. Required only for V3 collection.
     * @type {string}
     * @memberof SourceKafka
     */
    offset_reset_policy?: SourceKafka.OffsetResetPolicyEnum;
}

/**
 * @export
 * @namespace SourceKafka
 */
export namespace SourceKafka {
    /**
     * @export
     * @enum {string}
     */
    export enum OffsetResetPolicyEnum {
        LATEST = <any> 'LATEST',
        EARLIEST = <any> 'EARLIEST'
    }
}

/**
 * 
 * @export
 * @interface SourceKinesis
 */
export interface SourceKinesis {
    /**
     * AWS region name of Kinesis stream, by default us-west-2 is used
     * @type {string}
     * @memberof SourceKinesis
     */
    aws_region?: string;
    /**
     * name of kinesis stream
     * @type {string}
     * @memberof SourceKinesis
     */
    stream_name: string;
    /**
     * set of fields that correspond to a DMS primary key
     * @type {Array<string>}
     * @memberof SourceKinesis
     */
    dms_primary_key?: Array<string>;
}

/**
 * 
 * @export
 * @interface SourceMongoDb
 */
export interface SourceMongoDb {
    /**
     * MongoDB database name containing this collection
     * @type {string}
     * @memberof SourceMongoDb
     */
    database_name: string;
    /**
     * MongoDB collection name
     * @type {string}
     * @memberof SourceMongoDb
     */
    collection_name: string;
    /**
     * MongoDB source status
     * @type {StatusMongoDb}
     * @memberof SourceMongoDb
     */
    status?: StatusMongoDb;
}

/**
 * 
 * @export
 * @interface SourceRedshift
 */
export interface SourceRedshift {
    /**
     * name of the database in Redshift Cluster
     * @type {string}
     * @memberof SourceRedshift
     */
    database: string;
    /**
     * schema which contains the Redshift table
     * @type {string}
     * @memberof SourceRedshift
     */
    schema: string;
    /**
     * name of Redshift table containing data
     * @type {string}
     * @memberof SourceRedshift
     */
    table_name: string;
    /**
     * field in Redshift source table to monitor for updates
     * @type {string}
     * @memberof SourceRedshift
     */
    incremental_field?: string;
}

/**
 * 
 * @export
 * @interface SourceS3
 */
export interface SourceS3 {
    /**
     * AWS credential with ListObjects and GetObject access
     * @type {string}
     * @memberof SourceS3
     */
    access_key?: string;
    /**
     * AWS credential with ListObjects and GetObject access
     * @type {string}
     * @memberof SourceS3
     */
    secret_access?: string;
    /**
     * Prefix that selects keys to ingest.
     * @type {string}
     * @memberof SourceS3
     */
    prefix?: string;
    /**
     * Pattern that selects keys to ingest.
     * @type {string}
     * @memberof SourceS3
     */
    pattern?: string;
    /**
     * AWS region containing source bucket
     * @type {string}
     * @memberof SourceS3
     */
    region?: string;
    /**
     * address of S3 bucket containing data
     * @type {string}
     * @memberof SourceS3
     */
    bucket: string;
    /**
     * list of prefixes to paths from which data should be ingested
     * @type {Array<string>}
     * @memberof SourceS3
     */
    prefixes: Array<string>;
    /**
     * do not use
     * @type {string}
     * @memberof SourceS3
     */
    format?: SourceS3.FormatEnum;
    /**
     * custom transformation on data field
     * @type {Array<FieldMask>}
     * @memberof SourceS3
     */
    mappings?: Array<FieldMask>;
    /**
     * 
     * @type {number}
     * @memberof SourceS3
     */
    object_count_downloaded?: number;
    /**
     * 
     * @type {number}
     * @memberof SourceS3
     */
    object_count_total?: number;
    /**
     * 
     * @type {number}
     * @memberof SourceS3
     */
    object_bytes_total?: number;
}

/**
 * @export
 * @namespace SourceS3
 */
export namespace SourceS3 {
    /**
     * @export
     * @enum {string}
     */
    export enum FormatEnum {
        JSON = <any> 'JSON'
    }
}

/**
 * 
 * @export
 * @interface SqlExpression
 */
export interface SqlExpression {
    /**
     * The name of a sql function
     * @type {string}
     * @memberof SqlExpression
     */
    sql?: string;
}

/**
 * 
 * @export
 * @interface Stats
 */
export interface Stats {
    /**
     * Time taken for query to run in milliseconds.
     * @type {number}
     * @memberof Stats
     */
    elapsed_time_ms?: number;
    /**
     * Throttled time for query to run in milliseconds.
     * @type {number}
     * @memberof Stats
     */
    throttled_time_ms?: number;
    /**
     * Number of docs returned by this query.
     * @type {number}
     * @memberof Stats
     */
    doc_count?: number;
    /**
     * Number of bytes in the query result set.
     * @type {number}
     * @memberof Stats
     */
    size_bytes?: number;
}

/**
 * 
 * @export
 * @interface Status
 */
export interface Status {
    /**
     * Status of the Source's ingestion, one of: INITIALIZING, WATCHING, PROCESSING, COMPLETED, ERROR
     * @type {string}
     * @memberof Status
     */
    state?: Status.StateEnum;
    /**
     * state message
     * @type {string}
     * @memberof Status
     */
    message?: string;
    /**
     * ISO-8601 date when source was last processed
     * @type {string}
     * @memberof Status
     */
    last_processed_at?: string;
    /**
     * last source item processed by ingester
     * @type {string}
     * @memberof Status
     */
    last_processed_item?: string;
    /**
     * Total items processed of source
     * @type {number}
     * @memberof Status
     */
    total_processed_items?: number;
}

/**
 * @export
 * @namespace Status
 */
export namespace Status {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        INITIALIZING = <any> 'INITIALIZING',
        WATCHING = <any> 'WATCHING',
        PROCESSING = <any> 'PROCESSING',
        COMPLETED = <any> 'COMPLETED',
        ERROR = <any> 'ERROR'
    }
}

/**
 * 
 * @export
 * @interface StatusDynamoDb
 */
export interface StatusDynamoDb {
    /**
     * DynamoDB scan start time
     * @type {string}
     * @memberof StatusDynamoDb
     */
    scan_start_time?: string;
    /**
     * DynamoDb scan end time
     * @type {string}
     * @memberof StatusDynamoDb
     */
    scan_end_time?: string;
    /**
     * Number of records inserted using scan
     * @type {number}
     * @memberof StatusDynamoDb
     */
    scan_records_processed?: number;
    /**
     * Number of records in DynamoDB table at time of scan
     * @type {number}
     * @memberof StatusDynamoDb
     */
    scan_total_records?: number;
    /**
     * state of current ingest for this table
     * @type {string}
     * @memberof StatusDynamoDb
     */
    state?: StatusDynamoDb.StateEnum;
    /**
     * ISO-8601 date when source was last processed
     * @type {string}
     * @memberof StatusDynamoDb
     */
    stream_last_processed_at?: string;
}

/**
 * @export
 * @namespace StatusDynamoDb
 */
export namespace StatusDynamoDb {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        INITIALIZING = <any> 'INITIALIZING',
        SCANNINGTABLE = <any> 'SCANNING_TABLE',
        PROCESSINGSTREAM = <any> 'PROCESSING_STREAM'
    }
}

/**
 * 
 * @export
 * @interface StatusDynamoDbV2
 */
export interface StatusDynamoDbV2 {
    /**
     * 
     * @type {number}
     * @memberof StatusDynamoDbV2
     */
    initial_dump_completion_percentage?: number;
    /**
     * state of current ingest for this table
     * @type {string}
     * @memberof StatusDynamoDbV2
     */
    state?: StatusDynamoDbV2.StateEnum;
    /**
     * ISO-8601 date when source was last processed
     * @type {string}
     * @memberof StatusDynamoDbV2
     */
    stream_last_processed_at?: string;
}

/**
 * @export
 * @namespace StatusDynamoDbV2
 */
export namespace StatusDynamoDbV2 {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        INITIALIZING = <any> 'INITIALIZING',
        SCANNING = <any> 'SCANNING',
        EXPORTINGTOS3 = <any> 'EXPORTING_TO_S3',
        DOWNLOADINGFROMS3 = <any> 'DOWNLOADING_FROM_S3',
        PROCESSINGSTREAM = <any> 'PROCESSING_STREAM'
    }
}

/**
 * 
 * @export
 * @interface StatusKafka
 */
export interface StatusKafka {
    /**
     * State of the Kafka source
     * @type {string}
     * @memberof StatusKafka
     */
    state?: StatusKafka.StateEnum;
    /**
     * Time at which the last document was consumed from Kafka
     * @type {string}
     * @memberof StatusKafka
     */
    last_consumed_time?: string;
    /**
     * Number of documents consumed by this Kafka topic
     * @type {number}
     * @memberof StatusKafka
     */
    num_documents_processed?: number;
    /**
     * Status info per partition
     * @type {Array<StatusKafkaPartition>}
     * @memberof StatusKafka
     */
    kafka_partitions?: Array<StatusKafkaPartition>;
}

/**
 * @export
 * @namespace StatusKafka
 */
export namespace StatusKafka {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        NODOCSYET = <any> 'NO_DOCS_YET',
        ACTIVE = <any> 'ACTIVE',
        DORMANT = <any> 'DORMANT'
    }
}

/**
 * 
 * @export
 * @interface StatusKafkaPartition
 */
export interface StatusKafkaPartition {
    /**
     * The number of this partition
     * @type {number}
     * @memberof StatusKafkaPartition
     */
    partition_number?: number;
    /**
     * Latest offset of partition
     * @type {number}
     * @memberof StatusKafkaPartition
     */
    partition_offset?: number;
}

/**
 * 
 * @export
 * @interface StatusMongoDb
 */
export interface StatusMongoDb {
    /**
     * MongoDB scan start time
     * @type {string}
     * @memberof StatusMongoDb
     */
    scan_start_time?: string;
    /**
     * MongoDB scan end time
     * @type {string}
     * @memberof StatusMongoDb
     */
    scan_end_time?: string;
    /**
     * Number of records inserted using scan
     * @type {number}
     * @memberof StatusMongoDb
     */
    scan_records_processed?: number;
    /**
     * Number of records in MongoDB table at time of scan
     * @type {number}
     * @memberof StatusMongoDb
     */
    scan_total_records?: number;
    /**
     * state of current ingest for this table
     * @type {string}
     * @memberof StatusMongoDb
     */
    state?: StatusMongoDb.StateEnum;
    /**
     * ISO-8601 date when new insert from source was last processed
     * @type {string}
     * @memberof StatusMongoDb
     */
    stream_last_insert_processed_at?: string;
    /**
     * ISO-8601 date when update from source was last processed
     * @type {string}
     * @memberof StatusMongoDb
     */
    stream_last_update_processed_at?: string;
    /**
     * ISO-8601 date when delete from source was last processed
     * @type {string}
     * @memberof StatusMongoDb
     */
    stream_last_delete_processed_at?: string;
    /**
     * Number of new records inserted using stream
     * @type {number}
     * @memberof StatusMongoDb
     */
    stream_records_inserted?: number;
    /**
     * Number of new records updated using stream
     * @type {number}
     * @memberof StatusMongoDb
     */
    stream_records_updated?: number;
    /**
     * Number of new records deleted using stream
     * @type {number}
     * @memberof StatusMongoDb
     */
    stream_records_deleted?: number;
}

/**
 * @export
 * @namespace StatusMongoDb
 */
export namespace StatusMongoDb {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        INITIALIZING = <any> 'INITIALIZING',
        SCANNINGTABLE = <any> 'SCANNING_TABLE',
        PROCESSINGSTREAM = <any> 'PROCESSING_STREAM'
    }
}

/**
 * 
 * @export
 * @interface StatusResponse
 */
export interface StatusResponse {
    /**
     * 
     * @type {string}
     * @memberof StatusResponse
     */
    message?: string;
}

/**
 * 
 * @export
 * @interface TelemetryRequest
 */
export interface TelemetryRequest {
    /**
     * event details
     * @type {{ [key: string]: any; }}
     * @memberof TelemetryRequest
     */
    event?: { [key: string]: any; };
}

/**
 * 
 * @export
 * @interface TimeSeriesMetrics
 */
export interface TimeSeriesMetrics {
    /**
     * 
     * @type {string}
     * @memberof TimeSeriesMetrics
     */
    type?: TimeSeriesMetrics.TypeEnum;
    /**
     * 
     * @type {{ [key: string]: VirtualInstanceMetric; }}
     * @memberof TimeSeriesMetrics
     */
    virtual_instance_metrics?: { [key: string]: VirtualInstanceMetric; };
    /**
     * 
     * @type {{ [key: string]: VirtualInstanceStorageMetric; }}
     * @memberof TimeSeriesMetrics
     */
    virtual_instance_storage_metrics?: { [key: string]: VirtualInstanceStorageMetric; };
    /**
     * 
     * @type {{ [key: string]: VirtualInstanceQueryMetric; }}
     * @memberof TimeSeriesMetrics
     */
    virtual_instance_query_metrics?: { [key: string]: VirtualInstanceQueryMetric; };
    /**
     * 
     * @type {{ [key: string]: Array<QueryLambdaMetric>; }}
     * @memberof TimeSeriesMetrics
     */
    query_lambda_metrics?: { [key: string]: Array<QueryLambdaMetric>; };
    /**
     * 
     * @type {{ [key: string]: Array<CollectionMetric>; }}
     * @memberof TimeSeriesMetrics
     */
    collection_metrics?: { [key: string]: Array<CollectionMetric>; };
    /**
     * 
     * @type {{ [key: string]: SlowQueryCount; }}
     * @memberof TimeSeriesMetrics
     */
    slow_query_counts?: { [key: string]: SlowQueryCount; };
    /**
     * 
     * @type {Array<SlowQuery>}
     * @memberof TimeSeriesMetrics
     */
    slow_queries?: Array<SlowQuery>;
    /**
     * 
     * @type {number}
     * @memberof TimeSeriesMetrics
     */
    query_count?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeSeriesMetrics
     */
    percentile_query_latency?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeSeriesMetrics
     */
    collection_bulk_ingest_cpu?: number;
}

/**
 * @export
 * @namespace TimeSeriesMetrics
 */
export namespace TimeSeriesMetrics {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        COLLECTION = <any> 'COLLECTION',
        QUERYLAMBDA = <any> 'QUERY_LAMBDA',
        VIRTUALINSTANCE = <any> 'VIRTUAL_INSTANCE',
        VIRTUALINSTANCEQUERY = <any> 'VIRTUAL_INSTANCE_QUERY',
        VIRTUALINSTANCESTORAGE = <any> 'VIRTUAL_INSTANCE_STORAGE',
        SLOWQUERYCOUNT = <any> 'SLOW_QUERY_COUNT',
        SLOWQUERIES = <any> 'SLOW_QUERIES',
        PERCENTILEQUERYLATENCY = <any> 'PERCENTILE_QUERY_LATENCY',
        QUERYCOUNT = <any> 'QUERY_COUNT',
        COLLECTIONBULKINGESTCPU = <any> 'COLLECTION_BULK_INGEST_CPU'
    }
}

/**
 * 
 * @export
 * @interface TimeSeriesMetricsResponse
 */
export interface TimeSeriesMetricsResponse {
    /**
     * 
     * @type {TimeSeriesMetrics}
     * @memberof TimeSeriesMetricsResponse
     */
    data?: TimeSeriesMetrics;
}

/**
 * 
 * @export
 * @interface TransferOwnershipRequest
 */
export interface TransferOwnershipRequest {
    /**
     * email of new owner
     * @type {string}
     * @memberof TransferOwnershipRequest
     */
    new_owner?: string;
}

/**
 * Notification preferences for the user.
 * @export
 * @interface UnsubscribePreference
 */
export interface UnsubscribePreference {
    /**
     * The type of notification to be unsubscribed from.
     * @type {string}
     * @memberof UnsubscribePreference
     */
    notificationType: string;
}

/**
 * 
 * @export
 * @interface UpdateAliasRequest
 */
export interface UpdateAliasRequest {
    /**
     * optional description
     * @type {string}
     * @memberof UpdateAliasRequest
     */
    description?: string;
    /**
     * list of fully qualified collection names referenced by alias
     * @type {Array<string>}
     * @memberof UpdateAliasRequest
     */
    collections: Array<string>;
}

/**
 * 
 * @export
 * @interface UpdateApiKeyRequest
 */
export interface UpdateApiKeyRequest {
    /**
     * State that the api key should be set to.
     * @type {string}
     * @memberof UpdateApiKeyRequest
     */
    state?: UpdateApiKeyRequest.StateEnum;
}

/**
 * @export
 * @namespace UpdateApiKeyRequest
 */
export namespace UpdateApiKeyRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        ACTIVE = <any> 'ACTIVE',
        SUSPENDED = <any> 'SUSPENDED'
    }
}

/**
 * 
 * @export
 * @interface UpdateApiKeyResponse
 */
export interface UpdateApiKeyResponse {
    /**
     * The API key that was updated.
     * @type {ApiKey}
     * @memberof UpdateApiKeyResponse
     */
    data?: ApiKey;
}

/**
 * 
 * @export
 * @interface UpdateOrgMfaSettingsRequest
 */
export interface UpdateOrgMfaSettingsRequest {
    /**
     * org is MFA restricted
     * @type {boolean}
     * @memberof UpdateOrgMfaSettingsRequest
     */
    mfa_restricted?: boolean;
}

/**
 * 
 * @export
 * @interface UpdateOrgPaymentMethodRequest
 */
export interface UpdateOrgPaymentMethodRequest {
    /**
     * Stripe source
     * @type {string}
     * @memberof UpdateOrgPaymentMethodRequest
     */
    source?: string;
}

/**
 * 
 * @export
 * @interface UpdateQueryLambdaRequest
 */
export interface UpdateQueryLambdaRequest {
    /**
     * optional description
     * @type {string}
     * @memberof UpdateQueryLambdaRequest
     */
    description?: string;
    /**
     * Query Lambda SQL query
     * @type {QueryLambdaSql}
     * @memberof UpdateQueryLambdaRequest
     */
    sql?: QueryLambdaSql;
}

/**
 * 
 * @export
 * @interface UpdateRoleRequest
 */
export interface UpdateRoleRequest {
    /**
     * Description for the role.
     * @type {string}
     * @memberof UpdateRoleRequest
     */
    description?: string;
    /**
     * List of privileges that will be associated with the role.
     * @type {Array<Privilege>}
     * @memberof UpdateRoleRequest
     */
    privileges?: Array<Privilege>;
}

/**
 * 
 * @export
 * @interface UpdateSsoRequest
 */
export interface UpdateSsoRequest {
    /**
     * x09 SAML certificate
     * @type {string}
     * @memberof UpdateSsoRequest
     */
    cert?: string;
    /**
     * SSO provided endpoint to trigger login
     * @type {string}
     * @memberof UpdateSsoRequest
     */
    sign_in_endpoint?: string;
    /**
     * auto provision accounts for users in domain
     * @type {boolean}
     * @memberof UpdateSsoRequest
     */
    auto_provision?: boolean;
    /**
     * auto provision accounts with this role
     * @type {string}
     * @memberof UpdateSsoRequest
     */
    auto_provision_role?: string;
    /**
     * force sso as only auth mechanism for org
     * @type {boolean}
     * @memberof UpdateSsoRequest
     */
    sso_only?: boolean;
}

/**
 * 
 * @export
 * @interface UpdateUnsubscribePreferencesRequest
 */
export interface UpdateUnsubscribePreferencesRequest {
    /**
     * List of notification preferences
     * @type {Array<UnsubscribePreference>}
     * @memberof UpdateUnsubscribePreferencesRequest
     */
    data?: Array<UnsubscribePreference>;
}

/**
 * 
 * @export
 * @interface UpdateUnsubscribePreferencesResponse
 */
export interface UpdateUnsubscribePreferencesResponse {
    /**
     * List of notification preferences
     * @type {Array<UnsubscribePreference>}
     * @memberof UpdateUnsubscribePreferencesResponse
     */
    data?: Array<UnsubscribePreference>;
}

/**
 * 
 * @export
 * @interface UpdateUserNuxRequest
 */
export interface UpdateUserNuxRequest {
    /**
     * data integration for this user's nux
     * @type {string}
     * @memberof UpdateUserNuxRequest
     */
    data_integration?: UpdateUserNuxRequest.DataIntegrationEnum;
    /**
     * way in which user wants to export query in nux
     * @type {string}
     * @memberof UpdateUserNuxRequest
     */
    query_integration_type?: UpdateUserNuxRequest.QueryIntegrationTypeEnum;
    /**
     * specific query integration for this user's nux
     * @type {string}
     * @memberof UpdateUserNuxRequest
     */
    query_integration?: UpdateUserNuxRequest.QueryIntegrationEnum;
    /**
     * boolean for if user has dismissed nux
     * @type {boolean}
     * @memberof UpdateUserNuxRequest
     */
    dismissed_nux?: boolean;
}

/**
 * @export
 * @namespace UpdateUserNuxRequest
 */
export namespace UpdateUserNuxRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum DataIntegrationEnum {
        S3 = <any> 'S3',
        KINESIS = <any> 'KINESIS',
        DYNAMODB = <any> 'DYNAMODB',
        GCS = <any> 'GCS',
        REDSHIFT = <any> 'REDSHIFT',
        KAFKA = <any> 'KAFKA',
        FILE = <any> 'FILE',
        WRITE = <any> 'WRITE',
        PUBLIC = <any> 'PUBLIC',
        MONGODB = <any> 'MONGODB',
        RDSMYSQL = <any> 'RDSMYSQL',
        RDSORACLE = <any> 'RDSORACLE',
        RDSPOSTGRES = <any> 'RDSPOSTGRES',
        UNKNOWN = <any> 'UNKNOWN'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum QueryIntegrationTypeEnum {
        VIZ = <any> 'VIZ',
        CODE = <any> 'CODE',
        UNKNOWN = <any> 'UNKNOWN'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum QueryIntegrationEnum {
        GRAFANA = <any> 'GRAFANA',
        REDASH = <any> 'REDASH',
        SUPERSET = <any> 'SUPERSET',
        TABLEAU = <any> 'TABLEAU',
        GOLANG = <any> 'GOLANG',
        JAVA = <any> 'JAVA',
        NODEJS = <any> 'NODEJS',
        PYTHON = <any> 'PYTHON',
        RLANG = <any> 'RLANG',
        REST = <any> 'REST',
        RETOOL = <any> 'RETOOL',
        UNKNOWN = <any> 'UNKNOWN'
    }
}

/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * user first name
     * @type {string}
     * @memberof UpdateUserRequest
     */
    first_name?: string;
    /**
     * user last name
     * @type {string}
     * @memberof UpdateUserRequest
     */
    last_name?: string;
    /**
     * user phone number
     * @type {string}
     * @memberof UpdateUserRequest
     */
    phone_number?: string;
    /**
     * number of times to prompt user for demo
     * @type {number}
     * @memberof UpdateUserRequest
     */
    demo_remaining_prompts?: number;
    /**
     * New list of roles for a given user
     * @type {Array<string>}
     * @memberof UpdateUserRequest
     */
    roles?: Array<string>;
}

/**
 * 
 * @export
 * @interface UpdateViewRequest
 */
export interface UpdateViewRequest {
    /**
     * optional description
     * @type {string}
     * @memberof UpdateViewRequest
     */
    description?: string;
    /**
     * SQL for this view
     * @type {string}
     * @memberof UpdateViewRequest
     */
    query: string;
}

/**
 * 
 * @export
 * @interface UpdateViewResponse
 */
export interface UpdateViewResponse {
    /**
     * view that was updated
     * @type {View}
     * @memberof UpdateViewResponse
     */
    data?: View;
}

/**
 * 
 * @export
 * @interface UpdateVirtualInstanceRequest
 */
export interface UpdateVirtualInstanceRequest {
    /**
     * requested virtual instance size
     * @type {string}
     * @memberof UpdateVirtualInstanceRequest
     */
    new_size?: UpdateVirtualInstanceRequest.NewSizeEnum;
    /**
     * requested virtual instance type
     * @type {string}
     * @memberof UpdateVirtualInstanceRequest
     */
    new_type?: UpdateVirtualInstanceRequest.NewTypeEnum;
    /**
     * whether monitoring should be enabled for this virtual instance
     * @type {boolean}
     * @memberof UpdateVirtualInstanceRequest
     */
    monitoring_enabled?: boolean;
}

/**
 * @export
 * @namespace UpdateVirtualInstanceRequest
 */
export namespace UpdateVirtualInstanceRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum NewSizeEnum {
        FREE = <any> 'FREE',
        SHARED = <any> 'SHARED',
        SMALL = <any> 'SMALL',
        MEDIUM = <any> 'MEDIUM',
        LARGE = <any> 'LARGE',
        XLARGE = <any> 'XLARGE',
        XLARGE2 = <any> 'XLARGE2',
        XLARGE4 = <any> 'XLARGE4',
        XLARGE8 = <any> 'XLARGE8',
        XLARGE16 = <any> 'XLARGE16'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum NewTypeEnum {
        FREE = <any> 'FREE',
        SHARED = <any> 'SHARED',
        SMALL = <any> 'SMALL',
        MEDIUM = <any> 'MEDIUM',
        LARGE = <any> 'LARGE',
        XLARGE = <any> 'XLARGE',
        XLARGE2 = <any> 'XLARGE2',
        XLARGE4 = <any> 'XLARGE4',
        XLARGE8 = <any> 'XLARGE8',
        XLARGE16 = <any> 'XLARGE16'
    }
}

/**
 * 
 * @export
 * @interface UpdateVirtualInstanceResponse
 */
export interface UpdateVirtualInstanceResponse {
    /**
     * virtual instance that was switched
     * @type {VirtualInstance}
     * @memberof UpdateVirtualInstanceResponse
     */
    data?: VirtualInstance;
}

/**
 * 
 * @export
 * @interface UploadFileResponse
 */
export interface UploadFileResponse {
    /**
     * information about the file uploaded
     * @type {FileUploadStatus}
     * @memberof UploadFileResponse
     */
    data?: FileUploadStatus;
}

/**
 * 
 * @export
 * @interface Usage
 */
export interface Usage {
    /**
     * 
     * @type {number}
     * @memberof Usage
     */
    byte_minutes?: number;
    /**
     * 
     * @type {number}
     * @memberof Usage
     */
    price?: number;
    /**
     * 
     * @type {number}
     * @memberof Usage
     */
    gb_hours?: number;
    /**
     * 
     * @type {number}
     * @memberof Usage
     */
    gb_months: number;
    /**
     * 
     * @type {number}
     * @memberof Usage
     */
    total_cost: number;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * ISO-8601 date
     * @type {string}
     * @memberof User
     */
    created_at?: string;
    /**
     * user email
     * @type {string}
     * @memberof User
     */
    email: string;
    /**
     * user first name
     * @type {string}
     * @memberof User
     */
    first_name?: string;
    /**
     * user last name
     * @type {string}
     * @memberof User
     */
    last_name?: string;
    /**
     * user phone number
     * @type {string}
     * @memberof User
     */
    phone_number?: string;
    /**
     * List of roles for a given user
     * @type {Array<string>}
     * @memberof User
     */
    roles?: Array<string>;
    /**
     * state of user - NEW / ACTIVE
     * @type {string}
     * @memberof User
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    org?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    invite_state?: User.InviteStateEnum;
    /**
     * 
     * @type {Array<Organization>}
     * @memberof User
     */
    orgs?: Array<Organization>;
    /**
     * 
     * @type {Array<OrgMembership>}
     * @memberof User
     */
    org_memberships?: Array<OrgMembership>;
}

/**
 * @export
 * @namespace User
 */
export namespace User {
    /**
     * @export
     * @enum {string}
     */
    export enum InviteStateEnum {
        PENDING = <any> 'PENDING',
        ACCEPTED = <any> 'ACCEPTED',
        EXPIRED = <any> 'EXPIRED',
        CANCELLED = <any> 'CANCELLED'
    }
}

/**
 * 
 * @export
 * @interface UserNux
 */
export interface UserNux {
    /**
     * user email
     * @type {string}
     * @memberof UserNux
     */
    email: string;
    /**
     * data integration for this user's nux
     * @type {string}
     * @memberof UserNux
     */
    data_integration?: UserNux.DataIntegrationEnum;
    /**
     * way in which user wants to export query in nux
     * @type {string}
     * @memberof UserNux
     */
    query_integration_type?: UserNux.QueryIntegrationTypeEnum;
    /**
     * specific query integration for this user's nux
     * @type {string}
     * @memberof UserNux
     */
    query_integration?: UserNux.QueryIntegrationEnum;
    /**
     * boolean for if user has dismissed nux
     * @type {boolean}
     * @memberof UserNux
     */
    dismissed_nux?: boolean;
}

/**
 * @export
 * @namespace UserNux
 */
export namespace UserNux {
    /**
     * @export
     * @enum {string}
     */
    export enum DataIntegrationEnum {
        S3 = <any> 'S3',
        KINESIS = <any> 'KINESIS',
        DYNAMODB = <any> 'DYNAMODB',
        GCS = <any> 'GCS',
        REDSHIFT = <any> 'REDSHIFT',
        KAFKA = <any> 'KAFKA',
        FILE = <any> 'FILE',
        WRITE = <any> 'WRITE',
        PUBLIC = <any> 'PUBLIC',
        MONGODB = <any> 'MONGODB',
        RDSMYSQL = <any> 'RDSMYSQL',
        RDSORACLE = <any> 'RDSORACLE',
        RDSPOSTGRES = <any> 'RDSPOSTGRES',
        UNKNOWN = <any> 'UNKNOWN'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum QueryIntegrationTypeEnum {
        VIZ = <any> 'VIZ',
        CODE = <any> 'CODE',
        UNKNOWN = <any> 'UNKNOWN'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum QueryIntegrationEnum {
        GRAFANA = <any> 'GRAFANA',
        REDASH = <any> 'REDASH',
        SUPERSET = <any> 'SUPERSET',
        TABLEAU = <any> 'TABLEAU',
        GOLANG = <any> 'GOLANG',
        JAVA = <any> 'JAVA',
        NODEJS = <any> 'NODEJS',
        PYTHON = <any> 'PYTHON',
        RLANG = <any> 'RLANG',
        REST = <any> 'REST',
        RETOOL = <any> 'RETOOL',
        UNKNOWN = <any> 'UNKNOWN'
    }
}

/**
 * 
 * @export
 * @interface UserQuery
 */
export interface UserQuery {
    /**
     * success/invalid status of query
     * @type {string}
     * @memberof UserQuery
     */
    label?: string;
    /**
     * query that user executed
     * @type {string}
     * @memberof UserQuery
     */
    query_sql?: string;
    /**
     * ISO 8601 time at which the query was executed
     * @type {string}
     * @memberof UserQuery
     */
    query_time?: string;
}

/**
 * 
 * @export
 * @interface UserQueryHistoryResponse
 */
export interface UserQueryHistoryResponse {
    /**
     * query history of this user
     * @type {Array<UserQuery>}
     * @memberof UserQueryHistoryResponse
     */
    data?: Array<UserQuery>;
}

/**
 * 
 * @export
 * @interface UserState
 */
export interface UserState {
    /**
     * state of user
     * @type {string}
     * @memberof UserState
     */
    data?: UserState.DataEnum;
    /**
     * number of prompts left for user
     * @type {number}
     * @memberof UserState
     */
    demo_remaining_prompts?: number;
}

/**
 * @export
 * @namespace UserState
 */
export namespace UserState {
    /**
     * @export
     * @enum {string}
     */
    export enum DataEnum {
        NEW = <any> 'NEW',
        ACTIVE = <any> 'ACTIVE'
    }
}

/**
 * 
 * @export
 * @interface ValidateExpressionRequest
 */
export interface ValidateExpressionRequest {
    /**
     * SQL expression to be validated
     * @type {string}
     * @memberof ValidateExpressionRequest
     */
    sql_expression?: string;
}

/**
 * 
 * @export
 * @interface ValidateExpressionResponse
 */
export interface ValidateExpressionResponse {
    /**
     * input parameters of validated SQL expression
     * @type {Array<string>}
     * @memberof ValidateExpressionResponse
     */
    parameters?: Array<string>;
}

/**
 * 
 * @export
 * @interface ValidateFieldMappingQueryRequest
 */
export interface ValidateFieldMappingQueryRequest {
    /**
     * Field mapping query to be validated
     * @type {string}
     * @memberof ValidateFieldMappingQueryRequest
     */
    sql?: string;
    /**
     * is field mapping for an insert only collection
     * @type {boolean}
     * @memberof ValidateFieldMappingQueryRequest
     */
    insert_only?: boolean;
}

/**
 * 
 * @export
 * @interface ValidateFieldMappingQueryResponse
 */
export interface ValidateFieldMappingQueryResponse {
    /**
     * Whether the field mapping query is valid
     * @type {boolean}
     * @memberof ValidateFieldMappingQueryResponse
     */
    valid?: boolean;
    /**
     * The reason if field mapping query is invalid
     * @type {string}
     * @memberof ValidateFieldMappingQueryResponse
     */
    reason?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ValidateFieldMappingQueryResponse
     */
    is_rollup?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ValidateFieldMappingQueryResponse
     */
    has_id_mapping?: boolean;
}

/**
 * 
 * @export
 * @interface ValidateQueryResponse
 */
export interface ValidateQueryResponse {
    /**
     * list of aliases specifiedQueryRunner and referenced collections in query
     * @type {Array<QueryResponseAlias>}
     * @memberof ValidateQueryResponse
     */
    aliases?: Array<QueryResponseAlias>;
    /**
     * list of views specified in query
     * @type {Array<string>}
     * @memberof ValidateQueryResponse
     */
    views?: Array<string>;
    /**
     * list of collection specified in query
     * @type {Array<string>}
     * @memberof ValidateQueryResponse
     */
    name: Array<string>;
    /**
     * list of collection specified in query
     * @type {Array<string>}
     * @memberof ValidateQueryResponse
     */
    collections: Array<string>;
    /**
     * list of parameters specified in query
     * @type {Array<string>}
     * @memberof ValidateQueryResponse
     */
    parameters: Array<string>;
}

/**
 * 
 * @export
 * @interface View
 */
export interface View {
    /**
     * 
     * @type {string}
     * @memberof View
     */
    path?: string;
    /**
     * name of the view
     * @type {string}
     * @memberof View
     */
    name?: string;
    /**
     * view description
     * @type {string}
     * @memberof View
     */
    description?: string;
    /**
     * name of the workspace
     * @type {string}
     * @memberof View
     */
    workspace?: string;
    /**
     * email of the creator
     * @type {string}
     * @memberof View
     */
    creator_email?: string;
    /**
     * email of the owner
     * @type {string}
     * @memberof View
     */
    owner_email?: string;
    /**
     * SQL query of the view
     * @type {string}
     * @memberof View
     */
    query_sql?: string;
    /**
     * list of entities referenced by view. An entity can be a view, alias or collection
     * @type {Array<string>}
     * @memberof View
     */
    entities?: Array<string>;
    /**
     * state of the view
     * @type {string}
     * @memberof View
     */
    state?: View.StateEnum;
    /**
     * ISO-8601 date
     * @type {string}
     * @memberof View
     */
    created_at?: string;
    /**
     * ISO-8601 date
     * @type {string}
     * @memberof View
     */
    modified_at?: string;
}

/**
 * @export
 * @namespace View
 */
export namespace View {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        CREATED = <any> 'CREATED',
        SYNCING = <any> 'SYNCING',
        DELETED = <any> 'DELETED'
    }
}

/**
 * 
 * @export
 * @interface VirtualInstance
 */
export interface VirtualInstance {
    /**
     * virtual instance state
     * @type {string}
     * @memberof VirtualInstance
     */
    state?: VirtualInstance.StateEnum;
    /**
     * virtual instance current type
     * @type {string}
     * @memberof VirtualInstance
     */
    current_type?: VirtualInstance.CurrentTypeEnum;
    /**
     * virtual instance desired type
     * @type {string}
     * @memberof VirtualInstance
     */
    desired_type?: VirtualInstance.DesiredTypeEnum;
    /**
     * virtual instance current size
     * @type {string}
     * @memberof VirtualInstance
     */
    current_size?: VirtualInstance.CurrentSizeEnum;
    /**
     * virtual instance desired size
     * @type {string}
     * @memberof VirtualInstance
     */
    desired_size?: VirtualInstance.DesiredSizeEnum;
    /**
     * ISO-8601 date of when virtual instance size was last updated
     * @type {string}
     * @memberof VirtualInstance
     */
    last_updated?: string;
    /**
     * estimated duration in minutes of last virtual instance size update
     * @type {number}
     * @memberof VirtualInstance
     */
    estimated_switch_duration_minutes?: number;
    /**
     * whether monitoring should be enabled for this virtual instance
     * @type {boolean}
     * @memberof VirtualInstance
     */
    monitoring_enabled?: boolean;
    /**
     * virtual instance default pod count
     * @type {number}
     * @memberof VirtualInstance
     */
    default_pod_count?: number;
    /**
     * virtual instance scaled pod count
     * @type {number}
     * @memberof VirtualInstance
     */
    scaled_pod_count?: number;
    /**
     * unique identifier for virtual instance
     * @type {string}
     * @memberof VirtualInstance
     */
    id?: string;
}

/**
 * @export
 * @namespace VirtualInstance
 */
export namespace VirtualInstance {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        PROVISIONINGRESOURCES = <any> 'PROVISIONING_RESOURCES',
        REBALANCINGCOLLECTIONS = <any> 'REBALANCING_COLLECTIONS',
        ACTIVE = <any> 'ACTIVE',
        DELETED = <any> 'DELETED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum CurrentTypeEnum {
        FREE = <any> 'FREE',
        SHARED = <any> 'SHARED',
        SMALL = <any> 'SMALL',
        MEDIUM = <any> 'MEDIUM',
        LARGE = <any> 'LARGE',
        XLARGE = <any> 'XLARGE',
        XLARGE2 = <any> 'XLARGE2',
        XLARGE4 = <any> 'XLARGE4',
        XLARGE8 = <any> 'XLARGE8',
        XLARGE16 = <any> 'XLARGE16'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DesiredTypeEnum {
        FREE = <any> 'FREE',
        SHARED = <any> 'SHARED',
        SMALL = <any> 'SMALL',
        MEDIUM = <any> 'MEDIUM',
        LARGE = <any> 'LARGE',
        XLARGE = <any> 'XLARGE',
        XLARGE2 = <any> 'XLARGE2',
        XLARGE4 = <any> 'XLARGE4',
        XLARGE8 = <any> 'XLARGE8',
        XLARGE16 = <any> 'XLARGE16'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum CurrentSizeEnum {
        FREE = <any> 'FREE',
        SHARED = <any> 'SHARED',
        SMALL = <any> 'SMALL',
        MEDIUM = <any> 'MEDIUM',
        LARGE = <any> 'LARGE',
        XLARGE = <any> 'XLARGE',
        XLARGE2 = <any> 'XLARGE2',
        XLARGE4 = <any> 'XLARGE4',
        XLARGE8 = <any> 'XLARGE8',
        XLARGE16 = <any> 'XLARGE16'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DesiredSizeEnum {
        FREE = <any> 'FREE',
        SHARED = <any> 'SHARED',
        SMALL = <any> 'SMALL',
        MEDIUM = <any> 'MEDIUM',
        LARGE = <any> 'LARGE',
        XLARGE = <any> 'XLARGE',
        XLARGE2 = <any> 'XLARGE2',
        XLARGE4 = <any> 'XLARGE4',
        XLARGE8 = <any> 'XLARGE8',
        XLARGE16 = <any> 'XLARGE16'
    }
}

/**
 * 
 * @export
 * @interface VirtualInstanceMetric
 */
export interface VirtualInstanceMetric {
    /**
     * 
     * @type {number}
     * @memberof VirtualInstanceMetric
     */
    leaf_cpu_load?: number;
    /**
     * 
     * @type {number}
     * @memberof VirtualInstanceMetric
     */
    leaf_cpu_utilization?: number;
    /**
     * 
     * @type {number}
     * @memberof VirtualInstanceMetric
     */
    leaf_cpu_allocated?: number;
    /**
     * 
     * @type {number}
     * @memberof VirtualInstanceMetric
     */
    leaf_memory_used?: number;
    /**
     * 
     * @type {number}
     * @memberof VirtualInstanceMetric
     */
    leaf_memory_allocated?: number;
    /**
     * 
     * @type {number}
     * @memberof VirtualInstanceMetric
     */
    aggregator_cpu_load?: number;
    /**
     * 
     * @type {number}
     * @memberof VirtualInstanceMetric
     */
    aggregator_cpu_utilization?: number;
    /**
     * 
     * @type {number}
     * @memberof VirtualInstanceMetric
     */
    aggregator_cpu_allocated?: number;
    /**
     * 
     * @type {number}
     * @memberof VirtualInstanceMetric
     */
    aggregator_memory_used?: number;
    /**
     * 
     * @type {number}
     * @memberof VirtualInstanceMetric
     */
    aggregator_memory_allocated?: number;
    /**
     * 
     * @type {boolean}
     * @memberof VirtualInstanceMetric
     */
    switch_in_progress?: boolean;
    /**
     * 
     * @type {number}
     * @memberof VirtualInstanceMetric
     */
    time?: number;
}

/**
 * 
 * @export
 * @interface VirtualInstanceMetrics
 */
export interface VirtualInstanceMetrics {
    /**
     * virtual instance current type
     * @type {string}
     * @memberof VirtualInstanceMetrics
     */
    current_type?: VirtualInstanceMetrics.CurrentTypeEnum;
    /**
     * virtual instance desired type
     * @type {string}
     * @memberof VirtualInstanceMetrics
     */
    desired_type?: VirtualInstanceMetrics.DesiredTypeEnum;
    /**
     * virtual instance state
     * @type {string}
     * @memberof VirtualInstanceMetrics
     */
    state?: VirtualInstanceMetrics.StateEnum;
    /**
     * virtual instance leaf cpu load
     * @type {number}
     * @memberof VirtualInstanceMetrics
     */
    leaf_cpu_load?: number;
    /**
     * virtual instance leaf cpu utilization
     * @type {number}
     * @memberof VirtualInstanceMetrics
     */
    leaf_cpu_utilization?: number;
    /**
     * virtual instance leaf cpu allocated
     * @type {number}
     * @memberof VirtualInstanceMetrics
     */
    leaf_cpu_allocated?: number;
    /**
     * virtual instance leaf memory used
     * @type {number}
     * @memberof VirtualInstanceMetrics
     */
    leaf_memory_used?: number;
    /**
     * virtual instance leaf memory allocated
     * @type {number}
     * @memberof VirtualInstanceMetrics
     */
    leaf_memory_allocated?: number;
    /**
     * virtual instance aggregator cpu load
     * @type {number}
     * @memberof VirtualInstanceMetrics
     */
    aggregator_cpu_load?: number;
    /**
     * virtual instance aggregator cpu utilization
     * @type {number}
     * @memberof VirtualInstanceMetrics
     */
    aggregator_cpu_utilization?: number;
    /**
     * virtual instance aggregator cpu allocated
     * @type {number}
     * @memberof VirtualInstanceMetrics
     */
    aggregator_cpu_allocated?: number;
    /**
     * virtual instance aggregator memory used
     * @type {number}
     * @memberof VirtualInstanceMetrics
     */
    aggregator_memory_used?: number;
    /**
     * virtual instance aggregator memory allocated
     * @type {number}
     * @memberof VirtualInstanceMetrics
     */
    aggregator_memory_allocated?: number;
    /**
     * virtual instance queries in flight
     * @type {number}
     * @memberof VirtualInstanceMetrics
     */
    queries_in_flight?: number;
    /**
     * metrics timestamp millis
     * @type {number}
     * @memberof VirtualInstanceMetrics
     */
    time_millis?: number;
}

/**
 * @export
 * @namespace VirtualInstanceMetrics
 */
export namespace VirtualInstanceMetrics {
    /**
     * @export
     * @enum {string}
     */
    export enum CurrentTypeEnum {
        FREE = <any> 'FREE',
        SHARED = <any> 'SHARED',
        SMALL = <any> 'SMALL',
        MEDIUM = <any> 'MEDIUM',
        LARGE = <any> 'LARGE',
        XLARGE = <any> 'XLARGE',
        XLARGE2 = <any> 'XLARGE2',
        XLARGE4 = <any> 'XLARGE4',
        XLARGE8 = <any> 'XLARGE8',
        XLARGE16 = <any> 'XLARGE16'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DesiredTypeEnum {
        FREE = <any> 'FREE',
        SHARED = <any> 'SHARED',
        SMALL = <any> 'SMALL',
        MEDIUM = <any> 'MEDIUM',
        LARGE = <any> 'LARGE',
        XLARGE = <any> 'XLARGE',
        XLARGE2 = <any> 'XLARGE2',
        XLARGE4 = <any> 'XLARGE4',
        XLARGE8 = <any> 'XLARGE8',
        XLARGE16 = <any> 'XLARGE16'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        PROVISIONINGRESOURCES = <any> 'PROVISIONING_RESOURCES',
        REBALANCINGCOLLECTIONS = <any> 'REBALANCING_COLLECTIONS',
        ACTIVE = <any> 'ACTIVE',
        DELETED = <any> 'DELETED'
    }
}

/**
 * 
 * @export
 * @interface VirtualInstanceQueryMetric
 */
export interface VirtualInstanceQueryMetric {
    /**
     * 
     * @type {number}
     * @memberof VirtualInstanceQueryMetric
     */
    avg_latency?: number;
    /**
     * 
     * @type {number}
     * @memberof VirtualInstanceQueryMetric
     */
    avg_throttled_latency?: number;
    /**
     * 
     * @type {number}
     * @memberof VirtualInstanceQueryMetric
     */
    query_count?: number;
    /**
     * 
     * @type {number}
     * @memberof VirtualInstanceQueryMetric
     */
    err_count?: number;
    /**
     * 
     * @type {number}
     * @memberof VirtualInstanceQueryMetric
     */
    err_count_5xx?: number;
    /**
     * 
     * @type {number}
     * @memberof VirtualInstanceQueryMetric
     */
    err_count_4xx?: number;
    /**
     * 
     * @type {number}
     * @memberof VirtualInstanceQueryMetric
     */
    time?: number;
}

/**
 * 
 * @export
 * @interface VirtualInstanceStorageMetric
 */
export interface VirtualInstanceStorageMetric {
    /**
     * 
     * @type {number}
     * @memberof VirtualInstanceStorageMetric
     */
    total_index_size?: number;
    /**
     * 
     * @type {number}
     * @memberof VirtualInstanceStorageMetric
     */
    total_index_size_bulk?: number;
    /**
     * 
     * @type {number}
     * @memberof VirtualInstanceStorageMetric
     */
    total_index_size_streaming?: number;
    /**
     * 
     * @type {number}
     * @memberof VirtualInstanceStorageMetric
     */
    time?: number;
}

/**
 * Workspaces are organizational containers for collections.
 * @export
 * @interface Workspace
 */
export interface Workspace {
    /**
     * ISO-8601 date of when workspace was created
     * @type {string}
     * @memberof Workspace
     */
    created_at?: string;
    /**
     * email of user who created the workspace
     * @type {string}
     * @memberof Workspace
     */
    created_by?: string;
    /**
     * descriptive label and unique identifier
     * @type {string}
     * @memberof Workspace
     */
    name?: string;
    /**
     * longer explanation for the workspace
     * @type {string}
     * @memberof Workspace
     */
    description?: string;
    /**
     * number of collections that are immediate children of workspace
     * @type {number}
     * @memberof Workspace
     */
    collection_count?: number;
}

/**
 * 
 * @export
 * @interface XmlParams
 */
export interface XmlParams {
    /**
     * tag until which xml is ignored
     * @type {string}
     * @memberof XmlParams
     */
    root_tag?: string;
    /**
     * encoding in which data source is encoded
     * @type {string}
     * @memberof XmlParams
     */
    encoding?: string;
    /**
     * tags with which documents are identified
     * @type {string}
     * @memberof XmlParams
     */
    doc_tag?: string;
    /**
     * tag used for the value when there are attributes in the element having no child
     * @type {string}
     * @memberof XmlParams
     */
    value_tag?: string;
    /**
     * tag to differentiate between attributes and elements
     * @type {string}
     * @memberof XmlParams
     */
    attribute_prefix?: string;
}


/**
 * APIKeysApi - fetch parameter creator
 * @export
 */
export const APIKeysApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new API key for the authenticated user.
         * @summary Create API Key
         * @param {CreateApiKeyRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey(body: CreateApiKeyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createApiKey.');
            }
            const localVarPath = `/v1/orgs/self/users/self/apikeys`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateApiKeyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an API key for any user in your organization.
         * @summary Delete API Key
         * @param {string} name Name of the API key.
         * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey(name: string, user: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteApiKey.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling deleteApiKey.');
            }
            const localVarPath = `/v1/orgs/self/users/{user}/apikeys/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete API Key
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeySelf(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteApiKeySelf.');
            }
            const localVarPath = `/v1/orgs/self/users/self/apikeys/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a particular API key for any user in your organization.
         * @summary Retrieve API Key
         * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
         * @param {string} name Name of the API key.
         * @param {boolean} [reveal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKey(user: string, name: string, reveal?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling getApiKey.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getApiKey.');
            }
            const localVarPath = `/v1/orgs/self/users/{user}/apikeys/{name}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (reveal !== undefined) {
                localVarQueryParameter['reveal'] = reveal;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve API key
         * @param {string} name 
         * @param {boolean} [reveal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKeySelf(name: string, reveal?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getApiKeySelf.');
            }
            const localVarPath = `/v1/orgs/self/users/self/apikeys/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (reveal !== undefined) {
                localVarQueryParameter['reveal'] = reveal;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List API key metadata for any user in your organization.
         * @summary List API Keys.
         * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeys(user: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling listApiKeys.');
            }
            const localVarPath = `/v1/orgs/self/users/{user}/apikeys`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List API keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysSelf(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/users/self/apikeys`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the state of an API key for any user in your organization.
         * @summary Update an API key's state
         * @param {string} name Name of the API key.
         * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
         * @param {UpdateApiKeyRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApiKey(name: string, user: string, body: UpdateApiKeyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling updateApiKey.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling updateApiKey.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateApiKey.');
            }
            const localVarPath = `/v1/orgs/self/users/{user}/apikeys/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateApiKeyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update API key
         * @param {string} name 
         * @param {UpdateApiKeyRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApiKeySelf(name: string, body: UpdateApiKeyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling updateApiKeySelf.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateApiKeySelf.');
            }
            const localVarPath = `/v1/orgs/self/users/self/apikeys/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateApiKeyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIKeysApi - functional programming interface
 * @export
 */
export const APIKeysApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new API key for the authenticated user.
         * @summary Create API Key
         * @param {CreateApiKeyRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey(body: CreateApiKeyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateApiKeyResponse> {
            const localVarFetchArgs = APIKeysApiFetchParamCreator(configuration).createApiKey(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an API key for any user in your organization.
         * @summary Delete API Key
         * @param {string} name Name of the API key.
         * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey(name: string, user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteApiKeyResponse> {
            const localVarFetchArgs = APIKeysApiFetchParamCreator(configuration).deleteApiKey(name, user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete API Key
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeySelf(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = APIKeysApiFetchParamCreator(configuration).deleteApiKeySelf(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve a particular API key for any user in your organization.
         * @summary Retrieve API Key
         * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
         * @param {string} name Name of the API key.
         * @param {boolean} [reveal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKey(user: string, name: string, reveal?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetApiKeyResponse> {
            const localVarFetchArgs = APIKeysApiFetchParamCreator(configuration).getApiKey(user, name, reveal, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieve API key
         * @param {string} name 
         * @param {boolean} [reveal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKeySelf(name: string, reveal?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = APIKeysApiFetchParamCreator(configuration).getApiKeySelf(name, reveal, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List API key metadata for any user in your organization.
         * @summary List API Keys.
         * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeys(user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListApiKeysResponse> {
            const localVarFetchArgs = APIKeysApiFetchParamCreator(configuration).listApiKeys(user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List API keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysSelf(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = APIKeysApiFetchParamCreator(configuration).listApiKeysSelf(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the state of an API key for any user in your organization.
         * @summary Update an API key's state
         * @param {string} name Name of the API key.
         * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
         * @param {UpdateApiKeyRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApiKey(name: string, user: string, body: UpdateApiKeyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpdateApiKeyResponse> {
            const localVarFetchArgs = APIKeysApiFetchParamCreator(configuration).updateApiKey(name, user, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update API key
         * @param {string} name 
         * @param {UpdateApiKeyRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApiKeySelf(name: string, body: UpdateApiKeyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = APIKeysApiFetchParamCreator(configuration).updateApiKeySelf(name, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * APIKeysApi - factory interface
 * @export
 */
export const APIKeysApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new API key for the authenticated user.
         * @summary Create API Key
         * @param {CreateApiKeyRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey(body: CreateApiKeyRequest, options?: any) {
            return APIKeysApiFp(configuration).createApiKey(body, options)(fetch, basePath);
        },
        /**
         * Delete an API key for any user in your organization.
         * @summary Delete API Key
         * @param {string} name Name of the API key.
         * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey(name: string, user: string, options?: any) {
            return APIKeysApiFp(configuration).deleteApiKey(name, user, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete API Key
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeySelf(name: string, options?: any) {
            return APIKeysApiFp(configuration).deleteApiKeySelf(name, options)(fetch, basePath);
        },
        /**
         * Retrieve a particular API key for any user in your organization.
         * @summary Retrieve API Key
         * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
         * @param {string} name Name of the API key.
         * @param {boolean} [reveal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKey(user: string, name: string, reveal?: boolean, options?: any) {
            return APIKeysApiFp(configuration).getApiKey(user, name, reveal, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve API key
         * @param {string} name 
         * @param {boolean} [reveal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKeySelf(name: string, reveal?: boolean, options?: any) {
            return APIKeysApiFp(configuration).getApiKeySelf(name, reveal, options)(fetch, basePath);
        },
        /**
         * List API key metadata for any user in your organization.
         * @summary List API Keys.
         * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeys(user: string, options?: any) {
            return APIKeysApiFp(configuration).listApiKeys(user, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List API keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysSelf(options?: any) {
            return APIKeysApiFp(configuration).listApiKeysSelf(options)(fetch, basePath);
        },
        /**
         * Update the state of an API key for any user in your organization.
         * @summary Update an API key's state
         * @param {string} name Name of the API key.
         * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
         * @param {UpdateApiKeyRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApiKey(name: string, user: string, body: UpdateApiKeyRequest, options?: any) {
            return APIKeysApiFp(configuration).updateApiKey(name, user, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update API key
         * @param {string} name 
         * @param {UpdateApiKeyRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApiKeySelf(name: string, body: UpdateApiKeyRequest, options?: any) {
            return APIKeysApiFp(configuration).updateApiKeySelf(name, body, options)(fetch, basePath);
        },
    };
};

/**
 * APIKeysApi - object-oriented interface
 * @export
 * @class APIKeysApi
 * @extends {BaseAPI}
 */
export class APIKeysApi extends BaseAPI {
    /**
     * Create a new API key for the authenticated user.
     * @summary Create API Key
     * @param {CreateApiKeyRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public createApiKey(body: CreateApiKeyRequest, options?: any) {
        return APIKeysApiFp(this.configuration).createApiKey(body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete an API key for any user in your organization.
     * @summary Delete API Key
     * @param {string} name Name of the API key.
     * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public deleteApiKey(name: string, user: string, options?: any) {
        return APIKeysApiFp(this.configuration).deleteApiKey(name, user, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete API Key
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public deleteApiKeySelf(name: string, options?: any) {
        return APIKeysApiFp(this.configuration).deleteApiKeySelf(name, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve a particular API key for any user in your organization.
     * @summary Retrieve API Key
     * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
     * @param {string} name Name of the API key.
     * @param {boolean} [reveal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public getApiKey(user: string, name: string, reveal?: boolean, options?: any) {
        return APIKeysApiFp(this.configuration).getApiKey(user, name, reveal, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve API key
     * @param {string} name 
     * @param {boolean} [reveal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public getApiKeySelf(name: string, reveal?: boolean, options?: any) {
        return APIKeysApiFp(this.configuration).getApiKeySelf(name, reveal, options)(this.fetch, this.basePath);
    }

    /**
     * List API key metadata for any user in your organization.
     * @summary List API Keys.
     * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public listApiKeys(user: string, options?: any) {
        return APIKeysApiFp(this.configuration).listApiKeys(user, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List API keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public listApiKeysSelf(options?: any) {
        return APIKeysApiFp(this.configuration).listApiKeysSelf(options)(this.fetch, this.basePath);
    }

    /**
     * Update the state of an API key for any user in your organization.
     * @summary Update an API key's state
     * @param {string} name Name of the API key.
     * @param {string} user Email of the API key owner. Use &#x60;self&#x60; to specify the currently authenticated user.
     * @param {UpdateApiKeyRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public updateApiKey(name: string, user: string, body: UpdateApiKeyRequest, options?: any) {
        return APIKeysApiFp(this.configuration).updateApiKey(name, user, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update API key
     * @param {string} name 
     * @param {UpdateApiKeyRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public updateApiKeySelf(name: string, body: UpdateApiKeyRequest, options?: any) {
        return APIKeysApiFp(this.configuration).updateApiKeySelf(name, body, options)(this.fetch, this.basePath);
    }

}

/**
 * AliasesApi - fetch parameter creator
 * @export
 */
export const AliasesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new alias in a workspace.
         * @summary Create Alias
         * @param {string} workspace name of the workspace
         * @param {CreateAliasRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlias(workspace: string, body: CreateAliasRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling createAlias.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createAlias.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/aliases`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateAliasRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an alias.
         * @summary Delete Alias
         * @param {string} workspace name of the workspace
         * @param {string} alias name of the alias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlias(workspace: string, alias: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling deleteAlias.');
            }
            // verify required parameter 'alias' is not null or undefined
            if (alias === null || alias === undefined) {
                throw new RequiredError('alias','Required parameter alias was null or undefined when calling deleteAlias.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/aliases/{alias}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"alias"}}`, encodeURIComponent(String(alias)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details about an alias
         * @summary Retrieve Alias
         * @param {string} workspace name of the workspace
         * @param {string} alias name of the alias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlias(workspace: string, alias: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling getAlias.');
            }
            // verify required parameter 'alias' is not null or undefined
            if (alias === null || alias === undefined) {
                throw new RequiredError('alias','Required parameter alias was null or undefined when calling getAlias.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/aliases/{alias}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"alias"}}`, encodeURIComponent(String(alias)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all aliases in an organization
         * @summary List Aliases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAliases(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/aliases`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all Query Lambdas that hit a specific Rockset Alias.
         * @summary Get Query Lambdas with Alias
         * @param {string} workspace 
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdasWithAlias(workspace: string, alias: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling listQueryLambdasWithAlias.');
            }
            // verify required parameter 'alias' is not null or undefined
            if (alias === null || alias === undefined) {
                throw new RequiredError('alias','Required parameter alias was null or undefined when calling listQueryLambdasWithAlias.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/aliases/{alias}/lambdas`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"alias"}}`, encodeURIComponent(String(alias)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transfer ownership of an alias to a new user.
         * @summary Transfer Ownership of an Alias
         * @param {string} workspace name of the workspace
         * @param {string} alias name of the alias
         * @param {TransferOwnershipRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferOwnership(workspace: string, alias: string, body: TransferOwnershipRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling transferOwnership.');
            }
            // verify required parameter 'alias' is not null or undefined
            if (alias === null || alias === undefined) {
                throw new RequiredError('alias','Required parameter alias was null or undefined when calling transferOwnership.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling transferOwnership.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/aliases/{alias}/owner`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"alias"}}`, encodeURIComponent(String(alias)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TransferOwnershipRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update alias in a workspace.
         * @summary Update Alias
         * @param {string} workspace name of the workspace
         * @param {string} alias name of the alias
         * @param {UpdateAliasRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlias(workspace: string, alias: string, body: UpdateAliasRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling updateAlias.');
            }
            // verify required parameter 'alias' is not null or undefined
            if (alias === null || alias === undefined) {
                throw new RequiredError('alias','Required parameter alias was null or undefined when calling updateAlias.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateAlias.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/aliases/{alias}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"alias"}}`, encodeURIComponent(String(alias)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateAliasRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all aliases in a workspace.
         * @summary List Aliases in Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceAliases(workspace: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling workspaceAliases.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/aliases`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AliasesApi - functional programming interface
 * @export
 */
export const AliasesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create new alias in a workspace.
         * @summary Create Alias
         * @param {string} workspace name of the workspace
         * @param {CreateAliasRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlias(workspace: string, body: CreateAliasRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateAliasResponse> {
            const localVarFetchArgs = AliasesApiFetchParamCreator(configuration).createAlias(workspace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an alias.
         * @summary Delete Alias
         * @param {string} workspace name of the workspace
         * @param {string} alias name of the alias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlias(workspace: string, alias: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteAliasResponse> {
            const localVarFetchArgs = AliasesApiFetchParamCreator(configuration).deleteAlias(workspace, alias, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get details about an alias
         * @summary Retrieve Alias
         * @param {string} workspace name of the workspace
         * @param {string} alias name of the alias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlias(workspace: string, alias: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAliasResponse> {
            const localVarFetchArgs = AliasesApiFetchParamCreator(configuration).getAlias(workspace, alias, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all aliases in an organization
         * @summary List Aliases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAliases(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListAliasesResponse> {
            const localVarFetchArgs = AliasesApiFetchParamCreator(configuration).listAliases(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all Query Lambdas that hit a specific Rockset Alias.
         * @summary Get Query Lambdas with Alias
         * @param {string} workspace 
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdasWithAlias(workspace: string, alias: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueryLambdasResponse> {
            const localVarFetchArgs = AliasesApiFetchParamCreator(configuration).listQueryLambdasWithAlias(workspace, alias, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Transfer ownership of an alias to a new user.
         * @summary Transfer Ownership of an Alias
         * @param {string} workspace name of the workspace
         * @param {string} alias name of the alias
         * @param {TransferOwnershipRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferOwnership(workspace: string, alias: string, body: TransferOwnershipRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AliasesApiFetchParamCreator(configuration).transferOwnership(workspace, alias, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update alias in a workspace.
         * @summary Update Alias
         * @param {string} workspace name of the workspace
         * @param {string} alias name of the alias
         * @param {UpdateAliasRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlias(workspace: string, alias: string, body: UpdateAliasRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAliasResponse> {
            const localVarFetchArgs = AliasesApiFetchParamCreator(configuration).updateAlias(workspace, alias, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all aliases in a workspace.
         * @summary List Aliases in Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceAliases(workspace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListAliasesResponse> {
            const localVarFetchArgs = AliasesApiFetchParamCreator(configuration).workspaceAliases(workspace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AliasesApi - factory interface
 * @export
 */
export const AliasesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create new alias in a workspace.
         * @summary Create Alias
         * @param {string} workspace name of the workspace
         * @param {CreateAliasRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlias(workspace: string, body: CreateAliasRequest, options?: any) {
            return AliasesApiFp(configuration).createAlias(workspace, body, options)(fetch, basePath);
        },
        /**
         * Delete an alias.
         * @summary Delete Alias
         * @param {string} workspace name of the workspace
         * @param {string} alias name of the alias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlias(workspace: string, alias: string, options?: any) {
            return AliasesApiFp(configuration).deleteAlias(workspace, alias, options)(fetch, basePath);
        },
        /**
         * Get details about an alias
         * @summary Retrieve Alias
         * @param {string} workspace name of the workspace
         * @param {string} alias name of the alias
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlias(workspace: string, alias: string, options?: any) {
            return AliasesApiFp(configuration).getAlias(workspace, alias, options)(fetch, basePath);
        },
        /**
         * Retrieve all aliases in an organization
         * @summary List Aliases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAliases(options?: any) {
            return AliasesApiFp(configuration).listAliases(options)(fetch, basePath);
        },
        /**
         * Get all Query Lambdas that hit a specific Rockset Alias.
         * @summary Get Query Lambdas with Alias
         * @param {string} workspace 
         * @param {string} alias 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdasWithAlias(workspace: string, alias: string, options?: any) {
            return AliasesApiFp(configuration).listQueryLambdasWithAlias(workspace, alias, options)(fetch, basePath);
        },
        /**
         * Transfer ownership of an alias to a new user.
         * @summary Transfer Ownership of an Alias
         * @param {string} workspace name of the workspace
         * @param {string} alias name of the alias
         * @param {TransferOwnershipRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferOwnership(workspace: string, alias: string, body: TransferOwnershipRequest, options?: any) {
            return AliasesApiFp(configuration).transferOwnership(workspace, alias, body, options)(fetch, basePath);
        },
        /**
         * Update alias in a workspace.
         * @summary Update Alias
         * @param {string} workspace name of the workspace
         * @param {string} alias name of the alias
         * @param {UpdateAliasRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlias(workspace: string, alias: string, body: UpdateAliasRequest, options?: any) {
            return AliasesApiFp(configuration).updateAlias(workspace, alias, body, options)(fetch, basePath);
        },
        /**
         * Retrieve all aliases in a workspace.
         * @summary List Aliases in Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceAliases(workspace: string, options?: any) {
            return AliasesApiFp(configuration).workspaceAliases(workspace, options)(fetch, basePath);
        },
    };
};

/**
 * AliasesApi - object-oriented interface
 * @export
 * @class AliasesApi
 * @extends {BaseAPI}
 */
export class AliasesApi extends BaseAPI {
    /**
     * Create new alias in a workspace.
     * @summary Create Alias
     * @param {string} workspace name of the workspace
     * @param {CreateAliasRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    public createAlias(workspace: string, body: CreateAliasRequest, options?: any) {
        return AliasesApiFp(this.configuration).createAlias(workspace, body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete an alias.
     * @summary Delete Alias
     * @param {string} workspace name of the workspace
     * @param {string} alias name of the alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    public deleteAlias(workspace: string, alias: string, options?: any) {
        return AliasesApiFp(this.configuration).deleteAlias(workspace, alias, options)(this.fetch, this.basePath);
    }

    /**
     * Get details about an alias
     * @summary Retrieve Alias
     * @param {string} workspace name of the workspace
     * @param {string} alias name of the alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    public getAlias(workspace: string, alias: string, options?: any) {
        return AliasesApiFp(this.configuration).getAlias(workspace, alias, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all aliases in an organization
     * @summary List Aliases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    public listAliases(options?: any) {
        return AliasesApiFp(this.configuration).listAliases(options)(this.fetch, this.basePath);
    }

    /**
     * Get all Query Lambdas that hit a specific Rockset Alias.
     * @summary Get Query Lambdas with Alias
     * @param {string} workspace 
     * @param {string} alias 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    public listQueryLambdasWithAlias(workspace: string, alias: string, options?: any) {
        return AliasesApiFp(this.configuration).listQueryLambdasWithAlias(workspace, alias, options)(this.fetch, this.basePath);
    }

    /**
     * Transfer ownership of an alias to a new user.
     * @summary Transfer Ownership of an Alias
     * @param {string} workspace name of the workspace
     * @param {string} alias name of the alias
     * @param {TransferOwnershipRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    public transferOwnership(workspace: string, alias: string, body: TransferOwnershipRequest, options?: any) {
        return AliasesApiFp(this.configuration).transferOwnership(workspace, alias, body, options)(this.fetch, this.basePath);
    }

    /**
     * Update alias in a workspace.
     * @summary Update Alias
     * @param {string} workspace name of the workspace
     * @param {string} alias name of the alias
     * @param {UpdateAliasRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    public updateAlias(workspace: string, alias: string, body: UpdateAliasRequest, options?: any) {
        return AliasesApiFp(this.configuration).updateAlias(workspace, alias, body, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all aliases in a workspace.
     * @summary List Aliases in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasesApi
     */
    public workspaceAliases(workspace: string, options?: any) {
        return AliasesApiFp(this.configuration).workspaceAliases(workspace, options)(this.fetch, this.basePath);
    }

}

/**
 * CollectionsApi - fetch parameter creator
 * @export
 */
export const CollectionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new collection in a workspace.
         * @summary Create Collection
         * @param {string} workspace name of the workspace
         * @param {CreateCollectionRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection(workspace: string, body: CreateCollectionRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling createCollection.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createCollection.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateCollectionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an ephemeral source (expires after 24h) to perform preview on.
         * @summary Create Preview Source
         * @param {CreatePreviewSourceRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPreviewSource(body: CreatePreviewSourceRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createPreviewSource.');
            }
            const localVarPath = `/v1/orgs/self/collections/previews/sources`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreatePreviewSourceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a collection and all its documents from Rockset.
         * @summary Delete Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollection(workspace: string, collection: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling deleteCollection.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling deleteCollection.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details about a collection.
         * @summary Retrieve Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection(workspace: string, collection: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling getCollection.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling getCollection.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Determines if the collection includes data at or after the specified fence
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {string} [fence] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionOffsets(workspace: string, collection: string, fence?: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling getCollectionOffsets.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling getCollectionOffsets.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/offsets/commit`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fence !== undefined) {
                localVarQueryParameter['fence'] = fence;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get schema for a collection in Rockset.
         * @summary Get Collection Schema
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {number} [depth] max nested depth level to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchema(workspace: string, collection: string, depth?: number, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling getSchema.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling getSchema.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/schema`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information about source.
         * @summary Get Source config
         * @param {SourceConfigRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourceConfigs(body: SourceConfigRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getSourceConfigs.');
            }
            const localVarPath = `/v1/orgs/self/collections/configs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SourceConfigRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all Aliases for a specific Rockset Collection.
         * @summary Get Aliases for Collection
         * @param {string} workspace 
         * @param {string} collection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAliasesForCollection(workspace: string, collection: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling listAliasesForCollection.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling listAliasesForCollection.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/aliases`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all collections in an organization.
         * @summary List Collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/collections`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all Query Lambdas that hit a specific Rockset Collection.
         * @summary Get Query Lambdas for Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdasInCollection(workspace: string, collection: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling listQueryLambdasInCollection.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling listQueryLambdasInCollection.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/lambdas`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get sample documents given collection configuration.
         * @summary Preview Collection
         * @param {PreviewCollectionRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewCollection(body: PreviewCollectionRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling previewCollection.');
            }
            const localVarPath = `/v1/orgs/self/collections/previews`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PreviewCollectionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update state of a collection.
         * @summary Update state of Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {'READY' | 'PAUSED'} state new state of this collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCollectionState(workspace: string, collection: string, state: 'READY' | 'PAUSED', options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling setCollectionState.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling setCollectionState.');
            }
            // verify required parameter 'state' is not null or undefined
            if (state === null || state === undefined) {
                throw new RequiredError('state','Required parameter state was null or undefined when calling setCollectionState.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/state/{state}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"state"}}`, encodeURIComponent(String(state)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transfer ownership of a collection to a new user.
         * @summary Transfer Ownership of a Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {TransferOwnershipRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferOwnership(workspace: string, collection: string, body: TransferOwnershipRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling transferOwnership.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling transferOwnership.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling transferOwnership.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/owner`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TransferOwnershipRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a file to a collection in Rockset.
         * @summary Upload a file
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {InputStream} body file input stream
         * @param {FormDataContentDisposition} body2 file metadata
         * @param {FormDataBodyPart} [body3] file format params
         * @param {string} [body4] file size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(workspace: string, collection: string, body: InputStream, body2: FormDataContentDisposition, body3?: FormDataBodyPart, body4?: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling uploadFile.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling uploadFile.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling uploadFile.');
            }
            // verify required parameter 'body2' is not null or undefined
            if (body2 === null || body2 === undefined) {
                throw new RequiredError('body2','Required parameter body2 was null or undefined when calling uploadFile.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/uploads`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body4 || {}) : (body4 || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a file to a preview source that can be used to generate preview docs
         * @summary Upload File to Preview Source
         * @param {string} preview_source_id preview source identifier
         * @param {InputStream} body file input stream
         * @param {FormDataContentDisposition} body2 file metadata
         * @param {string} [body3] file size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFilePreviewSource(preview_source_id: string, body: InputStream, body2: FormDataContentDisposition, body3?: string, options: any = {}): FetchArgs {
            // verify required parameter 'preview_source_id' is not null or undefined
            if (preview_source_id === null || preview_source_id === undefined) {
                throw new RequiredError('preview_source_id','Required parameter preview_source_id was null or undefined when calling uploadFilePreviewSource.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling uploadFilePreviewSource.');
            }
            // verify required parameter 'body2' is not null or undefined
            if (body2 === null || body2 === undefined) {
                throw new RequiredError('body2','Required parameter body2 was null or undefined when calling uploadFilePreviewSource.');
            }
            const localVarPath = `/v1/orgs/self/collections/previews/sources/{preview_source_id}/uploads`
                .replace(`{${"preview_source_id"}}`, encodeURIComponent(String(preview_source_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body3 || {}) : (body3 || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all collections in a workspace.
         * @summary List Collections in Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceCollections(workspace: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling workspaceCollections.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionsApi - functional programming interface
 * @export
 */
export const CollectionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create new collection in a workspace.
         * @summary Create Collection
         * @param {string} workspace name of the workspace
         * @param {CreateCollectionRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection(workspace: string, body: CreateCollectionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateCollectionResponse> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).createCollection(workspace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create an ephemeral source (expires after 24h) to perform preview on.
         * @summary Create Preview Source
         * @param {CreatePreviewSourceRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPreviewSource(body: CreatePreviewSourceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreatePreviewSourceResponse> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).createPreviewSource(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a collection and all its documents from Rockset.
         * @summary Delete Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollection(workspace: string, collection: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteCollectionResponse> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).deleteCollection(workspace, collection, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get details about a collection.
         * @summary Retrieve Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection(workspace: string, collection: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCollectionResponse> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).getCollection(workspace, collection, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Determines if the collection includes data at or after the specified fence
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {string} [fence] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionOffsets(workspace: string, collection: string, fence?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCollectionCommit> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).getCollectionOffsets(workspace, collection, fence, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get schema for a collection in Rockset.
         * @summary Get Collection Schema
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {number} [depth] max nested depth level to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchema(workspace: string, collection: string, depth?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryResponse> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).getSchema(workspace, collection, depth, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve information about source.
         * @summary Get Source config
         * @param {SourceConfigRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourceConfigs(body: SourceConfigRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SourceConfigResponse> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).getSourceConfigs(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all Aliases for a specific Rockset Collection.
         * @summary Get Aliases for Collection
         * @param {string} workspace 
         * @param {string} collection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAliasesForCollection(workspace: string, collection: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListAliasesResponse> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).listAliasesForCollection(workspace, collection, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all collections in an organization.
         * @summary List Collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListCollectionsResponse> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).listCollections(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all Query Lambdas that hit a specific Rockset Collection.
         * @summary Get Query Lambdas for Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdasInCollection(workspace: string, collection: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueryLambdaVersionsResponse> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).listQueryLambdasInCollection(workspace, collection, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get sample documents given collection configuration.
         * @summary Preview Collection
         * @param {PreviewCollectionRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewCollection(body: PreviewCollectionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PreviewCollectionResponse> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).previewCollection(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update state of a collection.
         * @summary Update state of Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {'READY' | 'PAUSED'} state new state of this collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCollectionState(workspace: string, collection: string, state: 'READY' | 'PAUSED', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCollectionResponse> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).setCollectionState(workspace, collection, state, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Transfer ownership of a collection to a new user.
         * @summary Transfer Ownership of a Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {TransferOwnershipRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferOwnership(workspace: string, collection: string, body: TransferOwnershipRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).transferOwnership(workspace, collection, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Upload a file to a collection in Rockset.
         * @summary Upload a file
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {InputStream} body file input stream
         * @param {FormDataContentDisposition} body2 file metadata
         * @param {FormDataBodyPart} [body3] file format params
         * @param {string} [body4] file size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(workspace: string, collection: string, body: InputStream, body2: FormDataContentDisposition, body3?: FormDataBodyPart, body4?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UploadFileResponse> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).uploadFile(workspace, collection, body, body2, body3, body4, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Upload a file to a preview source that can be used to generate preview docs
         * @summary Upload File to Preview Source
         * @param {string} preview_source_id preview source identifier
         * @param {InputStream} body file input stream
         * @param {FormDataContentDisposition} body2 file metadata
         * @param {string} [body3] file size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFilePreviewSource(preview_source_id: string, body: InputStream, body2: FormDataContentDisposition, body3?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UploadFileResponse> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).uploadFilePreviewSource(preview_source_id, body, body2, body3, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all collections in a workspace.
         * @summary List Collections in Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceCollections(workspace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListCollectionsResponse> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).workspaceCollections(workspace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CollectionsApi - factory interface
 * @export
 */
export const CollectionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create new collection in a workspace.
         * @summary Create Collection
         * @param {string} workspace name of the workspace
         * @param {CreateCollectionRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection(workspace: string, body: CreateCollectionRequest, options?: any) {
            return CollectionsApiFp(configuration).createCollection(workspace, body, options)(fetch, basePath);
        },
        /**
         * Create an ephemeral source (expires after 24h) to perform preview on.
         * @summary Create Preview Source
         * @param {CreatePreviewSourceRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPreviewSource(body: CreatePreviewSourceRequest, options?: any) {
            return CollectionsApiFp(configuration).createPreviewSource(body, options)(fetch, basePath);
        },
        /**
         * Delete a collection and all its documents from Rockset.
         * @summary Delete Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollection(workspace: string, collection: string, options?: any) {
            return CollectionsApiFp(configuration).deleteCollection(workspace, collection, options)(fetch, basePath);
        },
        /**
         * Get details about a collection.
         * @summary Retrieve Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection(workspace: string, collection: string, options?: any) {
            return CollectionsApiFp(configuration).getCollection(workspace, collection, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Determines if the collection includes data at or after the specified fence
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {string} [fence] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionOffsets(workspace: string, collection: string, fence?: string, options?: any) {
            return CollectionsApiFp(configuration).getCollectionOffsets(workspace, collection, fence, options)(fetch, basePath);
        },
        /**
         * Get schema for a collection in Rockset.
         * @summary Get Collection Schema
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {number} [depth] max nested depth level to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchema(workspace: string, collection: string, depth?: number, options?: any) {
            return CollectionsApiFp(configuration).getSchema(workspace, collection, depth, options)(fetch, basePath);
        },
        /**
         * Retrieve information about source.
         * @summary Get Source config
         * @param {SourceConfigRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourceConfigs(body: SourceConfigRequest, options?: any) {
            return CollectionsApiFp(configuration).getSourceConfigs(body, options)(fetch, basePath);
        },
        /**
         * Get all Aliases for a specific Rockset Collection.
         * @summary Get Aliases for Collection
         * @param {string} workspace 
         * @param {string} collection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAliasesForCollection(workspace: string, collection: string, options?: any) {
            return CollectionsApiFp(configuration).listAliasesForCollection(workspace, collection, options)(fetch, basePath);
        },
        /**
         * Retrieve all collections in an organization.
         * @summary List Collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections(options?: any) {
            return CollectionsApiFp(configuration).listCollections(options)(fetch, basePath);
        },
        /**
         * Get all Query Lambdas that hit a specific Rockset Collection.
         * @summary Get Query Lambdas for Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdasInCollection(workspace: string, collection: string, options?: any) {
            return CollectionsApiFp(configuration).listQueryLambdasInCollection(workspace, collection, options)(fetch, basePath);
        },
        /**
         * Get sample documents given collection configuration.
         * @summary Preview Collection
         * @param {PreviewCollectionRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewCollection(body: PreviewCollectionRequest, options?: any) {
            return CollectionsApiFp(configuration).previewCollection(body, options)(fetch, basePath);
        },
        /**
         * Update state of a collection.
         * @summary Update state of Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {'READY' | 'PAUSED'} state new state of this collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCollectionState(workspace: string, collection: string, state: 'READY' | 'PAUSED', options?: any) {
            return CollectionsApiFp(configuration).setCollectionState(workspace, collection, state, options)(fetch, basePath);
        },
        /**
         * Transfer ownership of a collection to a new user.
         * @summary Transfer Ownership of a Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {TransferOwnershipRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferOwnership(workspace: string, collection: string, body: TransferOwnershipRequest, options?: any) {
            return CollectionsApiFp(configuration).transferOwnership(workspace, collection, body, options)(fetch, basePath);
        },
        /**
         * Upload a file to a collection in Rockset.
         * @summary Upload a file
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {InputStream} body file input stream
         * @param {FormDataContentDisposition} body2 file metadata
         * @param {FormDataBodyPart} [body3] file format params
         * @param {string} [body4] file size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(workspace: string, collection: string, body: InputStream, body2: FormDataContentDisposition, body3?: FormDataBodyPart, body4?: string, options?: any) {
            return CollectionsApiFp(configuration).uploadFile(workspace, collection, body, body2, body3, body4, options)(fetch, basePath);
        },
        /**
         * Upload a file to a preview source that can be used to generate preview docs
         * @summary Upload File to Preview Source
         * @param {string} preview_source_id preview source identifier
         * @param {InputStream} body file input stream
         * @param {FormDataContentDisposition} body2 file metadata
         * @param {string} [body3] file size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFilePreviewSource(preview_source_id: string, body: InputStream, body2: FormDataContentDisposition, body3?: string, options?: any) {
            return CollectionsApiFp(configuration).uploadFilePreviewSource(preview_source_id, body, body2, body3, options)(fetch, basePath);
        },
        /**
         * Retrieve all collections in a workspace.
         * @summary List Collections in Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceCollections(workspace: string, options?: any) {
            return CollectionsApiFp(configuration).workspaceCollections(workspace, options)(fetch, basePath);
        },
    };
};

/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
export class CollectionsApi extends BaseAPI {
    /**
     * Create new collection in a workspace.
     * @summary Create Collection
     * @param {string} workspace name of the workspace
     * @param {CreateCollectionRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public createCollection(workspace: string, body: CreateCollectionRequest, options?: any) {
        return CollectionsApiFp(this.configuration).createCollection(workspace, body, options)(this.fetch, this.basePath);
    }

    /**
     * Create an ephemeral source (expires after 24h) to perform preview on.
     * @summary Create Preview Source
     * @param {CreatePreviewSourceRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public createPreviewSource(body: CreatePreviewSourceRequest, options?: any) {
        return CollectionsApiFp(this.configuration).createPreviewSource(body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a collection and all its documents from Rockset.
     * @summary Delete Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public deleteCollection(workspace: string, collection: string, options?: any) {
        return CollectionsApiFp(this.configuration).deleteCollection(workspace, collection, options)(this.fetch, this.basePath);
    }

    /**
     * Get details about a collection.
     * @summary Retrieve Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getCollection(workspace: string, collection: string, options?: any) {
        return CollectionsApiFp(this.configuration).getCollection(workspace, collection, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Determines if the collection includes data at or after the specified fence
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {string} [fence] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getCollectionOffsets(workspace: string, collection: string, fence?: string, options?: any) {
        return CollectionsApiFp(this.configuration).getCollectionOffsets(workspace, collection, fence, options)(this.fetch, this.basePath);
    }

    /**
     * Get schema for a collection in Rockset.
     * @summary Get Collection Schema
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {number} [depth] max nested depth level to search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getSchema(workspace: string, collection: string, depth?: number, options?: any) {
        return CollectionsApiFp(this.configuration).getSchema(workspace, collection, depth, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve information about source.
     * @summary Get Source config
     * @param {SourceConfigRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getSourceConfigs(body: SourceConfigRequest, options?: any) {
        return CollectionsApiFp(this.configuration).getSourceConfigs(body, options)(this.fetch, this.basePath);
    }

    /**
     * Get all Aliases for a specific Rockset Collection.
     * @summary Get Aliases for Collection
     * @param {string} workspace 
     * @param {string} collection 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public listAliasesForCollection(workspace: string, collection: string, options?: any) {
        return CollectionsApiFp(this.configuration).listAliasesForCollection(workspace, collection, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all collections in an organization.
     * @summary List Collections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public listCollections(options?: any) {
        return CollectionsApiFp(this.configuration).listCollections(options)(this.fetch, this.basePath);
    }

    /**
     * Get all Query Lambdas that hit a specific Rockset Collection.
     * @summary Get Query Lambdas for Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public listQueryLambdasInCollection(workspace: string, collection: string, options?: any) {
        return CollectionsApiFp(this.configuration).listQueryLambdasInCollection(workspace, collection, options)(this.fetch, this.basePath);
    }

    /**
     * Get sample documents given collection configuration.
     * @summary Preview Collection
     * @param {PreviewCollectionRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public previewCollection(body: PreviewCollectionRequest, options?: any) {
        return CollectionsApiFp(this.configuration).previewCollection(body, options)(this.fetch, this.basePath);
    }

    /**
     * Update state of a collection.
     * @summary Update state of Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {'READY' | 'PAUSED'} state new state of this collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public setCollectionState(workspace: string, collection: string, state: 'READY' | 'PAUSED', options?: any) {
        return CollectionsApiFp(this.configuration).setCollectionState(workspace, collection, state, options)(this.fetch, this.basePath);
    }

    /**
     * Transfer ownership of a collection to a new user.
     * @summary Transfer Ownership of a Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {TransferOwnershipRequest} body JSON Object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public transferOwnership(workspace: string, collection: string, body: TransferOwnershipRequest, options?: any) {
        return CollectionsApiFp(this.configuration).transferOwnership(workspace, collection, body, options)(this.fetch, this.basePath);
    }

    /**
     * Upload a file to a collection in Rockset.
     * @summary Upload a file
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {InputStream} body file input stream
     * @param {FormDataContentDisposition} body2 file metadata
     * @param {FormDataBodyPart} [body3] file format params
     * @param {string} [body4] file size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public uploadFile(workspace: string, collection: string, body: InputStream, body2: FormDataContentDisposition, body3?: FormDataBodyPart, body4?: string, options?: any) {
        return CollectionsApiFp(this.configuration).uploadFile(workspace, collection, body, body2, body3, body4, options)(this.fetch, this.basePath);
    }

    /**
     * Upload a file to a preview source that can be used to generate preview docs
     * @summary Upload File to Preview Source
     * @param {string} preview_source_id preview source identifier
     * @param {InputStream} body file input stream
     * @param {FormDataContentDisposition} body2 file metadata
     * @param {string} [body3] file size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public uploadFilePreviewSource(preview_source_id: string, body: InputStream, body2: FormDataContentDisposition, body3?: string, options?: any) {
        return CollectionsApiFp(this.configuration).uploadFilePreviewSource(preview_source_id, body, body2, body3, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all collections in a workspace.
     * @summary List Collections in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public workspaceCollections(workspace: string, options?: any) {
        return CollectionsApiFp(this.configuration).workspaceCollections(workspace, options)(this.fetch, this.basePath);
    }

}

/**
 * ConsoleApi - fetch parameter creator
 * @export
 */
export const ConsoleApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Send confirmation email to user, send email internally, and notify internally
         * @summary Contact Sales
         * @param {ContactSalesRequest} body contact sales information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactSales(body: ContactSalesRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling contactSales.');
            }
            const localVarPath = `/v1/console/sales`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ContactSalesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Open a support ticket on behalf of the user
         * @summary Contact Support
         * @param {ContactSupportRequest} body contact sales information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactSupport(body: ContactSupportRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling contactSupport.');
            }
            const localVarPath = `/v1/console/support`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ContactSupportRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of all activity for user
         * @summary Get Activities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivity(options: any = {}): FetchArgs {
            const localVarPath = `/v1/console/activity`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Record an activity item from console.
         * @summary Record Activity
         * @param {RecordActivityRequest} body the activity item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordActivity(body: RecordActivityRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling recordActivity.');
            }
            const localVarPath = `/v1/console/activity`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RecordActivityRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConsoleApi - functional programming interface
 * @export
 */
export const ConsoleApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Send confirmation email to user, send email internally, and notify internally
         * @summary Contact Sales
         * @param {ContactSalesRequest} body contact sales information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactSales(body: ContactSalesRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StatusResponse> {
            const localVarFetchArgs = ConsoleApiFetchParamCreator(configuration).contactSales(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Open a support ticket on behalf of the user
         * @summary Contact Support
         * @param {ContactSupportRequest} body contact sales information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactSupport(body: ContactSupportRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StatusResponse> {
            const localVarFetchArgs = ConsoleApiFetchParamCreator(configuration).contactSupport(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get list of all activity for user
         * @summary Get Activities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivity(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetActivityResponse> {
            const localVarFetchArgs = ConsoleApiFetchParamCreator(configuration).getActivity(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Record an activity item from console.
         * @summary Record Activity
         * @param {RecordActivityRequest} body the activity item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordActivity(body: RecordActivityRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StatusResponse> {
            const localVarFetchArgs = ConsoleApiFetchParamCreator(configuration).recordActivity(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ConsoleApi - factory interface
 * @export
 */
export const ConsoleApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Send confirmation email to user, send email internally, and notify internally
         * @summary Contact Sales
         * @param {ContactSalesRequest} body contact sales information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactSales(body: ContactSalesRequest, options?: any) {
            return ConsoleApiFp(configuration).contactSales(body, options)(fetch, basePath);
        },
        /**
         * Open a support ticket on behalf of the user
         * @summary Contact Support
         * @param {ContactSupportRequest} body contact sales information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactSupport(body: ContactSupportRequest, options?: any) {
            return ConsoleApiFp(configuration).contactSupport(body, options)(fetch, basePath);
        },
        /**
         * Get list of all activity for user
         * @summary Get Activities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivity(options?: any) {
            return ConsoleApiFp(configuration).getActivity(options)(fetch, basePath);
        },
        /**
         * Record an activity item from console.
         * @summary Record Activity
         * @param {RecordActivityRequest} body the activity item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordActivity(body: RecordActivityRequest, options?: any) {
            return ConsoleApiFp(configuration).recordActivity(body, options)(fetch, basePath);
        },
    };
};

/**
 * ConsoleApi - object-oriented interface
 * @export
 * @class ConsoleApi
 * @extends {BaseAPI}
 */
export class ConsoleApi extends BaseAPI {
    /**
     * Send confirmation email to user, send email internally, and notify internally
     * @summary Contact Sales
     * @param {ContactSalesRequest} body contact sales information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsoleApi
     */
    public contactSales(body: ContactSalesRequest, options?: any) {
        return ConsoleApiFp(this.configuration).contactSales(body, options)(this.fetch, this.basePath);
    }

    /**
     * Open a support ticket on behalf of the user
     * @summary Contact Support
     * @param {ContactSupportRequest} body contact sales information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsoleApi
     */
    public contactSupport(body: ContactSupportRequest, options?: any) {
        return ConsoleApiFp(this.configuration).contactSupport(body, options)(this.fetch, this.basePath);
    }

    /**
     * Get list of all activity for user
     * @summary Get Activities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsoleApi
     */
    public getActivity(options?: any) {
        return ConsoleApiFp(this.configuration).getActivity(options)(this.fetch, this.basePath);
    }

    /**
     * Record an activity item from console.
     * @summary Record Activity
     * @param {RecordActivityRequest} body the activity item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsoleApi
     */
    public recordActivity(body: RecordActivityRequest, options?: any) {
        return ConsoleApiFp(this.configuration).recordActivity(body, options)(this.fetch, this.basePath);
    }

}

/**
 * CustomRolesBetaApi - fetch parameter creator
 * @export
 */
export const CustomRolesBetaApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a role for your organization.
         * @summary Create a Role
         * @param {CreateRoleRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(body: CreateRoleRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRole.');
            }
            const localVarPath = `/v1/orgs/self/roles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateRoleRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a role for your organization.
         * @summary Delete a Role
         * @param {string} roleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(roleName: string, options: any = {}): FetchArgs {
            // verify required parameter 'roleName' is not null or undefined
            if (roleName === null || roleName === undefined) {
                throw new RequiredError('roleName','Required parameter roleName was null or undefined when calling deleteRole.');
            }
            const localVarPath = `/v1/orgs/self/roles/{roleName}`
                .replace(`{${"roleName"}}`, encodeURIComponent(String(roleName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all roles for your organization.
         * @summary List Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/roles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a role for your organization.
         * @summary Update a Role
         * @param {string} roleName 
         * @param {UpdateRoleRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(roleName: string, body: UpdateRoleRequest, options: any = {}): FetchArgs {
            // verify required parameter 'roleName' is not null or undefined
            if (roleName === null || roleName === undefined) {
                throw new RequiredError('roleName','Required parameter roleName was null or undefined when calling updateRole.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateRole.');
            }
            const localVarPath = `/v1/orgs/self/roles/{roleName}`
                .replace(`{${"roleName"}}`, encodeURIComponent(String(roleName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateRoleRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomRolesBetaApi - functional programming interface
 * @export
 */
export const CustomRolesBetaApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a role for your organization.
         * @summary Create a Role
         * @param {CreateRoleRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(body: CreateRoleRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleResponse> {
            const localVarFetchArgs = CustomRolesBetaApiFetchParamCreator(configuration).createRole(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a role for your organization.
         * @summary Delete a Role
         * @param {string} roleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(roleName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleResponse> {
            const localVarFetchArgs = CustomRolesBetaApiFetchParamCreator(configuration).deleteRole(roleName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all roles for your organization.
         * @summary List Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListRolesResponse> {
            const localVarFetchArgs = CustomRolesBetaApiFetchParamCreator(configuration).listRoles(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a role for your organization.
         * @summary Update a Role
         * @param {string} roleName 
         * @param {UpdateRoleRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(roleName: string, body: UpdateRoleRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleResponse> {
            const localVarFetchArgs = CustomRolesBetaApiFetchParamCreator(configuration).updateRole(roleName, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomRolesBetaApi - factory interface
 * @export
 */
export const CustomRolesBetaApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a role for your organization.
         * @summary Create a Role
         * @param {CreateRoleRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(body: CreateRoleRequest, options?: any) {
            return CustomRolesBetaApiFp(configuration).createRole(body, options)(fetch, basePath);
        },
        /**
         * Delete a role for your organization.
         * @summary Delete a Role
         * @param {string} roleName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(roleName: string, options?: any) {
            return CustomRolesBetaApiFp(configuration).deleteRole(roleName, options)(fetch, basePath);
        },
        /**
         * List all roles for your organization.
         * @summary List Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(options?: any) {
            return CustomRolesBetaApiFp(configuration).listRoles(options)(fetch, basePath);
        },
        /**
         * Update a role for your organization.
         * @summary Update a Role
         * @param {string} roleName 
         * @param {UpdateRoleRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(roleName: string, body: UpdateRoleRequest, options?: any) {
            return CustomRolesBetaApiFp(configuration).updateRole(roleName, body, options)(fetch, basePath);
        },
    };
};

/**
 * CustomRolesBetaApi - object-oriented interface
 * @export
 * @class CustomRolesBetaApi
 * @extends {BaseAPI}
 */
export class CustomRolesBetaApi extends BaseAPI {
    /**
     * Create a role for your organization.
     * @summary Create a Role
     * @param {CreateRoleRequest} body JSON Object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesBetaApi
     */
    public createRole(body: CreateRoleRequest, options?: any) {
        return CustomRolesBetaApiFp(this.configuration).createRole(body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a role for your organization.
     * @summary Delete a Role
     * @param {string} roleName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesBetaApi
     */
    public deleteRole(roleName: string, options?: any) {
        return CustomRolesBetaApiFp(this.configuration).deleteRole(roleName, options)(this.fetch, this.basePath);
    }

    /**
     * List all roles for your organization.
     * @summary List Roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesBetaApi
     */
    public listRoles(options?: any) {
        return CustomRolesBetaApiFp(this.configuration).listRoles(options)(this.fetch, this.basePath);
    }

    /**
     * Update a role for your organization.
     * @summary Update a Role
     * @param {string} roleName 
     * @param {UpdateRoleRequest} body JSON Object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesBetaApi
     */
    public updateRole(roleName: string, body: UpdateRoleRequest, options?: any) {
        return CustomRolesBetaApiFp(this.configuration).updateRole(roleName, body, options)(this.fetch, this.basePath);
    }

}

/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiveKafkaEvent(options: any = {}): FetchArgs {
            const localVarPath = `/v1/receivers/kafka`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiveSegmentEvent(options: any = {}): FetchArgs {
            const localVarPath = `/v1/receivers/segment`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiveKafkaEvent(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).receiveKafkaEvent(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiveSegmentEvent(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).receiveSegmentEvent(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiveKafkaEvent(options?: any) {
            return DefaultApiFp(configuration).receiveKafkaEvent(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiveSegmentEvent(options?: any) {
            return DefaultApiFp(configuration).receiveSegmentEvent(options)(fetch, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public receiveKafkaEvent(options?: any) {
        return DefaultApiFp(this.configuration).receiveKafkaEvent(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public receiveSegmentEvent(options?: any) {
        return DefaultApiFp(this.configuration).receiveSegmentEvent(options)(this.fetch, this.basePath);
    }

}

/**
 * DocumentsApi - fetch parameter creator
 * @export
 */
export const DocumentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add documents to a collection.
         * @summary Add Documents
         * @param {string} workspace Name of the workspace.
         * @param {string} collection Name of the collection.
         * @param {AddDocumentsRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocuments(workspace: string, collection: string, body: AddDocumentsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling addDocuments.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling addDocuments.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addDocuments.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/docs`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddDocumentsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete documents from a collection.
         * @summary Delete Documents
         * @param {string} workspace Name of the workspace.
         * @param {string} collection Name of the collection.
         * @param {DeleteDocumentsRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocuments(workspace: string, collection: string, body: DeleteDocumentsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling deleteDocuments.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling deleteDocuments.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deleteDocuments.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/docs`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeleteDocumentsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update existing documents in a collection.
         * @summary Patch Documents
         * @param {string} workspace Name of the workspace.
         * @param {string} collection Name of the collection.
         * @param {PatchDocumentsRequest} body JSON Patch objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDocuments(workspace: string, collection: string, body: PatchDocumentsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling patchDocuments.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling patchDocuments.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchDocuments.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/docs`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PatchDocumentsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsApi - functional programming interface
 * @export
 */
export const DocumentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add documents to a collection.
         * @summary Add Documents
         * @param {string} workspace Name of the workspace.
         * @param {string} collection Name of the collection.
         * @param {AddDocumentsRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocuments(workspace: string, collection: string, body: AddDocumentsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddDocumentsResponse> {
            const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).addDocuments(workspace, collection, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete documents from a collection.
         * @summary Delete Documents
         * @param {string} workspace Name of the workspace.
         * @param {string} collection Name of the collection.
         * @param {DeleteDocumentsRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocuments(workspace: string, collection: string, body: DeleteDocumentsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteDocumentsResponse> {
            const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).deleteDocuments(workspace, collection, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update existing documents in a collection.
         * @summary Patch Documents
         * @param {string} workspace Name of the workspace.
         * @param {string} collection Name of the collection.
         * @param {PatchDocumentsRequest} body JSON Patch objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDocuments(workspace: string, collection: string, body: PatchDocumentsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PatchDocumentsResponse> {
            const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).patchDocuments(workspace, collection, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DocumentsApi - factory interface
 * @export
 */
export const DocumentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Add documents to a collection.
         * @summary Add Documents
         * @param {string} workspace Name of the workspace.
         * @param {string} collection Name of the collection.
         * @param {AddDocumentsRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocuments(workspace: string, collection: string, body: AddDocumentsRequest, options?: any) {
            return DocumentsApiFp(configuration).addDocuments(workspace, collection, body, options)(fetch, basePath);
        },
        /**
         * Delete documents from a collection.
         * @summary Delete Documents
         * @param {string} workspace Name of the workspace.
         * @param {string} collection Name of the collection.
         * @param {DeleteDocumentsRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocuments(workspace: string, collection: string, body: DeleteDocumentsRequest, options?: any) {
            return DocumentsApiFp(configuration).deleteDocuments(workspace, collection, body, options)(fetch, basePath);
        },
        /**
         * Update existing documents in a collection.
         * @summary Patch Documents
         * @param {string} workspace Name of the workspace.
         * @param {string} collection Name of the collection.
         * @param {PatchDocumentsRequest} body JSON Patch objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDocuments(workspace: string, collection: string, body: PatchDocumentsRequest, options?: any) {
            return DocumentsApiFp(configuration).patchDocuments(workspace, collection, body, options)(fetch, basePath);
        },
    };
};

/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export class DocumentsApi extends BaseAPI {
    /**
     * Add documents to a collection.
     * @summary Add Documents
     * @param {string} workspace Name of the workspace.
     * @param {string} collection Name of the collection.
     * @param {AddDocumentsRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public addDocuments(workspace: string, collection: string, body: AddDocumentsRequest, options?: any) {
        return DocumentsApiFp(this.configuration).addDocuments(workspace, collection, body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete documents from a collection.
     * @summary Delete Documents
     * @param {string} workspace Name of the workspace.
     * @param {string} collection Name of the collection.
     * @param {DeleteDocumentsRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public deleteDocuments(workspace: string, collection: string, body: DeleteDocumentsRequest, options?: any) {
        return DocumentsApiFp(this.configuration).deleteDocuments(workspace, collection, body, options)(this.fetch, this.basePath);
    }

    /**
     * Update existing documents in a collection.
     * @summary Patch Documents
     * @param {string} workspace Name of the workspace.
     * @param {string} collection Name of the collection.
     * @param {PatchDocumentsRequest} body JSON Patch objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public patchDocuments(workspace: string, collection: string, body: PatchDocumentsRequest, options?: any) {
        return DocumentsApiFp(this.configuration).patchDocuments(workspace, collection, body, options)(this.fetch, this.basePath);
    }

}

/**
 * IPAllowlistApi - fetch parameter creator
 * @export
 */
export const IPAllowlistApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new entry to allow an IP address
         * @summary Create IP Allowlist Network Policy
         * @param {CreateIpAllowlistRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowlistIp(body: CreateIpAllowlistRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createAllowlistIp.');
            }
            const localVarPath = `/v1/orgs/self/ip/allowlist`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateIpAllowlistRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an entry for IP allowlist network policy.
         * @summary Delete IP Allowlist Network Policy
         * @param {string} name name of the IP allowlist network policy
         * @param {DeleteIpAllowlistRequest} [body] JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowlistIp(name: string, body?: DeleteIpAllowlistRequest, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteAllowlistIp.');
            }
            const localVarPath = `/v1/orgs/self/ip/allowlist/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeleteIpAllowlistRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details about a IP Allowlist network policy
         * @summary Get IP Allowlist Network Policy
         * @param {string} name name of the IP Allowlist network policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowlistIp(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getAllowlistIp.');
            }
            const localVarPath = `/v1/orgs/self/ip/allowlist/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List IP Allowlist Entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllowlistIps(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/ip/allowlist`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IPAllowlistApi - functional programming interface
 * @export
 */
export const IPAllowlistApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new entry to allow an IP address
         * @summary Create IP Allowlist Network Policy
         * @param {CreateIpAllowlistRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowlistIp(body: CreateIpAllowlistRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateIpAllowlistResponse> {
            const localVarFetchArgs = IPAllowlistApiFetchParamCreator(configuration).createAllowlistIp(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an entry for IP allowlist network policy.
         * @summary Delete IP Allowlist Network Policy
         * @param {string} name name of the IP allowlist network policy
         * @param {DeleteIpAllowlistRequest} [body] JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowlistIp(name: string, body?: DeleteIpAllowlistRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteIpAllowlistResponse> {
            const localVarFetchArgs = IPAllowlistApiFetchParamCreator(configuration).deleteAllowlistIp(name, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get details about a IP Allowlist network policy
         * @summary Get IP Allowlist Network Policy
         * @param {string} name name of the IP Allowlist network policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowlistIp(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetIpAllowlistResponse> {
            const localVarFetchArgs = IPAllowlistApiFetchParamCreator(configuration).getAllowlistIp(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List IP Allowlist Entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllowlistIps(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListIpAllowlistsResponse> {
            const localVarFetchArgs = IPAllowlistApiFetchParamCreator(configuration).listAllowlistIps(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * IPAllowlistApi - factory interface
 * @export
 */
export const IPAllowlistApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new entry to allow an IP address
         * @summary Create IP Allowlist Network Policy
         * @param {CreateIpAllowlistRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAllowlistIp(body: CreateIpAllowlistRequest, options?: any) {
            return IPAllowlistApiFp(configuration).createAllowlistIp(body, options)(fetch, basePath);
        },
        /**
         * Delete an entry for IP allowlist network policy.
         * @summary Delete IP Allowlist Network Policy
         * @param {string} name name of the IP allowlist network policy
         * @param {DeleteIpAllowlistRequest} [body] JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllowlistIp(name: string, body?: DeleteIpAllowlistRequest, options?: any) {
            return IPAllowlistApiFp(configuration).deleteAllowlistIp(name, body, options)(fetch, basePath);
        },
        /**
         * Get details about a IP Allowlist network policy
         * @summary Get IP Allowlist Network Policy
         * @param {string} name name of the IP Allowlist network policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowlistIp(name: string, options?: any) {
            return IPAllowlistApiFp(configuration).getAllowlistIp(name, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List IP Allowlist Entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllowlistIps(options?: any) {
            return IPAllowlistApiFp(configuration).listAllowlistIps(options)(fetch, basePath);
        },
    };
};

/**
 * IPAllowlistApi - object-oriented interface
 * @export
 * @class IPAllowlistApi
 * @extends {BaseAPI}
 */
export class IPAllowlistApi extends BaseAPI {
    /**
     * Create a new entry to allow an IP address
     * @summary Create IP Allowlist Network Policy
     * @param {CreateIpAllowlistRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IPAllowlistApi
     */
    public createAllowlistIp(body: CreateIpAllowlistRequest, options?: any) {
        return IPAllowlistApiFp(this.configuration).createAllowlistIp(body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete an entry for IP allowlist network policy.
     * @summary Delete IP Allowlist Network Policy
     * @param {string} name name of the IP allowlist network policy
     * @param {DeleteIpAllowlistRequest} [body] JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IPAllowlistApi
     */
    public deleteAllowlistIp(name: string, body?: DeleteIpAllowlistRequest, options?: any) {
        return IPAllowlistApiFp(this.configuration).deleteAllowlistIp(name, body, options)(this.fetch, this.basePath);
    }

    /**
     * Get details about a IP Allowlist network policy
     * @summary Get IP Allowlist Network Policy
     * @param {string} name name of the IP Allowlist network policy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IPAllowlistApi
     */
    public getAllowlistIp(name: string, options?: any) {
        return IPAllowlistApiFp(this.configuration).getAllowlistIp(name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List IP Allowlist Entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IPAllowlistApi
     */
    public listAllowlistIps(options?: any) {
        return IPAllowlistApiFp(this.configuration).listAllowlistIps(options)(this.fetch, this.basePath);
    }

}

/**
 * IntegrationsApi - fetch parameter creator
 * @export
 */
export const IntegrationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new integration.
         * @summary Create Integration
         * @param {CreateIntegrationRequest} body integration credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIntegration(body: CreateIntegrationRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createIntegration.');
            }
            const localVarPath = `/v1/orgs/self/integrations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateIntegrationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an integration.
         * @summary Delete Integration
         * @param {string} integration name of the integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIntegration(integration: string, options: any = {}): FetchArgs {
            // verify required parameter 'integration' is not null or undefined
            if (integration === null || integration === undefined) {
                throw new RequiredError('integration','Required parameter integration was null or undefined when calling deleteIntegration.');
            }
            const localVarPath = `/v1/orgs/self/integrations/{integration}`
                .replace(`{${"integration"}}`, encodeURIComponent(String(integration)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information about a single integration.
         * @summary Retrieve Integration
         * @param {string} integration name of the integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegration(integration: string, options: any = {}): FetchArgs {
            // verify required parameter 'integration' is not null or undefined
            if (integration === null || integration === undefined) {
                throw new RequiredError('integration','Required parameter integration was null or undefined when calling getIntegration.');
            }
            const localVarPath = `/v1/orgs/self/integrations/{integration}`
                .replace(`{${"integration"}}`, encodeURIComponent(String(integration)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all integrations in an organization.
         * @summary List Integrations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIntegrations(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/integrations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transfer ownership of an integration to a new user.
         * @summary Transfer Ownership of an Integration
         * @param {string} integration name of the integration
         * @param {TransferOwnershipRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferOwnership(integration: string, body: TransferOwnershipRequest, options: any = {}): FetchArgs {
            // verify required parameter 'integration' is not null or undefined
            if (integration === null || integration === undefined) {
                throw new RequiredError('integration','Required parameter integration was null or undefined when calling transferOwnership.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling transferOwnership.');
            }
            const localVarPath = `/v1/orgs/self/integrations/{integration}/owner`
                .replace(`{${"integration"}}`, encodeURIComponent(String(integration)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TransferOwnershipRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify that an integration is healthy.
         * @summary Verify Integration
         * @param {string} integration name of the integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyIntegration(integration: string, options: any = {}): FetchArgs {
            // verify required parameter 'integration' is not null or undefined
            if (integration === null || integration === undefined) {
                throw new RequiredError('integration','Required parameter integration was null or undefined when calling verifyIntegration.');
            }
            const localVarPath = `/v1/orgs/self/integrations/{integration}/verifications`
                .replace(`{${"integration"}}`, encodeURIComponent(String(integration)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationsApi - functional programming interface
 * @export
 */
export const IntegrationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new integration.
         * @summary Create Integration
         * @param {CreateIntegrationRequest} body integration credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIntegration(body: CreateIntegrationRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateIntegrationResponse> {
            const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).createIntegration(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove an integration.
         * @summary Delete Integration
         * @param {string} integration name of the integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIntegration(integration: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteIntegrationResponse> {
            const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).deleteIntegration(integration, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve information about a single integration.
         * @summary Retrieve Integration
         * @param {string} integration name of the integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegration(integration: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetIntegrationResponse> {
            const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).getIntegration(integration, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all integrations in an organization.
         * @summary List Integrations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIntegrations(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListIntegrationsResponse> {
            const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).listIntegrations(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Transfer ownership of an integration to a new user.
         * @summary Transfer Ownership of an Integration
         * @param {string} integration name of the integration
         * @param {TransferOwnershipRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferOwnership(integration: string, body: TransferOwnershipRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).transferOwnership(integration, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Verify that an integration is healthy.
         * @summary Verify Integration
         * @param {string} integration name of the integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyIntegration(integration: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StatusResponse> {
            const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).verifyIntegration(integration, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * IntegrationsApi - factory interface
 * @export
 */
export const IntegrationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new integration.
         * @summary Create Integration
         * @param {CreateIntegrationRequest} body integration credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIntegration(body: CreateIntegrationRequest, options?: any) {
            return IntegrationsApiFp(configuration).createIntegration(body, options)(fetch, basePath);
        },
        /**
         * Remove an integration.
         * @summary Delete Integration
         * @param {string} integration name of the integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIntegration(integration: string, options?: any) {
            return IntegrationsApiFp(configuration).deleteIntegration(integration, options)(fetch, basePath);
        },
        /**
         * Retrieve information about a single integration.
         * @summary Retrieve Integration
         * @param {string} integration name of the integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegration(integration: string, options?: any) {
            return IntegrationsApiFp(configuration).getIntegration(integration, options)(fetch, basePath);
        },
        /**
         * List all integrations in an organization.
         * @summary List Integrations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIntegrations(options?: any) {
            return IntegrationsApiFp(configuration).listIntegrations(options)(fetch, basePath);
        },
        /**
         * Transfer ownership of an integration to a new user.
         * @summary Transfer Ownership of an Integration
         * @param {string} integration name of the integration
         * @param {TransferOwnershipRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferOwnership(integration: string, body: TransferOwnershipRequest, options?: any) {
            return IntegrationsApiFp(configuration).transferOwnership(integration, body, options)(fetch, basePath);
        },
        /**
         * Verify that an integration is healthy.
         * @summary Verify Integration
         * @param {string} integration name of the integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyIntegration(integration: string, options?: any) {
            return IntegrationsApiFp(configuration).verifyIntegration(integration, options)(fetch, basePath);
        },
    };
};

/**
 * IntegrationsApi - object-oriented interface
 * @export
 * @class IntegrationsApi
 * @extends {BaseAPI}
 */
export class IntegrationsApi extends BaseAPI {
    /**
     * Create a new integration.
     * @summary Create Integration
     * @param {CreateIntegrationRequest} body integration credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public createIntegration(body: CreateIntegrationRequest, options?: any) {
        return IntegrationsApiFp(this.configuration).createIntegration(body, options)(this.fetch, this.basePath);
    }

    /**
     * Remove an integration.
     * @summary Delete Integration
     * @param {string} integration name of the integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public deleteIntegration(integration: string, options?: any) {
        return IntegrationsApiFp(this.configuration).deleteIntegration(integration, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve information about a single integration.
     * @summary Retrieve Integration
     * @param {string} integration name of the integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getIntegration(integration: string, options?: any) {
        return IntegrationsApiFp(this.configuration).getIntegration(integration, options)(this.fetch, this.basePath);
    }

    /**
     * List all integrations in an organization.
     * @summary List Integrations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public listIntegrations(options?: any) {
        return IntegrationsApiFp(this.configuration).listIntegrations(options)(this.fetch, this.basePath);
    }

    /**
     * Transfer ownership of an integration to a new user.
     * @summary Transfer Ownership of an Integration
     * @param {string} integration name of the integration
     * @param {TransferOwnershipRequest} body JSON Object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public transferOwnership(integration: string, body: TransferOwnershipRequest, options?: any) {
        return IntegrationsApiFp(this.configuration).transferOwnership(integration, body, options)(this.fetch, this.basePath);
    }

    /**
     * Verify that an integration is healthy.
     * @summary Verify Integration
     * @param {string} integration name of the integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public verifyIntegration(integration: string, options?: any) {
        return IntegrationsApiFp(this.configuration).verifyIntegration(integration, options)(this.fetch, this.basePath);
    }

}

/**
 * OrganizationsApi - fetch parameter creator
 * @export
 */
export const OrganizationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add an organization to a new cluster.
         * @summary Add Organization to Cluster
         * @param {string} clusterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrgToCluster(clusterName: string, options: any = {}): FetchArgs {
            // verify required parameter 'clusterName' is not null or undefined
            if (clusterName === null || clusterName === undefined) {
                throw new RequiredError('clusterName','Required parameter clusterName was null or undefined when calling addOrgToCluster.');
            }
            const localVarPath = `/v1/orgs/self/clusters/{clusterName}`
                .replace(`{${"clusterName"}}`, encodeURIComponent(String(clusterName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Confirm an AWS Marketplace subscription for an organization.
         * @summary Confirm AWS Marketplace Subscription
         * @param {MarketplaceSubscriptionRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmMarketplaceSubscription(body: MarketplaceSubscriptionRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling confirmMarketplaceSubscription.');
            }
            const localVarPath = `/v1/orgs/self/billing/marketplace`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MarketplaceSubscriptionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the rate card for an organization.
         * @summary Get Rate Card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveRateCard(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/billing/cards`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all billing line items for a specified month and year.
         * @summary Retrieve billing line items.
         * @param {number} [month] 
         * @param {number} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillingLineItems(month?: number, year?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/billing/lineitems`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the redirect to customer billing portal.
         * @summary Retrieve customer billing portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillingPortal(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/billing`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get metrics for all VIs with metrics enabled.
         * @summary Get metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/metrics`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information about current organization.
         * @summary Get Organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve usage levels for current organization.
         * @summary Get Organization Compute Time-Series data
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCompute(month?: string, year?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/usage/compute`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve usage levels for current organization.
         * @summary Get Organization ingest usage data
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationIngest(month?: string, year?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/usage/ingest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve settings for current organization.
         * @summary Get Organization Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSettings(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/settings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve usage levels for current organization.
         * @summary Get Organization Storage Time-Series data
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationStorage(month?: string, year?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/usage/storage`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve usage levels for current organization.
         * @summary Get Organization trial credit usage data
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationTrialCredit(month?: string, year?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/usage/trial`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve usage levels for current organization.
         * @summary Get Organization Usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUsage(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/usage`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the payment information for your organization.
         * @summary Retrieve payment information about payment method
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethod(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/payment/method`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get stored payment information for your organization.
         * @summary Retrieve payment information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentSource(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/payment/invoices`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get stored sso information for your organization.
         * @summary Retrieve sso settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSsoSettings(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/sso`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch time series metrics, for a specified VI, time interval, and granularity.
         * @summary Get time series metrics.
         * @param {string} [virtual_instance_id] 
         * @param {'COLLECTION' | 'QUERY_LAMBDA' | 'VIRTUAL_INSTANCE' | 'VIRTUAL_INSTANCE_QUERY' | 'VIRTUAL_INSTANCE_STORAGE' | 'SLOW_QUERY_COUNT' | 'SLOW_QUERIES' | 'PERCENTILE_QUERY_LATENCY' | 'QUERY_COUNT' | 'COLLECTION_BULK_INGEST_CPU'} [metric_type] 
         * @param {number} [start] 
         * @param {number} [end] 
         * @param {number} [granularity] 
         * @param {number} [limit] 
         * @param {string} [collection_path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeSeriesMetrics(virtual_instance_id?: string, metric_type?: 'COLLECTION' | 'QUERY_LAMBDA' | 'VIRTUAL_INSTANCE' | 'VIRTUAL_INSTANCE_QUERY' | 'VIRTUAL_INSTANCE_STORAGE' | 'SLOW_QUERY_COUNT' | 'SLOW_QUERIES' | 'PERCENTILE_QUERY_LATENCY' | 'QUERY_COUNT' | 'COLLECTION_BULK_INGEST_CPU', start?: number, end?: number, granularity?: number, limit?: number, collection_path?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/metrics/timeSeries`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (virtual_instance_id !== undefined) {
                localVarQueryParameter['virtual_instance_id'] = virtual_instance_id;
            }

            if (metric_type !== undefined) {
                localVarQueryParameter['metric_type'] = metric_type;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (granularity !== undefined) {
                localVarQueryParameter['granularity'] = granularity;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (collection_path !== undefined) {
                localVarQueryParameter['collection_path'] = collection_path;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all credits for an organization.
         * @summary Retrieve credits.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredits(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/billing/credits`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update MFA settings for your organization.
         * @summary Update MFA settings
         * @param {UpdateOrgMfaSettingsRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMfaSettings(body: UpdateOrgMfaSettingsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateMfaSettings.');
            }
            const localVarPath = `/v1/orgs/self/mfa`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateOrgMfaSettingsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update payment settings with new Stripe Source id.
         * @summary Update Payment Information
         * @param {UpdateOrgPaymentMethodRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentSource(body: UpdateOrgPaymentMethodRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updatePaymentSource.');
            }
            const localVarPath = `/v1/orgs/self/payment/method`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateOrgPaymentMethodRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update SSO settings with certificates and redirect links.
         * @summary Update SSO settings
         * @param {UpdateSsoRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSsoSettings(body: UpdateSsoRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateSsoSettings.');
            }
            const localVarPath = `/v1/orgs/self/sso`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateSsoRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add an organization to a new cluster.
         * @summary Add Organization to Cluster
         * @param {string} clusterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrgToCluster(clusterName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).addOrgToCluster(clusterName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Confirm an AWS Marketplace subscription for an organization.
         * @summary Confirm AWS Marketplace Subscription
         * @param {MarketplaceSubscriptionRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmMarketplaceSubscription(body: MarketplaceSubscriptionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).confirmMarketplaceSubscription(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the rate card for an organization.
         * @summary Get Rate Card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveRateCard(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RateCardResponse> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getActiveRateCard(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all billing line items for a specified month and year.
         * @summary Retrieve billing line items.
         * @param {number} [month] 
         * @param {number} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillingLineItems(month?: number, year?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LineItemsResponse> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getBillingLineItems(month, year, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the redirect to customer billing portal.
         * @summary Retrieve customer billing portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillingPortal(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrgBillingPortalResponse> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getBillingPortal(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get metrics for all VIs with metrics enabled.
         * @summary Get metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getMetrics(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve information about current organization.
         * @summary Get Organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrganizationResponse> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getOrganization(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve usage levels for current organization.
         * @summary Get Organization Compute Time-Series data
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCompute(month?: string, year?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrgComputeResponse> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getOrganizationCompute(month, year, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve usage levels for current organization.
         * @summary Get Organization ingest usage data
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationIngest(month?: string, year?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrgIngestResponse> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getOrganizationIngest(month, year, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve settings for current organization.
         * @summary Get Organization Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSettings(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrgSettingsResponse> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getOrganizationSettings(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve usage levels for current organization.
         * @summary Get Organization Storage Time-Series data
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationStorage(month?: string, year?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrgStorageResponse> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getOrganizationStorage(month, year, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve usage levels for current organization.
         * @summary Get Organization trial credit usage data
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationTrialCredit(month?: string, year?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrgTrialUsageResponse> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getOrganizationTrialCredit(month, year, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve usage levels for current organization.
         * @summary Get Organization Usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUsage(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrgUsageResponse> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getOrganizationUsage(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the payment information for your organization.
         * @summary Retrieve payment information about payment method
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethod(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrgPaymentMethodResponse> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getPaymentMethod(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get stored payment information for your organization.
         * @summary Retrieve payment information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentSource(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrgInvoicesResponse> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getPaymentSource(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get stored sso information for your organization.
         * @summary Retrieve sso settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSsoSettings(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrgSettingsResponse> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getSsoSettings(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch time series metrics, for a specified VI, time interval, and granularity.
         * @summary Get time series metrics.
         * @param {string} [virtual_instance_id] 
         * @param {'COLLECTION' | 'QUERY_LAMBDA' | 'VIRTUAL_INSTANCE' | 'VIRTUAL_INSTANCE_QUERY' | 'VIRTUAL_INSTANCE_STORAGE' | 'SLOW_QUERY_COUNT' | 'SLOW_QUERIES' | 'PERCENTILE_QUERY_LATENCY' | 'QUERY_COUNT' | 'COLLECTION_BULK_INGEST_CPU'} [metric_type] 
         * @param {number} [start] 
         * @param {number} [end] 
         * @param {number} [granularity] 
         * @param {number} [limit] 
         * @param {string} [collection_path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeSeriesMetrics(virtual_instance_id?: string, metric_type?: 'COLLECTION' | 'QUERY_LAMBDA' | 'VIRTUAL_INSTANCE' | 'VIRTUAL_INSTANCE_QUERY' | 'VIRTUAL_INSTANCE_STORAGE' | 'SLOW_QUERY_COUNT' | 'SLOW_QUERIES' | 'PERCENTILE_QUERY_LATENCY' | 'QUERY_COUNT' | 'COLLECTION_BULK_INGEST_CPU', start?: number, end?: number, granularity?: number, limit?: number, collection_path?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TimeSeriesMetricsResponse> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getTimeSeriesMetrics(virtual_instance_id, metric_type, start, end, granularity, limit, collection_path, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all credits for an organization.
         * @summary Retrieve credits.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredits(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListCreditsResponse> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).listCredits(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update MFA settings for your organization.
         * @summary Update MFA settings
         * @param {UpdateOrgMfaSettingsRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMfaSettings(body: UpdateOrgMfaSettingsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrgSettingsResponse> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).updateMfaSettings(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update payment settings with new Stripe Source id.
         * @summary Update Payment Information
         * @param {UpdateOrgPaymentMethodRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentSource(body: UpdateOrgPaymentMethodRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrgPaymentMethodResponse> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).updatePaymentSource(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update SSO settings with certificates and redirect links.
         * @summary Update SSO settings
         * @param {UpdateSsoRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSsoSettings(body: UpdateSsoRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrgSettingsResponse> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).updateSsoSettings(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Add an organization to a new cluster.
         * @summary Add Organization to Cluster
         * @param {string} clusterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrgToCluster(clusterName: string, options?: any) {
            return OrganizationsApiFp(configuration).addOrgToCluster(clusterName, options)(fetch, basePath);
        },
        /**
         * Confirm an AWS Marketplace subscription for an organization.
         * @summary Confirm AWS Marketplace Subscription
         * @param {MarketplaceSubscriptionRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmMarketplaceSubscription(body: MarketplaceSubscriptionRequest, options?: any) {
            return OrganizationsApiFp(configuration).confirmMarketplaceSubscription(body, options)(fetch, basePath);
        },
        /**
         * Get the rate card for an organization.
         * @summary Get Rate Card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveRateCard(options?: any) {
            return OrganizationsApiFp(configuration).getActiveRateCard(options)(fetch, basePath);
        },
        /**
         * List all billing line items for a specified month and year.
         * @summary Retrieve billing line items.
         * @param {number} [month] 
         * @param {number} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillingLineItems(month?: number, year?: number, options?: any) {
            return OrganizationsApiFp(configuration).getBillingLineItems(month, year, options)(fetch, basePath);
        },
        /**
         * Get the redirect to customer billing portal.
         * @summary Retrieve customer billing portal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBillingPortal(options?: any) {
            return OrganizationsApiFp(configuration).getBillingPortal(options)(fetch, basePath);
        },
        /**
         * Get metrics for all VIs with metrics enabled.
         * @summary Get metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(options?: any) {
            return OrganizationsApiFp(configuration).getMetrics(options)(fetch, basePath);
        },
        /**
         * Retrieve information about current organization.
         * @summary Get Organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(options?: any) {
            return OrganizationsApiFp(configuration).getOrganization(options)(fetch, basePath);
        },
        /**
         * Retrieve usage levels for current organization.
         * @summary Get Organization Compute Time-Series data
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCompute(month?: string, year?: string, options?: any) {
            return OrganizationsApiFp(configuration).getOrganizationCompute(month, year, options)(fetch, basePath);
        },
        /**
         * Retrieve usage levels for current organization.
         * @summary Get Organization ingest usage data
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationIngest(month?: string, year?: string, options?: any) {
            return OrganizationsApiFp(configuration).getOrganizationIngest(month, year, options)(fetch, basePath);
        },
        /**
         * Retrieve settings for current organization.
         * @summary Get Organization Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSettings(options?: any) {
            return OrganizationsApiFp(configuration).getOrganizationSettings(options)(fetch, basePath);
        },
        /**
         * Retrieve usage levels for current organization.
         * @summary Get Organization Storage Time-Series data
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationStorage(month?: string, year?: string, options?: any) {
            return OrganizationsApiFp(configuration).getOrganizationStorage(month, year, options)(fetch, basePath);
        },
        /**
         * Retrieve usage levels for current organization.
         * @summary Get Organization trial credit usage data
         * @param {string} [month] 
         * @param {string} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationTrialCredit(month?: string, year?: string, options?: any) {
            return OrganizationsApiFp(configuration).getOrganizationTrialCredit(month, year, options)(fetch, basePath);
        },
        /**
         * Retrieve usage levels for current organization.
         * @summary Get Organization Usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUsage(options?: any) {
            return OrganizationsApiFp(configuration).getOrganizationUsage(options)(fetch, basePath);
        },
        /**
         * Get the payment information for your organization.
         * @summary Retrieve payment information about payment method
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethod(options?: any) {
            return OrganizationsApiFp(configuration).getPaymentMethod(options)(fetch, basePath);
        },
        /**
         * Get stored payment information for your organization.
         * @summary Retrieve payment information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentSource(options?: any) {
            return OrganizationsApiFp(configuration).getPaymentSource(options)(fetch, basePath);
        },
        /**
         * Get stored sso information for your organization.
         * @summary Retrieve sso settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSsoSettings(options?: any) {
            return OrganizationsApiFp(configuration).getSsoSettings(options)(fetch, basePath);
        },
        /**
         * Fetch time series metrics, for a specified VI, time interval, and granularity.
         * @summary Get time series metrics.
         * @param {string} [virtual_instance_id] 
         * @param {'COLLECTION' | 'QUERY_LAMBDA' | 'VIRTUAL_INSTANCE' | 'VIRTUAL_INSTANCE_QUERY' | 'VIRTUAL_INSTANCE_STORAGE' | 'SLOW_QUERY_COUNT' | 'SLOW_QUERIES' | 'PERCENTILE_QUERY_LATENCY' | 'QUERY_COUNT' | 'COLLECTION_BULK_INGEST_CPU'} [metric_type] 
         * @param {number} [start] 
         * @param {number} [end] 
         * @param {number} [granularity] 
         * @param {number} [limit] 
         * @param {string} [collection_path] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeSeriesMetrics(virtual_instance_id?: string, metric_type?: 'COLLECTION' | 'QUERY_LAMBDA' | 'VIRTUAL_INSTANCE' | 'VIRTUAL_INSTANCE_QUERY' | 'VIRTUAL_INSTANCE_STORAGE' | 'SLOW_QUERY_COUNT' | 'SLOW_QUERIES' | 'PERCENTILE_QUERY_LATENCY' | 'QUERY_COUNT' | 'COLLECTION_BULK_INGEST_CPU', start?: number, end?: number, granularity?: number, limit?: number, collection_path?: string, options?: any) {
            return OrganizationsApiFp(configuration).getTimeSeriesMetrics(virtual_instance_id, metric_type, start, end, granularity, limit, collection_path, options)(fetch, basePath);
        },
        /**
         * List all credits for an organization.
         * @summary Retrieve credits.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredits(options?: any) {
            return OrganizationsApiFp(configuration).listCredits(options)(fetch, basePath);
        },
        /**
         * Update MFA settings for your organization.
         * @summary Update MFA settings
         * @param {UpdateOrgMfaSettingsRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMfaSettings(body: UpdateOrgMfaSettingsRequest, options?: any) {
            return OrganizationsApiFp(configuration).updateMfaSettings(body, options)(fetch, basePath);
        },
        /**
         * Update payment settings with new Stripe Source id.
         * @summary Update Payment Information
         * @param {UpdateOrgPaymentMethodRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentSource(body: UpdateOrgPaymentMethodRequest, options?: any) {
            return OrganizationsApiFp(configuration).updatePaymentSource(body, options)(fetch, basePath);
        },
        /**
         * Update SSO settings with certificates and redirect links.
         * @summary Update SSO settings
         * @param {UpdateSsoRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSsoSettings(body: UpdateSsoRequest, options?: any) {
            return OrganizationsApiFp(configuration).updateSsoSettings(body, options)(fetch, basePath);
        },
    };
};

/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI {
    /**
     * Add an organization to a new cluster.
     * @summary Add Organization to Cluster
     * @param {string} clusterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public addOrgToCluster(clusterName: string, options?: any) {
        return OrganizationsApiFp(this.configuration).addOrgToCluster(clusterName, options)(this.fetch, this.basePath);
    }

    /**
     * Confirm an AWS Marketplace subscription for an organization.
     * @summary Confirm AWS Marketplace Subscription
     * @param {MarketplaceSubscriptionRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public confirmMarketplaceSubscription(body: MarketplaceSubscriptionRequest, options?: any) {
        return OrganizationsApiFp(this.configuration).confirmMarketplaceSubscription(body, options)(this.fetch, this.basePath);
    }

    /**
     * Get the rate card for an organization.
     * @summary Get Rate Card
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getActiveRateCard(options?: any) {
        return OrganizationsApiFp(this.configuration).getActiveRateCard(options)(this.fetch, this.basePath);
    }

    /**
     * List all billing line items for a specified month and year.
     * @summary Retrieve billing line items.
     * @param {number} [month] 
     * @param {number} [year] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getBillingLineItems(month?: number, year?: number, options?: any) {
        return OrganizationsApiFp(this.configuration).getBillingLineItems(month, year, options)(this.fetch, this.basePath);
    }

    /**
     * Get the redirect to customer billing portal.
     * @summary Retrieve customer billing portal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getBillingPortal(options?: any) {
        return OrganizationsApiFp(this.configuration).getBillingPortal(options)(this.fetch, this.basePath);
    }

    /**
     * Get metrics for all VIs with metrics enabled.
     * @summary Get metrics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getMetrics(options?: any) {
        return OrganizationsApiFp(this.configuration).getMetrics(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve information about current organization.
     * @summary Get Organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganization(options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganization(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve usage levels for current organization.
     * @summary Get Organization Compute Time-Series data
     * @param {string} [month] 
     * @param {string} [year] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationCompute(month?: string, year?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganizationCompute(month, year, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve usage levels for current organization.
     * @summary Get Organization ingest usage data
     * @param {string} [month] 
     * @param {string} [year] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationIngest(month?: string, year?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganizationIngest(month, year, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve settings for current organization.
     * @summary Get Organization Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationSettings(options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganizationSettings(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve usage levels for current organization.
     * @summary Get Organization Storage Time-Series data
     * @param {string} [month] 
     * @param {string} [year] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationStorage(month?: string, year?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganizationStorage(month, year, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve usage levels for current organization.
     * @summary Get Organization trial credit usage data
     * @param {string} [month] 
     * @param {string} [year] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationTrialCredit(month?: string, year?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganizationTrialCredit(month, year, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve usage levels for current organization.
     * @summary Get Organization Usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganizationUsage(options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganizationUsage(options)(this.fetch, this.basePath);
    }

    /**
     * Get the payment information for your organization.
     * @summary Retrieve payment information about payment method
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getPaymentMethod(options?: any) {
        return OrganizationsApiFp(this.configuration).getPaymentMethod(options)(this.fetch, this.basePath);
    }

    /**
     * Get stored payment information for your organization.
     * @summary Retrieve payment information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getPaymentSource(options?: any) {
        return OrganizationsApiFp(this.configuration).getPaymentSource(options)(this.fetch, this.basePath);
    }

    /**
     * Get stored sso information for your organization.
     * @summary Retrieve sso settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getSsoSettings(options?: any) {
        return OrganizationsApiFp(this.configuration).getSsoSettings(options)(this.fetch, this.basePath);
    }

    /**
     * Fetch time series metrics, for a specified VI, time interval, and granularity.
     * @summary Get time series metrics.
     * @param {string} [virtual_instance_id] 
     * @param {'COLLECTION' | 'QUERY_LAMBDA' | 'VIRTUAL_INSTANCE' | 'VIRTUAL_INSTANCE_QUERY' | 'VIRTUAL_INSTANCE_STORAGE' | 'SLOW_QUERY_COUNT' | 'SLOW_QUERIES' | 'PERCENTILE_QUERY_LATENCY' | 'QUERY_COUNT' | 'COLLECTION_BULK_INGEST_CPU'} [metric_type] 
     * @param {number} [start] 
     * @param {number} [end] 
     * @param {number} [granularity] 
     * @param {number} [limit] 
     * @param {string} [collection_path] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getTimeSeriesMetrics(virtual_instance_id?: string, metric_type?: 'COLLECTION' | 'QUERY_LAMBDA' | 'VIRTUAL_INSTANCE' | 'VIRTUAL_INSTANCE_QUERY' | 'VIRTUAL_INSTANCE_STORAGE' | 'SLOW_QUERY_COUNT' | 'SLOW_QUERIES' | 'PERCENTILE_QUERY_LATENCY' | 'QUERY_COUNT' | 'COLLECTION_BULK_INGEST_CPU', start?: number, end?: number, granularity?: number, limit?: number, collection_path?: string, options?: any) {
        return OrganizationsApiFp(this.configuration).getTimeSeriesMetrics(virtual_instance_id, metric_type, start, end, granularity, limit, collection_path, options)(this.fetch, this.basePath);
    }

    /**
     * List all credits for an organization.
     * @summary Retrieve credits.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listCredits(options?: any) {
        return OrganizationsApiFp(this.configuration).listCredits(options)(this.fetch, this.basePath);
    }

    /**
     * Update MFA settings for your organization.
     * @summary Update MFA settings
     * @param {UpdateOrgMfaSettingsRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public updateMfaSettings(body: UpdateOrgMfaSettingsRequest, options?: any) {
        return OrganizationsApiFp(this.configuration).updateMfaSettings(body, options)(this.fetch, this.basePath);
    }

    /**
     * Update payment settings with new Stripe Source id.
     * @summary Update Payment Information
     * @param {UpdateOrgPaymentMethodRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public updatePaymentSource(body: UpdateOrgPaymentMethodRequest, options?: any) {
        return OrganizationsApiFp(this.configuration).updatePaymentSource(body, options)(this.fetch, this.basePath);
    }

    /**
     * Update SSO settings with certificates and redirect links.
     * @summary Update SSO settings
     * @param {UpdateSsoRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public updateSsoSettings(body: UpdateSsoRequest, options?: any) {
        return OrganizationsApiFp(this.configuration).updateSsoSettings(body, options)(this.fetch, this.basePath);
    }

}

/**
 * ProvisionApi - fetch parameter creator
 * @export
 */
export const ProvisionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Provision an organization
         * @param {CreateOrganizationRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provisionOrganization(body: CreateOrganizationRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling provisionOrganization.');
            }
            const localVarPath = `/v1/provision/orgs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateOrganizationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Provision a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provisionUser(options: any = {}): FetchArgs {
            const localVarPath = `/v1/provision/orgs/self/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resend verification email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail(options: any = {}): FetchArgs {
            const localVarPath = `/v1/provision/orgs/self/verification/email`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProvisionApi - functional programming interface
 * @export
 */
export const ProvisionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Provision an organization
         * @param {CreateOrganizationRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provisionOrganization(body: CreateOrganizationRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProvisionApiFetchParamCreator(configuration).provisionOrganization(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Provision a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provisionUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProvisionApiFetchParamCreator(configuration).provisionUser(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Resend verification email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProvisionApiFetchParamCreator(configuration).verifyEmail(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProvisionApi - factory interface
 * @export
 */
export const ProvisionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Provision an organization
         * @param {CreateOrganizationRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provisionOrganization(body: CreateOrganizationRequest, options?: any) {
            return ProvisionApiFp(configuration).provisionOrganization(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Provision a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        provisionUser(options?: any) {
            return ProvisionApiFp(configuration).provisionUser(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Resend verification email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail(options?: any) {
            return ProvisionApiFp(configuration).verifyEmail(options)(fetch, basePath);
        },
    };
};

/**
 * ProvisionApi - object-oriented interface
 * @export
 * @class ProvisionApi
 * @extends {BaseAPI}
 */
export class ProvisionApi extends BaseAPI {
    /**
     * 
     * @summary Provision an organization
     * @param {CreateOrganizationRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisionApi
     */
    public provisionOrganization(body: CreateOrganizationRequest, options?: any) {
        return ProvisionApiFp(this.configuration).provisionOrganization(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Provision a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisionApi
     */
    public provisionUser(options?: any) {
        return ProvisionApiFp(this.configuration).provisionUser(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Resend verification email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisionApi
     */
    public verifyEmail(options?: any) {
        return ProvisionApiFp(this.configuration).verifyEmail(options)(this.fetch, this.basePath);
    }

}

/**
 * QueriesApi - fetch parameter creator
 * @export
 */
export const QueriesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns information for a query
         * @summary Get information for a query
         * @param {string} queryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuery(queryId: string, options: any = {}): FetchArgs {
            // verify required parameter 'queryId' is not null or undefined
            if (queryId === null || queryId === undefined) {
                throw new RequiredError('queryId','Required parameter queryId was null or undefined when calling getQuery.');
            }
            const localVarPath = `/v1/orgs/self/queries/{queryId}`
                .replace(`{${"queryId"}}`, encodeURIComponent(String(queryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch paginated query results
         * @param {string} queryId 
         * @param {string} cursor 
         * @param {number} [docs] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryPagination(queryId: string, cursor: string, docs?: number, offset?: number, options: any = {}): FetchArgs {
            // verify required parameter 'queryId' is not null or undefined
            if (queryId === null || queryId === undefined) {
                throw new RequiredError('queryId','Required parameter queryId was null or undefined when calling getQueryPagination.');
            }
            // verify required parameter 'cursor' is not null or undefined
            if (cursor === null || cursor === undefined) {
                throw new RequiredError('cursor','Required parameter cursor was null or undefined when calling getQueryPagination.');
            }
            const localVarPath = `/v1/orgs/self/queries/{queryId}/pages/{cursor}`
                .replace(`{${"queryId"}}`, encodeURIComponent(String(queryId)))
                .replace(`{${"cursor"}}`, encodeURIComponent(String(cursor)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (docs !== undefined) {
                localVarQueryParameter['docs'] = docs;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a query plan from Rockset's planner for a given SQL query.
         * @summary Plan Query
         * @param {QueryRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryPlan(body: QueryRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getQueryPlan.');
            }
            const localVarPath = `/v1/orgs/self/queries/plans`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QueryRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch execution statistics for a particular query.
         * @summary Fetch Query Stats
         * @param {string} queryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryStats(queryId: string, options: any = {}): FetchArgs {
            // verify required parameter 'queryId' is not null or undefined
            if (queryId === null || queryId === undefined) {
                throw new RequiredError('queryId','Required parameter queryId was null or undefined when calling getQueryStats.');
            }
            const localVarPath = `/v1/orgs/self/queries/{queryId}/stats`
                .replace(`{${"queryId"}}`, encodeURIComponent(String(queryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists data about ongoing queries.
         * @summary List all query pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllQueryPages(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/queries`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists data about this queries pages.
         * @summary Get pages for a query
         * @param {string} queryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryPages(queryId: string, options: any = {}): FetchArgs {
            // verify required parameter 'queryId' is not null or undefined
            if (queryId === null || queryId === undefined) {
                throw new RequiredError('queryId','Required parameter queryId was null or undefined when calling listQueryPages.');
            }
            const localVarPath = `/v1/orgs/self/queries/{queryId}/pages`
                .replace(`{${"queryId"}}`, encodeURIComponent(String(queryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Make a SQL query to Rockset.
         * @summary Query
         * @param {QueryRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        query(body: QueryRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling query.');
            }
            const localVarPath = `/v1/orgs/self/queries`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QueryRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate a SQL query with Rockset's parser and planner.
         * @summary Validate Query
         * @param {QueryRequest} body JSON object
         * @param {boolean} [parameters] 
         * @param {boolean} [allow_undefined_parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validate(body: QueryRequest, parameters?: boolean, allow_undefined_parameters?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling validate.');
            }
            const localVarPath = `/v1/orgs/self/queries/validations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parameters !== undefined) {
                localVarQueryParameter['parameters'] = parameters;
            }

            if (allow_undefined_parameters !== undefined) {
                localVarQueryParameter['allow_undefined_parameters'] = allow_undefined_parameters;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QueryRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate a SQL Expression with Rockset's parser and planner.
         * @summary Validate Expression
         * @param {ValidateExpressionRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateExpression(body: ValidateExpressionRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling validateExpression.');
            }
            const localVarPath = `/v1/orgs/self/queries/validateExpression`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ValidateExpressionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate field mapping query with Rockset's parser and planner.
         * @summary Validate field mapping query
         * @param {ValidateFieldMappingQueryRequest} body SQL query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateFieldMappingQuery(body: ValidateFieldMappingQueryRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling validateFieldMappingQuery.');
            }
            const localVarPath = `/v1/orgs/self/queries/validateMappings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ValidateFieldMappingQueryRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueriesApi - functional programming interface
 * @export
 */
export const QueriesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns information for a query
         * @summary Get information for a query
         * @param {string} queryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuery(queryId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryResponse> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).getQuery(queryId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Fetch paginated query results
         * @param {string} queryId 
         * @param {string} cursor 
         * @param {number} [docs] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryPagination(queryId: string, cursor: string, docs?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryPaginationResponse> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).getQueryPagination(queryId, cursor, docs, offset, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch a query plan from Rockset's planner for a given SQL query.
         * @summary Plan Query
         * @param {QueryRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryPlan(body: QueryRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryResponse> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).getQueryPlan(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch execution statistics for a particular query.
         * @summary Fetch Query Stats
         * @param {string} queryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryStats(queryId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryStatsResponse> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).getQueryStats(queryId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists data about ongoing queries.
         * @summary List all query pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllQueryPages(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListAllQueryPagesResponse> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).listAllQueryPages(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lists data about this queries pages.
         * @summary Get pages for a query
         * @param {string} queryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryPages(queryId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueryPagesResponse> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).listQueryPages(queryId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Make a SQL query to Rockset.
         * @summary Query
         * @param {QueryRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        query(body: QueryRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryResponse> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).query(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Validate a SQL query with Rockset's parser and planner.
         * @summary Validate Query
         * @param {QueryRequest} body JSON object
         * @param {boolean} [parameters] 
         * @param {boolean} [allow_undefined_parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validate(body: QueryRequest, parameters?: boolean, allow_undefined_parameters?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ValidateQueryResponse> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).validate(body, parameters, allow_undefined_parameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Validate a SQL Expression with Rockset's parser and planner.
         * @summary Validate Expression
         * @param {ValidateExpressionRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateExpression(body: ValidateExpressionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ValidateExpressionResponse> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).validateExpression(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Validate field mapping query with Rockset's parser and planner.
         * @summary Validate field mapping query
         * @param {ValidateFieldMappingQueryRequest} body SQL query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateFieldMappingQuery(body: ValidateFieldMappingQueryRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ValidateFieldMappingQueryResponse> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).validateFieldMappingQuery(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QueriesApi - factory interface
 * @export
 */
export const QueriesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns information for a query
         * @summary Get information for a query
         * @param {string} queryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuery(queryId: string, options?: any) {
            return QueriesApiFp(configuration).getQuery(queryId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetch paginated query results
         * @param {string} queryId 
         * @param {string} cursor 
         * @param {number} [docs] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryPagination(queryId: string, cursor: string, docs?: number, offset?: number, options?: any) {
            return QueriesApiFp(configuration).getQueryPagination(queryId, cursor, docs, offset, options)(fetch, basePath);
        },
        /**
         * Fetch a query plan from Rockset's planner for a given SQL query.
         * @summary Plan Query
         * @param {QueryRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryPlan(body: QueryRequest, options?: any) {
            return QueriesApiFp(configuration).getQueryPlan(body, options)(fetch, basePath);
        },
        /**
         * Fetch execution statistics for a particular query.
         * @summary Fetch Query Stats
         * @param {string} queryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryStats(queryId: string, options?: any) {
            return QueriesApiFp(configuration).getQueryStats(queryId, options)(fetch, basePath);
        },
        /**
         * Lists data about ongoing queries.
         * @summary List all query pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllQueryPages(options?: any) {
            return QueriesApiFp(configuration).listAllQueryPages(options)(fetch, basePath);
        },
        /**
         * Lists data about this queries pages.
         * @summary Get pages for a query
         * @param {string} queryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryPages(queryId: string, options?: any) {
            return QueriesApiFp(configuration).listQueryPages(queryId, options)(fetch, basePath);
        },
        /**
         * Make a SQL query to Rockset.
         * @summary Query
         * @param {QueryRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        query(body: QueryRequest, options?: any) {
            return QueriesApiFp(configuration).query(body, options)(fetch, basePath);
        },
        /**
         * Validate a SQL query with Rockset's parser and planner.
         * @summary Validate Query
         * @param {QueryRequest} body JSON object
         * @param {boolean} [parameters] 
         * @param {boolean} [allow_undefined_parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validate(body: QueryRequest, parameters?: boolean, allow_undefined_parameters?: boolean, options?: any) {
            return QueriesApiFp(configuration).validate(body, parameters, allow_undefined_parameters, options)(fetch, basePath);
        },
        /**
         * Validate a SQL Expression with Rockset's parser and planner.
         * @summary Validate Expression
         * @param {ValidateExpressionRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateExpression(body: ValidateExpressionRequest, options?: any) {
            return QueriesApiFp(configuration).validateExpression(body, options)(fetch, basePath);
        },
        /**
         * Validate field mapping query with Rockset's parser and planner.
         * @summary Validate field mapping query
         * @param {ValidateFieldMappingQueryRequest} body SQL query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateFieldMappingQuery(body: ValidateFieldMappingQueryRequest, options?: any) {
            return QueriesApiFp(configuration).validateFieldMappingQuery(body, options)(fetch, basePath);
        },
    };
};

/**
 * QueriesApi - object-oriented interface
 * @export
 * @class QueriesApi
 * @extends {BaseAPI}
 */
export class QueriesApi extends BaseAPI {
    /**
     * Returns information for a query
     * @summary Get information for a query
     * @param {string} queryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public getQuery(queryId: string, options?: any) {
        return QueriesApiFp(this.configuration).getQuery(queryId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Fetch paginated query results
     * @param {string} queryId 
     * @param {string} cursor 
     * @param {number} [docs] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public getQueryPagination(queryId: string, cursor: string, docs?: number, offset?: number, options?: any) {
        return QueriesApiFp(this.configuration).getQueryPagination(queryId, cursor, docs, offset, options)(this.fetch, this.basePath);
    }

    /**
     * Fetch a query plan from Rockset's planner for a given SQL query.
     * @summary Plan Query
     * @param {QueryRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public getQueryPlan(body: QueryRequest, options?: any) {
        return QueriesApiFp(this.configuration).getQueryPlan(body, options)(this.fetch, this.basePath);
    }

    /**
     * Fetch execution statistics for a particular query.
     * @summary Fetch Query Stats
     * @param {string} queryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public getQueryStats(queryId: string, options?: any) {
        return QueriesApiFp(this.configuration).getQueryStats(queryId, options)(this.fetch, this.basePath);
    }

    /**
     * Lists data about ongoing queries.
     * @summary List all query pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public listAllQueryPages(options?: any) {
        return QueriesApiFp(this.configuration).listAllQueryPages(options)(this.fetch, this.basePath);
    }

    /**
     * Lists data about this queries pages.
     * @summary Get pages for a query
     * @param {string} queryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public listQueryPages(queryId: string, options?: any) {
        return QueriesApiFp(this.configuration).listQueryPages(queryId, options)(this.fetch, this.basePath);
    }

    /**
     * Make a SQL query to Rockset.
     * @summary Query
     * @param {QueryRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public query(body: QueryRequest, options?: any) {
        return QueriesApiFp(this.configuration).query(body, options)(this.fetch, this.basePath);
    }

    /**
     * Validate a SQL query with Rockset's parser and planner.
     * @summary Validate Query
     * @param {QueryRequest} body JSON object
     * @param {boolean} [parameters] 
     * @param {boolean} [allow_undefined_parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public validate(body: QueryRequest, parameters?: boolean, allow_undefined_parameters?: boolean, options?: any) {
        return QueriesApiFp(this.configuration).validate(body, parameters, allow_undefined_parameters, options)(this.fetch, this.basePath);
    }

    /**
     * Validate a SQL Expression with Rockset's parser and planner.
     * @summary Validate Expression
     * @param {ValidateExpressionRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public validateExpression(body: ValidateExpressionRequest, options?: any) {
        return QueriesApiFp(this.configuration).validateExpression(body, options)(this.fetch, this.basePath);
    }

    /**
     * Validate field mapping query with Rockset's parser and planner.
     * @summary Validate field mapping query
     * @param {ValidateFieldMappingQueryRequest} body SQL query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public validateFieldMappingQuery(body: ValidateFieldMappingQueryRequest, options?: any) {
        return QueriesApiFp(this.configuration).validateFieldMappingQuery(body, options)(this.fetch, this.basePath);
    }

}

/**
 * QueryLambdasApi - fetch parameter creator
 * @export
 */
export const QueryLambdasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a Query Lambda in given workspace.
         * @summary Create Query Lambda
         * @param {string} workspace name of the workspace
         * @param {CreateQueryLambdaRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueryLambda(workspace: string, body: CreateQueryLambdaRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling createQueryLambda.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createQueryLambda.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateQueryLambdaRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a tag for a specific Query Lambda version, or update that tag if it already exists.
         * @summary Create Query Lambda Tag
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {CreateQueryLambdaTagRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueryLambdaTag(workspace: string, queryLambda: string, body: CreateQueryLambdaTagRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling createQueryLambdaTag.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling createQueryLambdaTag.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createQueryLambdaTag.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/tags`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateQueryLambdaTagRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Query Lambda.
         * @summary Delete Query Lambda
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueryLambda(workspace: string, queryLambda: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling deleteQueryLambda.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling deleteQueryLambda.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a tag for a specific Query Lambda
         * @summary Delete Query Lambda Tag Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} tag name of the tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueryLambdaTag(workspace: string, queryLambda: string, tag: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling deleteQueryLambdaTag.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling deleteQueryLambdaTag.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling deleteQueryLambdaTag.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/tags/{tag}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Query Lambda version.
         * @summary Delete Query Lambda Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} version version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling deleteQueryLambdaVersion.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling deleteQueryLambdaVersion.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling deleteQueryLambdaVersion.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/version/{version}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Execute a particular version of a Query Lambda.
         * @summary Execute Query Lambda By Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} version version
         * @param {ExecuteQueryLambdaRequest} [body] JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeQueryLambda(workspace: string, queryLambda: string, version: string, body?: ExecuteQueryLambdaRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling executeQueryLambda.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling executeQueryLambda.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling executeQueryLambda.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/versions/{version}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ExecuteQueryLambdaRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Execute the Query Lambda version associated with a given tag.
         * @summary Execute Query Lambda By Tag
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} tag tag
         * @param {ExecuteQueryLambdaRequest} [body] JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeQueryLambdaByTag(workspace: string, queryLambda: string, tag: string, body?: ExecuteQueryLambdaRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling executeQueryLambdaByTag.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling executeQueryLambdaByTag.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling executeQueryLambdaByTag.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/tags/{tag}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ExecuteQueryLambdaRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the Query Lambda version associated with a given tag.
         * @summary Retrieve Query Lambda Tag
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} tag name of the tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryLambdaTagVersion(workspace: string, queryLambda: string, tag: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling getQueryLambdaTagVersion.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling getQueryLambdaTagVersion.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling getQueryLambdaTagVersion.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/tags/{tag}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details for a specified version of a Query Lambda.
         * @summary Retrieve Query Lambda Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} version version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling getQueryLambdaVersion.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling getQueryLambdaVersion.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling getQueryLambdaVersion.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/versions/{version}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all Query Lambdas in an organization.
         * @summary List Query Lambdas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllQueryLambdas(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/lambdas`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all distinct Query Lambda tags in an organization.
         * @summary List All Query Lambda Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationTags(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/lambdas/tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all Query Lambda versions associated with a given tag.
         * @summary List Query Lambda Tag Versions
         * @param {string} tag name of the tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdaTagVersions(tag: string, options: any = {}): FetchArgs {
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling listQueryLambdaTagVersions.');
            }
            const localVarPath = `/v1/orgs/self/lambdas/tags/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all tags associated with a Query Lambda
         * @summary List Query Lambda Tags
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdaTags(workspace: string, queryLambda: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling listQueryLambdaTags.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling listQueryLambdaTags.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/tags`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all versions of a Query Lambda.
         * @summary List Query Lambda Versions
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdaVersions(workspace: string, queryLambda: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling listQueryLambdaVersions.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling listQueryLambdaVersions.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/versions`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all Query Lambdas under given workspace.
         * @summary List Query Lambdas in Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdasInWorkspace(workspace: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling listQueryLambdasInWorkspace.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transfer ownership of a Query Lambda to a new user.
         * @summary Transfer Ownership of a Query Lambda
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {TransferOwnershipRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferOwnership(workspace: string, queryLambda: string, body: TransferOwnershipRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling transferOwnership.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling transferOwnership.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling transferOwnership.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/owner`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TransferOwnershipRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new version of a Query Lambda in given workspace.
         * @summary Update Query Lambda
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {UpdateQueryLambdaRequest} body JSON object
         * @param {boolean} [create] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQueryLambda(workspace: string, queryLambda: string, body: UpdateQueryLambdaRequest, create?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling updateQueryLambda.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling updateQueryLambda.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateQueryLambda.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/versions`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (create !== undefined) {
                localVarQueryParameter['create'] = create;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateQueryLambdaRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryLambdasApi - functional programming interface
 * @export
 */
export const QueryLambdasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a Query Lambda in given workspace.
         * @summary Create Query Lambda
         * @param {string} workspace name of the workspace
         * @param {CreateQueryLambdaRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueryLambda(workspace: string, body: CreateQueryLambdaRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryLambdaVersionResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).createQueryLambda(workspace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a tag for a specific Query Lambda version, or update that tag if it already exists.
         * @summary Create Query Lambda Tag
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {CreateQueryLambdaTagRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueryLambdaTag(workspace: string, queryLambda: string, body: CreateQueryLambdaTagRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryLambdaTagResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).createQueryLambdaTag(workspace, queryLambda, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a Query Lambda.
         * @summary Delete Query Lambda
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueryLambda(workspace: string, queryLambda: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteQueryLambdaResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).deleteQueryLambda(workspace, queryLambda, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a tag for a specific Query Lambda
         * @summary Delete Query Lambda Tag Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} tag name of the tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueryLambdaTag(workspace: string, queryLambda: string, tag: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryLambdaTagResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).deleteQueryLambdaTag(workspace, queryLambda, tag, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a Query Lambda version.
         * @summary Delete Query Lambda Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} version version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryLambdaVersionResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).deleteQueryLambdaVersion(workspace, queryLambda, version, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Execute a particular version of a Query Lambda.
         * @summary Execute Query Lambda By Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} version version
         * @param {ExecuteQueryLambdaRequest} [body] JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeQueryLambda(workspace: string, queryLambda: string, version: string, body?: ExecuteQueryLambdaRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).executeQueryLambda(workspace, queryLambda, version, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Execute the Query Lambda version associated with a given tag.
         * @summary Execute Query Lambda By Tag
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} tag tag
         * @param {ExecuteQueryLambdaRequest} [body] JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeQueryLambdaByTag(workspace: string, queryLambda: string, tag: string, body?: ExecuteQueryLambdaRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).executeQueryLambdaByTag(workspace, queryLambda, tag, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve the Query Lambda version associated with a given tag.
         * @summary Retrieve Query Lambda Tag
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} tag name of the tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryLambdaTagVersion(workspace: string, queryLambda: string, tag: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryLambdaTagResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).getQueryLambdaTagVersion(workspace, queryLambda, tag, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve details for a specified version of a Query Lambda.
         * @summary Retrieve Query Lambda Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} version version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryLambdaVersionResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).getQueryLambdaVersion(workspace, queryLambda, version, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all Query Lambdas in an organization.
         * @summary List Query Lambdas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllQueryLambdas(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueryLambdasResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).listAllQueryLambdas(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all distinct Query Lambda tags in an organization.
         * @summary List All Query Lambda Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationTags(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueryLambdaTagsResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).listOrganizationTags(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all Query Lambda versions associated with a given tag.
         * @summary List Query Lambda Tag Versions
         * @param {string} tag name of the tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdaTagVersions(tag: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueryLambdaVersionsResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).listQueryLambdaTagVersions(tag, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all tags associated with a Query Lambda
         * @summary List Query Lambda Tags
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdaTags(workspace: string, queryLambda: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueryLambdaTagsResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).listQueryLambdaTags(workspace, queryLambda, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all versions of a Query Lambda.
         * @summary List Query Lambda Versions
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdaVersions(workspace: string, queryLambda: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueryLambdaVersionsResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).listQueryLambdaVersions(workspace, queryLambda, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all Query Lambdas under given workspace.
         * @summary List Query Lambdas in Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdasInWorkspace(workspace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueryLambdasResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).listQueryLambdasInWorkspace(workspace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Transfer ownership of a Query Lambda to a new user.
         * @summary Transfer Ownership of a Query Lambda
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {TransferOwnershipRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferOwnership(workspace: string, queryLambda: string, body: TransferOwnershipRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).transferOwnership(workspace, queryLambda, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new version of a Query Lambda in given workspace.
         * @summary Update Query Lambda
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {UpdateQueryLambdaRequest} body JSON object
         * @param {boolean} [create] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQueryLambda(workspace: string, queryLambda: string, body: UpdateQueryLambdaRequest, create?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryLambdaVersionResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).updateQueryLambda(workspace, queryLambda, body, create, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QueryLambdasApi - factory interface
 * @export
 */
export const QueryLambdasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a Query Lambda in given workspace.
         * @summary Create Query Lambda
         * @param {string} workspace name of the workspace
         * @param {CreateQueryLambdaRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueryLambda(workspace: string, body: CreateQueryLambdaRequest, options?: any) {
            return QueryLambdasApiFp(configuration).createQueryLambda(workspace, body, options)(fetch, basePath);
        },
        /**
         * Create a tag for a specific Query Lambda version, or update that tag if it already exists.
         * @summary Create Query Lambda Tag
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {CreateQueryLambdaTagRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueryLambdaTag(workspace: string, queryLambda: string, body: CreateQueryLambdaTagRequest, options?: any) {
            return QueryLambdasApiFp(configuration).createQueryLambdaTag(workspace, queryLambda, body, options)(fetch, basePath);
        },
        /**
         * Delete a Query Lambda.
         * @summary Delete Query Lambda
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueryLambda(workspace: string, queryLambda: string, options?: any) {
            return QueryLambdasApiFp(configuration).deleteQueryLambda(workspace, queryLambda, options)(fetch, basePath);
        },
        /**
         * Delete a tag for a specific Query Lambda
         * @summary Delete Query Lambda Tag Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} tag name of the tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueryLambdaTag(workspace: string, queryLambda: string, tag: string, options?: any) {
            return QueryLambdasApiFp(configuration).deleteQueryLambdaTag(workspace, queryLambda, tag, options)(fetch, basePath);
        },
        /**
         * Delete a Query Lambda version.
         * @summary Delete Query Lambda Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} version version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options?: any) {
            return QueryLambdasApiFp(configuration).deleteQueryLambdaVersion(workspace, queryLambda, version, options)(fetch, basePath);
        },
        /**
         * Execute a particular version of a Query Lambda.
         * @summary Execute Query Lambda By Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} version version
         * @param {ExecuteQueryLambdaRequest} [body] JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeQueryLambda(workspace: string, queryLambda: string, version: string, body?: ExecuteQueryLambdaRequest, options?: any) {
            return QueryLambdasApiFp(configuration).executeQueryLambda(workspace, queryLambda, version, body, options)(fetch, basePath);
        },
        /**
         * Execute the Query Lambda version associated with a given tag.
         * @summary Execute Query Lambda By Tag
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} tag tag
         * @param {ExecuteQueryLambdaRequest} [body] JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeQueryLambdaByTag(workspace: string, queryLambda: string, tag: string, body?: ExecuteQueryLambdaRequest, options?: any) {
            return QueryLambdasApiFp(configuration).executeQueryLambdaByTag(workspace, queryLambda, tag, body, options)(fetch, basePath);
        },
        /**
         * Retrieve the Query Lambda version associated with a given tag.
         * @summary Retrieve Query Lambda Tag
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} tag name of the tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryLambdaTagVersion(workspace: string, queryLambda: string, tag: string, options?: any) {
            return QueryLambdasApiFp(configuration).getQueryLambdaTagVersion(workspace, queryLambda, tag, options)(fetch, basePath);
        },
        /**
         * Retrieve details for a specified version of a Query Lambda.
         * @summary Retrieve Query Lambda Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} version version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options?: any) {
            return QueryLambdasApiFp(configuration).getQueryLambdaVersion(workspace, queryLambda, version, options)(fetch, basePath);
        },
        /**
         * List all Query Lambdas in an organization.
         * @summary List Query Lambdas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllQueryLambdas(options?: any) {
            return QueryLambdasApiFp(configuration).listAllQueryLambdas(options)(fetch, basePath);
        },
        /**
         * List all distinct Query Lambda tags in an organization.
         * @summary List All Query Lambda Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationTags(options?: any) {
            return QueryLambdasApiFp(configuration).listOrganizationTags(options)(fetch, basePath);
        },
        /**
         * List all Query Lambda versions associated with a given tag.
         * @summary List Query Lambda Tag Versions
         * @param {string} tag name of the tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdaTagVersions(tag: string, options?: any) {
            return QueryLambdasApiFp(configuration).listQueryLambdaTagVersions(tag, options)(fetch, basePath);
        },
        /**
         * List all tags associated with a Query Lambda
         * @summary List Query Lambda Tags
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdaTags(workspace: string, queryLambda: string, options?: any) {
            return QueryLambdasApiFp(configuration).listQueryLambdaTags(workspace, queryLambda, options)(fetch, basePath);
        },
        /**
         * List all versions of a Query Lambda.
         * @summary List Query Lambda Versions
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdaVersions(workspace: string, queryLambda: string, options?: any) {
            return QueryLambdasApiFp(configuration).listQueryLambdaVersions(workspace, queryLambda, options)(fetch, basePath);
        },
        /**
         * List all Query Lambdas under given workspace.
         * @summary List Query Lambdas in Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdasInWorkspace(workspace: string, options?: any) {
            return QueryLambdasApiFp(configuration).listQueryLambdasInWorkspace(workspace, options)(fetch, basePath);
        },
        /**
         * Transfer ownership of a Query Lambda to a new user.
         * @summary Transfer Ownership of a Query Lambda
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {TransferOwnershipRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferOwnership(workspace: string, queryLambda: string, body: TransferOwnershipRequest, options?: any) {
            return QueryLambdasApiFp(configuration).transferOwnership(workspace, queryLambda, body, options)(fetch, basePath);
        },
        /**
         * Create a new version of a Query Lambda in given workspace.
         * @summary Update Query Lambda
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {UpdateQueryLambdaRequest} body JSON object
         * @param {boolean} [create] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQueryLambda(workspace: string, queryLambda: string, body: UpdateQueryLambdaRequest, create?: boolean, options?: any) {
            return QueryLambdasApiFp(configuration).updateQueryLambda(workspace, queryLambda, body, create, options)(fetch, basePath);
        },
    };
};

/**
 * QueryLambdasApi - object-oriented interface
 * @export
 * @class QueryLambdasApi
 * @extends {BaseAPI}
 */
export class QueryLambdasApi extends BaseAPI {
    /**
     * Create a Query Lambda in given workspace.
     * @summary Create Query Lambda
     * @param {string} workspace name of the workspace
     * @param {CreateQueryLambdaRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public createQueryLambda(workspace: string, body: CreateQueryLambdaRequest, options?: any) {
        return QueryLambdasApiFp(this.configuration).createQueryLambda(workspace, body, options)(this.fetch, this.basePath);
    }

    /**
     * Create a tag for a specific Query Lambda version, or update that tag if it already exists.
     * @summary Create Query Lambda Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {CreateQueryLambdaTagRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public createQueryLambdaTag(workspace: string, queryLambda: string, body: CreateQueryLambdaTagRequest, options?: any) {
        return QueryLambdasApiFp(this.configuration).createQueryLambdaTag(workspace, queryLambda, body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a Query Lambda.
     * @summary Delete Query Lambda
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public deleteQueryLambda(workspace: string, queryLambda: string, options?: any) {
        return QueryLambdasApiFp(this.configuration).deleteQueryLambda(workspace, queryLambda, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a tag for a specific Query Lambda
     * @summary Delete Query Lambda Tag Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag name of the tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public deleteQueryLambdaTag(workspace: string, queryLambda: string, tag: string, options?: any) {
        return QueryLambdasApiFp(this.configuration).deleteQueryLambdaTag(workspace, queryLambda, tag, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a Query Lambda version.
     * @summary Delete Query Lambda Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public deleteQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options?: any) {
        return QueryLambdasApiFp(this.configuration).deleteQueryLambdaVersion(workspace, queryLambda, version, options)(this.fetch, this.basePath);
    }

    /**
     * Execute a particular version of a Query Lambda.
     * @summary Execute Query Lambda By Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {ExecuteQueryLambdaRequest} [body] JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public executeQueryLambda(workspace: string, queryLambda: string, version: string, body?: ExecuteQueryLambdaRequest, options?: any) {
        return QueryLambdasApiFp(this.configuration).executeQueryLambda(workspace, queryLambda, version, body, options)(this.fetch, this.basePath);
    }

    /**
     * Execute the Query Lambda version associated with a given tag.
     * @summary Execute Query Lambda By Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag tag
     * @param {ExecuteQueryLambdaRequest} [body] JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public executeQueryLambdaByTag(workspace: string, queryLambda: string, tag: string, body?: ExecuteQueryLambdaRequest, options?: any) {
        return QueryLambdasApiFp(this.configuration).executeQueryLambdaByTag(workspace, queryLambda, tag, body, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve the Query Lambda version associated with a given tag.
     * @summary Retrieve Query Lambda Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag name of the tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public getQueryLambdaTagVersion(workspace: string, queryLambda: string, tag: string, options?: any) {
        return QueryLambdasApiFp(this.configuration).getQueryLambdaTagVersion(workspace, queryLambda, tag, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve details for a specified version of a Query Lambda.
     * @summary Retrieve Query Lambda Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public getQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options?: any) {
        return QueryLambdasApiFp(this.configuration).getQueryLambdaVersion(workspace, queryLambda, version, options)(this.fetch, this.basePath);
    }

    /**
     * List all Query Lambdas in an organization.
     * @summary List Query Lambdas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public listAllQueryLambdas(options?: any) {
        return QueryLambdasApiFp(this.configuration).listAllQueryLambdas(options)(this.fetch, this.basePath);
    }

    /**
     * List all distinct Query Lambda tags in an organization.
     * @summary List All Query Lambda Tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public listOrganizationTags(options?: any) {
        return QueryLambdasApiFp(this.configuration).listOrganizationTags(options)(this.fetch, this.basePath);
    }

    /**
     * List all Query Lambda versions associated with a given tag.
     * @summary List Query Lambda Tag Versions
     * @param {string} tag name of the tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public listQueryLambdaTagVersions(tag: string, options?: any) {
        return QueryLambdasApiFp(this.configuration).listQueryLambdaTagVersions(tag, options)(this.fetch, this.basePath);
    }

    /**
     * List all tags associated with a Query Lambda
     * @summary List Query Lambda Tags
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public listQueryLambdaTags(workspace: string, queryLambda: string, options?: any) {
        return QueryLambdasApiFp(this.configuration).listQueryLambdaTags(workspace, queryLambda, options)(this.fetch, this.basePath);
    }

    /**
     * List all versions of a Query Lambda.
     * @summary List Query Lambda Versions
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public listQueryLambdaVersions(workspace: string, queryLambda: string, options?: any) {
        return QueryLambdasApiFp(this.configuration).listQueryLambdaVersions(workspace, queryLambda, options)(this.fetch, this.basePath);
    }

    /**
     * List all Query Lambdas under given workspace.
     * @summary List Query Lambdas in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public listQueryLambdasInWorkspace(workspace: string, options?: any) {
        return QueryLambdasApiFp(this.configuration).listQueryLambdasInWorkspace(workspace, options)(this.fetch, this.basePath);
    }

    /**
     * Transfer ownership of a Query Lambda to a new user.
     * @summary Transfer Ownership of a Query Lambda
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {TransferOwnershipRequest} body JSON Object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public transferOwnership(workspace: string, queryLambda: string, body: TransferOwnershipRequest, options?: any) {
        return QueryLambdasApiFp(this.configuration).transferOwnership(workspace, queryLambda, body, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new version of a Query Lambda in given workspace.
     * @summary Update Query Lambda
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {UpdateQueryLambdaRequest} body JSON object
     * @param {boolean} [create] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public updateQueryLambda(workspace: string, queryLambda: string, body: UpdateQueryLambdaRequest, create?: boolean, options?: any) {
        return QueryLambdasApiFp(this.configuration).updateQueryLambda(workspace, queryLambda, body, create, options)(this.fetch, this.basePath);
    }

}

/**
 * StatusApi - fetch parameter creator
 * @export
 */
export const StatusApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Server responds with 200 if healthy.
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health(options: any = {}): FetchArgs {
            const localVarPath = `/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Server responds with 200 if healthy.
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StatusResponse> {
            const localVarFetchArgs = StatusApiFetchParamCreator(configuration).health(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Server responds with 200 if healthy.
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health(options?: any) {
            return StatusApiFp(configuration).health(options)(fetch, basePath);
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     * Server responds with 200 if healthy.
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public health(options?: any) {
        return StatusApiFp(this.configuration).health(options)(this.fetch, this.basePath);
    }

}

/**
 * TelemetryApi - fetch parameter creator
 * @export
 */
export const TelemetryApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Record an item.
         * @summary Record Activity
         * @param {TelemetryRequest} body the activity item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordActivity(body: TelemetryRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling recordActivity.');
            }
            const localVarPath = `/v1/telemetry`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TelemetryRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TelemetryApi - functional programming interface
 * @export
 */
export const TelemetryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Record an item.
         * @summary Record Activity
         * @param {TelemetryRequest} body the activity item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordActivity(body: TelemetryRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StatusResponse> {
            const localVarFetchArgs = TelemetryApiFetchParamCreator(configuration).recordActivity(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TelemetryApi - factory interface
 * @export
 */
export const TelemetryApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Record an item.
         * @summary Record Activity
         * @param {TelemetryRequest} body the activity item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordActivity(body: TelemetryRequest, options?: any) {
            return TelemetryApiFp(configuration).recordActivity(body, options)(fetch, basePath);
        },
    };
};

/**
 * TelemetryApi - object-oriented interface
 * @export
 * @class TelemetryApi
 * @extends {BaseAPI}
 */
export class TelemetryApi extends BaseAPI {
    /**
     * Record an item.
     * @summary Record Activity
     * @param {TelemetryRequest} body the activity item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryApi
     */
    public recordActivity(body: TelemetryRequest, options?: any) {
        return TelemetryApiFp(this.configuration).recordActivity(body, options)(this.fetch, this.basePath);
    }

}

/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new user for an organization.
         * @summary Create User
         * @param {CreateUserRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: CreateUserRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createUser.');
            }
            const localVarPath = `/v1/orgs/self/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateUserRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user from an organization.
         * @summary Delete User
         * @param {string} user user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(user: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/v1/orgs/self/users/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve currently authenticated user.
         * @summary Retrieve Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/users/self`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get invite_state for current user's org_membership.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserInviteState(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/users/self/inviteState`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve currently active user's nux values.
         * @summary Get Current User's Nux Values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserNux(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/users/self/nux`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get state value for user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserState(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/users/self/state`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get accepted_ToS value for user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserTos(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/users/self/tos`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Functional in public API server's only - used to bootstrap Console
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserUnchecked(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/users/self/public`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve user by email.
         * @summary Retrieve User
         * @param {string} user user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(user: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling getUser.');
            }
            const localVarPath = `/v1/orgs/self/users/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get query history for user.
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserQueryHistory(limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/users/self/query-history`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all roles for a user.
         * @summary List User Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/users/roles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all notification preferences.
         * @summary Get all notification preferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUnsubscribePreferences(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/users/self/preferences`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all users for an organization.
         * @summary List Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set invite_state for current user's org_membership.
         * @param {InviteState} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCurrentUserInviteState(body: InviteState, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setCurrentUserInviteState.');
            }
            const localVarPath = `/v1/orgs/self/users/self/inviteState`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InviteState" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update state value for user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCurrentUserState(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/users/self/state`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set accepted_ToS value to true for user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCurrentUserTos(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/users/self/tos`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Auth0 to require MFA for a user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserMfa(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/users/self/mfa`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update currently active user.
         * @summary Update Current User
         * @param {UpdateUserRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentUser(body: UpdateUserRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateCurrentUser.');
            }
            const localVarPath = `/v1/orgs/self/users/self`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUserRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update nux info for user.
         * @summary Update Nux Info for User
         * @param {UpdateUserNuxRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentUserNux(body: UpdateUserNuxRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateCurrentUserNux.');
            }
            const localVarPath = `/v1/orgs/self/users/self/nux`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUserNuxRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update notification preference.
         * @summary Update notification preferences
         * @param {UpdateUnsubscribePreferencesRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUnsubscribePreferences(body: UpdateUnsubscribePreferencesRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateUnsubscribePreferences.');
            }
            const localVarPath = `/v1/orgs/self/users/self/preferences`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUnsubscribePreferencesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user in an organization.
         * @summary Update User
         * @param {string} user email of the user to update
         * @param {UpdateUserRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(user: string, body: UpdateUserRequest, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling updateUser.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateUser.');
            }
            const localVarPath = `/v1/orgs/self/users/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUserRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new user for an organization.
         * @summary Create User
         * @param {CreateUserRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: CreateUserRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateUserResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).createUser(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a user from an organization.
         * @summary Delete User
         * @param {string} user user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteUserResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).deleteUser(user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve currently authenticated user.
         * @summary Retrieve Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getCurrentUser(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get invite_state for current user's org_membership.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserInviteState(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InviteState> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getCurrentUserInviteState(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve currently active user's nux values.
         * @summary Get Current User's Nux Values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserNux(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserNux> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getCurrentUserNux(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get state value for user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserState(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserState> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getCurrentUserState(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get accepted_ToS value for user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserTos(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetUserTosResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getCurrentUserTos(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Functional in public API server's only - used to bootstrap Console
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserUnchecked(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getCurrentUserUnchecked(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve user by email.
         * @summary Retrieve User
         * @param {string} user user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUser(user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get query history for user.
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserQueryHistory(limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserQueryHistoryResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUserQueryHistory(limit, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all roles for a user.
         * @summary List User Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListRolesResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).listRoles(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all notification preferences.
         * @summary Get all notification preferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUnsubscribePreferences(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListUnsubscribePreferencesResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).listUnsubscribePreferences(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all users for an organization.
         * @summary List Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListUsersResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).listUsers(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set invite_state for current user's org_membership.
         * @param {InviteState} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCurrentUserInviteState(body: InviteState, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InviteState> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).setCurrentUserInviteState(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update state value for user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCurrentUserState(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserState> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).setCurrentUserState(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set accepted_ToS value to true for user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCurrentUserTos(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).setCurrentUserTos(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update Auth0 to require MFA for a user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserMfa(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).setUserMfa(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update currently active user.
         * @summary Update Current User
         * @param {UpdateUserRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentUser(body: UpdateUserRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).updateCurrentUser(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update nux info for user.
         * @summary Update Nux Info for User
         * @param {UpdateUserNuxRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentUserNux(body: UpdateUserNuxRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserNux> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).updateCurrentUserNux(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update notification preference.
         * @summary Update notification preferences
         * @param {UpdateUnsubscribePreferencesRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUnsubscribePreferences(body: UpdateUnsubscribePreferencesRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpdateUnsubscribePreferencesResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).updateUnsubscribePreferences(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a user in an organization.
         * @summary Update User
         * @param {string} user email of the user to update
         * @param {UpdateUserRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(user: string, body: UpdateUserRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).updateUser(user, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new user for an organization.
         * @summary Create User
         * @param {CreateUserRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: CreateUserRequest, options?: any) {
            return UsersApiFp(configuration).createUser(body, options)(fetch, basePath);
        },
        /**
         * Delete a user from an organization.
         * @summary Delete User
         * @param {string} user user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(user: string, options?: any) {
            return UsersApiFp(configuration).deleteUser(user, options)(fetch, basePath);
        },
        /**
         * Retrieve currently authenticated user.
         * @summary Retrieve Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: any) {
            return UsersApiFp(configuration).getCurrentUser(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get invite_state for current user's org_membership.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserInviteState(options?: any) {
            return UsersApiFp(configuration).getCurrentUserInviteState(options)(fetch, basePath);
        },
        /**
         * Retrieve currently active user's nux values.
         * @summary Get Current User's Nux Values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserNux(options?: any) {
            return UsersApiFp(configuration).getCurrentUserNux(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get state value for user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserState(options?: any) {
            return UsersApiFp(configuration).getCurrentUserState(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get accepted_ToS value for user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserTos(options?: any) {
            return UsersApiFp(configuration).getCurrentUserTos(options)(fetch, basePath);
        },
        /**
         * Functional in public API server's only - used to bootstrap Console
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserUnchecked(options?: any) {
            return UsersApiFp(configuration).getCurrentUserUnchecked(options)(fetch, basePath);
        },
        /**
         * Retrieve user by email.
         * @summary Retrieve User
         * @param {string} user user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(user: string, options?: any) {
            return UsersApiFp(configuration).getUser(user, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get query history for user.
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserQueryHistory(limit?: number, options?: any) {
            return UsersApiFp(configuration).getUserQueryHistory(limit, options)(fetch, basePath);
        },
        /**
         * List all roles for a user.
         * @summary List User Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(options?: any) {
            return UsersApiFp(configuration).listRoles(options)(fetch, basePath);
        },
        /**
         * Get all notification preferences.
         * @summary Get all notification preferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUnsubscribePreferences(options?: any) {
            return UsersApiFp(configuration).listUnsubscribePreferences(options)(fetch, basePath);
        },
        /**
         * Retrieve all users for an organization.
         * @summary List Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(options?: any) {
            return UsersApiFp(configuration).listUsers(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set invite_state for current user's org_membership.
         * @param {InviteState} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCurrentUserInviteState(body: InviteState, options?: any) {
            return UsersApiFp(configuration).setCurrentUserInviteState(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update state value for user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCurrentUserState(options?: any) {
            return UsersApiFp(configuration).setCurrentUserState(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set accepted_ToS value to true for user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCurrentUserTos(options?: any) {
            return UsersApiFp(configuration).setCurrentUserTos(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update Auth0 to require MFA for a user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserMfa(options?: any) {
            return UsersApiFp(configuration).setUserMfa(options)(fetch, basePath);
        },
        /**
         * Update currently active user.
         * @summary Update Current User
         * @param {UpdateUserRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentUser(body: UpdateUserRequest, options?: any) {
            return UsersApiFp(configuration).updateCurrentUser(body, options)(fetch, basePath);
        },
        /**
         * Update nux info for user.
         * @summary Update Nux Info for User
         * @param {UpdateUserNuxRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentUserNux(body: UpdateUserNuxRequest, options?: any) {
            return UsersApiFp(configuration).updateCurrentUserNux(body, options)(fetch, basePath);
        },
        /**
         * Update notification preference.
         * @summary Update notification preferences
         * @param {UpdateUnsubscribePreferencesRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUnsubscribePreferences(body: UpdateUnsubscribePreferencesRequest, options?: any) {
            return UsersApiFp(configuration).updateUnsubscribePreferences(body, options)(fetch, basePath);
        },
        /**
         * Update a user in an organization.
         * @summary Update User
         * @param {string} user email of the user to update
         * @param {UpdateUserRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(user: string, body: UpdateUserRequest, options?: any) {
            return UsersApiFp(configuration).updateUser(user, body, options)(fetch, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Create a new user for an organization.
     * @summary Create User
     * @param {CreateUserRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(body: CreateUserRequest, options?: any) {
        return UsersApiFp(this.configuration).createUser(body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a user from an organization.
     * @summary Delete User
     * @param {string} user user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(user: string, options?: any) {
        return UsersApiFp(this.configuration).deleteUser(user, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve currently authenticated user.
     * @summary Retrieve Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getCurrentUser(options?: any) {
        return UsersApiFp(this.configuration).getCurrentUser(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get invite_state for current user's org_membership.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getCurrentUserInviteState(options?: any) {
        return UsersApiFp(this.configuration).getCurrentUserInviteState(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve currently active user's nux values.
     * @summary Get Current User's Nux Values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getCurrentUserNux(options?: any) {
        return UsersApiFp(this.configuration).getCurrentUserNux(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get state value for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getCurrentUserState(options?: any) {
        return UsersApiFp(this.configuration).getCurrentUserState(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get accepted_ToS value for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getCurrentUserTos(options?: any) {
        return UsersApiFp(this.configuration).getCurrentUserTos(options)(this.fetch, this.basePath);
    }

    /**
     * Functional in public API server's only - used to bootstrap Console
     * @summary Get Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getCurrentUserUnchecked(options?: any) {
        return UsersApiFp(this.configuration).getCurrentUserUnchecked(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve user by email.
     * @summary Retrieve User
     * @param {string} user user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(user: string, options?: any) {
        return UsersApiFp(this.configuration).getUser(user, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get query history for user.
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserQueryHistory(limit?: number, options?: any) {
        return UsersApiFp(this.configuration).getUserQueryHistory(limit, options)(this.fetch, this.basePath);
    }

    /**
     * List all roles for a user.
     * @summary List User Roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listRoles(options?: any) {
        return UsersApiFp(this.configuration).listRoles(options)(this.fetch, this.basePath);
    }

    /**
     * Get all notification preferences.
     * @summary Get all notification preferences
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUnsubscribePreferences(options?: any) {
        return UsersApiFp(this.configuration).listUnsubscribePreferences(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all users for an organization.
     * @summary List Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUsers(options?: any) {
        return UsersApiFp(this.configuration).listUsers(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set invite_state for current user's org_membership.
     * @param {InviteState} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public setCurrentUserInviteState(body: InviteState, options?: any) {
        return UsersApiFp(this.configuration).setCurrentUserInviteState(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update state value for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public setCurrentUserState(options?: any) {
        return UsersApiFp(this.configuration).setCurrentUserState(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set accepted_ToS value to true for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public setCurrentUserTos(options?: any) {
        return UsersApiFp(this.configuration).setCurrentUserTos(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update Auth0 to require MFA for a user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public setUserMfa(options?: any) {
        return UsersApiFp(this.configuration).setUserMfa(options)(this.fetch, this.basePath);
    }

    /**
     * Update currently active user.
     * @summary Update Current User
     * @param {UpdateUserRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateCurrentUser(body: UpdateUserRequest, options?: any) {
        return UsersApiFp(this.configuration).updateCurrentUser(body, options)(this.fetch, this.basePath);
    }

    /**
     * Update nux info for user.
     * @summary Update Nux Info for User
     * @param {UpdateUserNuxRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateCurrentUserNux(body: UpdateUserNuxRequest, options?: any) {
        return UsersApiFp(this.configuration).updateCurrentUserNux(body, options)(this.fetch, this.basePath);
    }

    /**
     * Update notification preference.
     * @summary Update notification preferences
     * @param {UpdateUnsubscribePreferencesRequest} body JSON Object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUnsubscribePreferences(body: UpdateUnsubscribePreferencesRequest, options?: any) {
        return UsersApiFp(this.configuration).updateUnsubscribePreferences(body, options)(this.fetch, this.basePath);
    }

    /**
     * Update a user in an organization.
     * @summary Update User
     * @param {string} user email of the user to update
     * @param {UpdateUserRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(user: string, body: UpdateUserRequest, options?: any) {
        return UsersApiFp(this.configuration).updateUser(user, body, options)(this.fetch, this.basePath);
    }

}

/**
 * ViewsApi - fetch parameter creator
 * @export
 */
export const ViewsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a view
         * @summary Create View
         * @param {string} workspace name of the workspace
         * @param {CreateViewRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createView(workspace: string, body: CreateViewRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling createView.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createView.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/views`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateViewRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a view
         * @summary Delete View
         * @param {string} workspace name of the workspace
         * @param {string} view name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteView(workspace: string, view: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling deleteView.');
            }
            // verify required parameter 'view' is not null or undefined
            if (view === null || view === undefined) {
                throw new RequiredError('view','Required parameter view was null or undefined when calling deleteView.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/views/{view}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"view"}}`, encodeURIComponent(String(view)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details about a view
         * @summary Retrieve View
         * @param {string} workspace name of the workspace
         * @param {string} view name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getView(workspace: string, view: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling getView.');
            }
            // verify required parameter 'view' is not null or undefined
            if (view === null || view === undefined) {
                throw new RequiredError('view','Required parameter view was null or undefined when calling getView.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/views/{view}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"view"}}`, encodeURIComponent(String(view)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all views in an organization
         * @summary List Views
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listViews(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/views`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a view
         * @summary Update View
         * @param {string} workspace name of the workspace
         * @param {string} view name of the view
         * @param {UpdateViewRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateView(workspace: string, view: string, body: UpdateViewRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling updateView.');
            }
            // verify required parameter 'view' is not null or undefined
            if (view === null || view === undefined) {
                throw new RequiredError('view','Required parameter view was null or undefined when calling updateView.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateView.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/views/{view}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"view"}}`, encodeURIComponent(String(view)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateViewRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all views in a workspace.
         * @summary List Views in Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceViews(workspace: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling workspaceViews.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/views`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ViewsApi - functional programming interface
 * @export
 */
export const ViewsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a view
         * @summary Create View
         * @param {string} workspace name of the workspace
         * @param {CreateViewRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createView(workspace: string, body: CreateViewRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateViewResponse> {
            const localVarFetchArgs = ViewsApiFetchParamCreator(configuration).createView(workspace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a view
         * @summary Delete View
         * @param {string} workspace name of the workspace
         * @param {string} view name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteView(workspace: string, view: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteViewResponse> {
            const localVarFetchArgs = ViewsApiFetchParamCreator(configuration).deleteView(workspace, view, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get details about a view
         * @summary Retrieve View
         * @param {string} workspace name of the workspace
         * @param {string} view name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getView(workspace: string, view: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetViewResponse> {
            const localVarFetchArgs = ViewsApiFetchParamCreator(configuration).getView(workspace, view, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all views in an organization
         * @summary List Views
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listViews(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListViewsResponse> {
            const localVarFetchArgs = ViewsApiFetchParamCreator(configuration).listViews(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a view
         * @summary Update View
         * @param {string} workspace name of the workspace
         * @param {string} view name of the view
         * @param {UpdateViewRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateView(workspace: string, view: string, body: UpdateViewRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpdateViewResponse> {
            const localVarFetchArgs = ViewsApiFetchParamCreator(configuration).updateView(workspace, view, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all views in a workspace.
         * @summary List Views in Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceViews(workspace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListViewsResponse> {
            const localVarFetchArgs = ViewsApiFetchParamCreator(configuration).workspaceViews(workspace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ViewsApi - factory interface
 * @export
 */
export const ViewsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a view
         * @summary Create View
         * @param {string} workspace name of the workspace
         * @param {CreateViewRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createView(workspace: string, body: CreateViewRequest, options?: any) {
            return ViewsApiFp(configuration).createView(workspace, body, options)(fetch, basePath);
        },
        /**
         * Delete a view
         * @summary Delete View
         * @param {string} workspace name of the workspace
         * @param {string} view name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteView(workspace: string, view: string, options?: any) {
            return ViewsApiFp(configuration).deleteView(workspace, view, options)(fetch, basePath);
        },
        /**
         * Get details about a view
         * @summary Retrieve View
         * @param {string} workspace name of the workspace
         * @param {string} view name of the view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getView(workspace: string, view: string, options?: any) {
            return ViewsApiFp(configuration).getView(workspace, view, options)(fetch, basePath);
        },
        /**
         * Retrieve all views in an organization
         * @summary List Views
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listViews(options?: any) {
            return ViewsApiFp(configuration).listViews(options)(fetch, basePath);
        },
        /**
         * Update a view
         * @summary Update View
         * @param {string} workspace name of the workspace
         * @param {string} view name of the view
         * @param {UpdateViewRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateView(workspace: string, view: string, body: UpdateViewRequest, options?: any) {
            return ViewsApiFp(configuration).updateView(workspace, view, body, options)(fetch, basePath);
        },
        /**
         * Retrieve all views in a workspace.
         * @summary List Views in Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceViews(workspace: string, options?: any) {
            return ViewsApiFp(configuration).workspaceViews(workspace, options)(fetch, basePath);
        },
    };
};

/**
 * ViewsApi - object-oriented interface
 * @export
 * @class ViewsApi
 * @extends {BaseAPI}
 */
export class ViewsApi extends BaseAPI {
    /**
     * Create a view
     * @summary Create View
     * @param {string} workspace name of the workspace
     * @param {CreateViewRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public createView(workspace: string, body: CreateViewRequest, options?: any) {
        return ViewsApiFp(this.configuration).createView(workspace, body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a view
     * @summary Delete View
     * @param {string} workspace name of the workspace
     * @param {string} view name of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public deleteView(workspace: string, view: string, options?: any) {
        return ViewsApiFp(this.configuration).deleteView(workspace, view, options)(this.fetch, this.basePath);
    }

    /**
     * Get details about a view
     * @summary Retrieve View
     * @param {string} workspace name of the workspace
     * @param {string} view name of the view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public getView(workspace: string, view: string, options?: any) {
        return ViewsApiFp(this.configuration).getView(workspace, view, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all views in an organization
     * @summary List Views
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public listViews(options?: any) {
        return ViewsApiFp(this.configuration).listViews(options)(this.fetch, this.basePath);
    }

    /**
     * Update a view
     * @summary Update View
     * @param {string} workspace name of the workspace
     * @param {string} view name of the view
     * @param {UpdateViewRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public updateView(workspace: string, view: string, body: UpdateViewRequest, options?: any) {
        return ViewsApiFp(this.configuration).updateView(workspace, view, body, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all views in a workspace.
     * @summary List Views in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewsApi
     */
    public workspaceViews(workspace: string, options?: any) {
        return ViewsApiFp(this.configuration).workspaceViews(workspace, options)(this.fetch, this.basePath);
    }

}

/**
 * VirtualInstancesApi - fetch parameter creator
 * @export
 */
export const VirtualInstancesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get details about a virtual instance.
         * @summary Retrieve Virtual Instance
         * @param {string} virtualInstanceId uuid of the virtual instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualInstance(virtualInstanceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'virtualInstanceId' is not null or undefined
            if (virtualInstanceId === null || virtualInstanceId === undefined) {
                throw new RequiredError('virtualInstanceId','Required parameter virtualInstanceId was null or undefined when calling getVirtualInstance.');
            }
            const localVarPath = `/v1/orgs/self/virtualinstances/{virtualInstanceId}`
                .replace(`{${"virtualInstanceId"}}`, encodeURIComponent(String(virtualInstanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get relevant metrics for a specific virtual instance.
         * @summary Get Virtual Instance metrics
         * @param {string} virtualInstanceId uuid of the virtual instance
         * @param {number} start start time (ms)
         * @param {number} end end time (ms)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualInstanceMetrics(virtualInstanceId: string, start: number, end: number, options: any = {}): FetchArgs {
            // verify required parameter 'virtualInstanceId' is not null or undefined
            if (virtualInstanceId === null || virtualInstanceId === undefined) {
                throw new RequiredError('virtualInstanceId','Required parameter virtualInstanceId was null or undefined when calling getVirtualInstanceMetrics.');
            }
            // verify required parameter 'start' is not null or undefined
            if (start === null || start === undefined) {
                throw new RequiredError('start','Required parameter start was null or undefined when calling getVirtualInstanceMetrics.');
            }
            // verify required parameter 'end' is not null or undefined
            if (end === null || end === undefined) {
                throw new RequiredError('end','Required parameter end was null or undefined when calling getVirtualInstanceMetrics.');
            }
            const localVarPath = `/v1/orgs/self/virtualinstances/{virtualInstanceId}/metrics`
                .replace(`{${"virtualInstanceId"}}`, encodeURIComponent(String(virtualInstanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all virtual instances in an organization.
         * @summary List Virtual Instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVirtualInstances(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/virtualinstances`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the properties of a virtual instance.
         * @summary Update Virtual Instance
         * @param {string} virtualInstanceId uuid of the virtual instance
         * @param {UpdateVirtualInstanceRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setVirtualInstance(virtualInstanceId: string, body: UpdateVirtualInstanceRequest, options: any = {}): FetchArgs {
            // verify required parameter 'virtualInstanceId' is not null or undefined
            if (virtualInstanceId === null || virtualInstanceId === undefined) {
                throw new RequiredError('virtualInstanceId','Required parameter virtualInstanceId was null or undefined when calling setVirtualInstance.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setVirtualInstance.');
            }
            const localVarPath = `/v1/orgs/self/virtualinstances/{virtualInstanceId}`
                .replace(`{${"virtualInstanceId"}}`, encodeURIComponent(String(virtualInstanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateVirtualInstanceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Switch a virtual instance type within an organization to a new virtual instance type.
         * @summary Switch Virtual Instance Type
         * @param {string} virtualInstanceId uuid of the virtual instance
         * @param {UpdateVirtualInstanceRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setVirtualInstanceType(virtualInstanceId: string, body: UpdateVirtualInstanceRequest, options: any = {}): FetchArgs {
            // verify required parameter 'virtualInstanceId' is not null or undefined
            if (virtualInstanceId === null || virtualInstanceId === undefined) {
                throw new RequiredError('virtualInstanceId','Required parameter virtualInstanceId was null or undefined when calling setVirtualInstanceType.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setVirtualInstanceType.');
            }
            const localVarPath = `/v1/orgs/self/virtualinstances/{virtualInstanceId}/type`
                .replace(`{${"virtualInstanceId"}}`, encodeURIComponent(String(virtualInstanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateVirtualInstanceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VirtualInstancesApi - functional programming interface
 * @export
 */
export const VirtualInstancesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get details about a virtual instance.
         * @summary Retrieve Virtual Instance
         * @param {string} virtualInstanceId uuid of the virtual instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualInstance(virtualInstanceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetVirtualInstanceResponse> {
            const localVarFetchArgs = VirtualInstancesApiFetchParamCreator(configuration).getVirtualInstance(virtualInstanceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get relevant metrics for a specific virtual instance.
         * @summary Get Virtual Instance metrics
         * @param {string} virtualInstanceId uuid of the virtual instance
         * @param {number} start start time (ms)
         * @param {number} end end time (ms)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualInstanceMetrics(virtualInstanceId: string, start: number, end: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetVirtualInstanceMetricsResponse> {
            const localVarFetchArgs = VirtualInstancesApiFetchParamCreator(configuration).getVirtualInstanceMetrics(virtualInstanceId, start, end, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all virtual instances in an organization.
         * @summary List Virtual Instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVirtualInstances(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListVirtualInstancesResponse> {
            const localVarFetchArgs = VirtualInstancesApiFetchParamCreator(configuration).listVirtualInstances(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the properties of a virtual instance.
         * @summary Update Virtual Instance
         * @param {string} virtualInstanceId uuid of the virtual instance
         * @param {UpdateVirtualInstanceRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setVirtualInstance(virtualInstanceId: string, body: UpdateVirtualInstanceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpdateVirtualInstanceResponse> {
            const localVarFetchArgs = VirtualInstancesApiFetchParamCreator(configuration).setVirtualInstance(virtualInstanceId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Switch a virtual instance type within an organization to a new virtual instance type.
         * @summary Switch Virtual Instance Type
         * @param {string} virtualInstanceId uuid of the virtual instance
         * @param {UpdateVirtualInstanceRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setVirtualInstanceType(virtualInstanceId: string, body: UpdateVirtualInstanceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpdateVirtualInstanceResponse> {
            const localVarFetchArgs = VirtualInstancesApiFetchParamCreator(configuration).setVirtualInstanceType(virtualInstanceId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VirtualInstancesApi - factory interface
 * @export
 */
export const VirtualInstancesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get details about a virtual instance.
         * @summary Retrieve Virtual Instance
         * @param {string} virtualInstanceId uuid of the virtual instance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualInstance(virtualInstanceId: string, options?: any) {
            return VirtualInstancesApiFp(configuration).getVirtualInstance(virtualInstanceId, options)(fetch, basePath);
        },
        /**
         * Get relevant metrics for a specific virtual instance.
         * @summary Get Virtual Instance metrics
         * @param {string} virtualInstanceId uuid of the virtual instance
         * @param {number} start start time (ms)
         * @param {number} end end time (ms)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualInstanceMetrics(virtualInstanceId: string, start: number, end: number, options?: any) {
            return VirtualInstancesApiFp(configuration).getVirtualInstanceMetrics(virtualInstanceId, start, end, options)(fetch, basePath);
        },
        /**
         * Retrieve all virtual instances in an organization.
         * @summary List Virtual Instances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVirtualInstances(options?: any) {
            return VirtualInstancesApiFp(configuration).listVirtualInstances(options)(fetch, basePath);
        },
        /**
         * Update the properties of a virtual instance.
         * @summary Update Virtual Instance
         * @param {string} virtualInstanceId uuid of the virtual instance
         * @param {UpdateVirtualInstanceRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setVirtualInstance(virtualInstanceId: string, body: UpdateVirtualInstanceRequest, options?: any) {
            return VirtualInstancesApiFp(configuration).setVirtualInstance(virtualInstanceId, body, options)(fetch, basePath);
        },
        /**
         * Switch a virtual instance type within an organization to a new virtual instance type.
         * @summary Switch Virtual Instance Type
         * @param {string} virtualInstanceId uuid of the virtual instance
         * @param {UpdateVirtualInstanceRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setVirtualInstanceType(virtualInstanceId: string, body: UpdateVirtualInstanceRequest, options?: any) {
            return VirtualInstancesApiFp(configuration).setVirtualInstanceType(virtualInstanceId, body, options)(fetch, basePath);
        },
    };
};

/**
 * VirtualInstancesApi - object-oriented interface
 * @export
 * @class VirtualInstancesApi
 * @extends {BaseAPI}
 */
export class VirtualInstancesApi extends BaseAPI {
    /**
     * Get details about a virtual instance.
     * @summary Retrieve Virtual Instance
     * @param {string} virtualInstanceId uuid of the virtual instance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    public getVirtualInstance(virtualInstanceId: string, options?: any) {
        return VirtualInstancesApiFp(this.configuration).getVirtualInstance(virtualInstanceId, options)(this.fetch, this.basePath);
    }

    /**
     * Get relevant metrics for a specific virtual instance.
     * @summary Get Virtual Instance metrics
     * @param {string} virtualInstanceId uuid of the virtual instance
     * @param {number} start start time (ms)
     * @param {number} end end time (ms)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    public getVirtualInstanceMetrics(virtualInstanceId: string, start: number, end: number, options?: any) {
        return VirtualInstancesApiFp(this.configuration).getVirtualInstanceMetrics(virtualInstanceId, start, end, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all virtual instances in an organization.
     * @summary List Virtual Instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    public listVirtualInstances(options?: any) {
        return VirtualInstancesApiFp(this.configuration).listVirtualInstances(options)(this.fetch, this.basePath);
    }

    /**
     * Update the properties of a virtual instance.
     * @summary Update Virtual Instance
     * @param {string} virtualInstanceId uuid of the virtual instance
     * @param {UpdateVirtualInstanceRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    public setVirtualInstance(virtualInstanceId: string, body: UpdateVirtualInstanceRequest, options?: any) {
        return VirtualInstancesApiFp(this.configuration).setVirtualInstance(virtualInstanceId, body, options)(this.fetch, this.basePath);
    }

    /**
     * Switch a virtual instance type within an organization to a new virtual instance type.
     * @summary Switch Virtual Instance Type
     * @param {string} virtualInstanceId uuid of the virtual instance
     * @param {UpdateVirtualInstanceRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualInstancesApi
     */
    public setVirtualInstanceType(virtualInstanceId: string, body: UpdateVirtualInstanceRequest, options?: any) {
        return VirtualInstancesApiFp(this.configuration).setVirtualInstanceType(virtualInstanceId, body, options)(this.fetch, this.basePath);
    }

}

/**
 * WorkspacesApi - fetch parameter creator
 * @export
 */
export const WorkspacesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List workspaces under given workspace.
         * @summary List Workspaces in Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        childWorkspaces(workspace: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling childWorkspaces.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/ws`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new workspace.
         * @summary Create Workspace
         * @param {CreateWorkspaceRequest} body workspace details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace(body: CreateWorkspaceRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createWorkspace.');
            }
            const localVarPath = `/v1/orgs/self/ws`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateWorkspaceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a workspace.
         * @summary Delete Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace(workspace: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling deleteWorkspace.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a single workspace.
         * @summary Retrieve Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspace(workspace: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling getWorkspace.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all workspaces in an organization.
         * @summary List Workspaces
         * @param {boolean} [fetch_across_regions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaces(fetch_across_regions?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/ws`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fetch_across_regions !== undefined) {
                localVarQueryParameter['fetch_across_regions'] = fetch_across_regions;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transfer ownership of a workspace to a new user.
         * @summary Transfer Ownership of a Workspace
         * @param {string} workspace name of the workspace
         * @param {TransferOwnershipRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferOwnership(workspace: string, body: TransferOwnershipRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling transferOwnership.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling transferOwnership.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/owner`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TransferOwnershipRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkspacesApi - functional programming interface
 * @export
 */
export const WorkspacesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List workspaces under given workspace.
         * @summary List Workspaces in Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        childWorkspaces(workspace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListWorkspacesResponse> {
            const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).childWorkspaces(workspace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new workspace.
         * @summary Create Workspace
         * @param {CreateWorkspaceRequest} body workspace details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace(body: CreateWorkspaceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateWorkspaceResponse> {
            const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).createWorkspace(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove a workspace.
         * @summary Delete Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace(workspace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteWorkspaceResponse> {
            const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).deleteWorkspace(workspace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information about a single workspace.
         * @summary Retrieve Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspace(workspace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetWorkspaceResponse> {
            const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).getWorkspace(workspace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all workspaces in an organization.
         * @summary List Workspaces
         * @param {boolean} [fetch_across_regions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaces(fetch_across_regions?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListWorkspacesResponse> {
            const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).listWorkspaces(fetch_across_regions, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Transfer ownership of a workspace to a new user.
         * @summary Transfer Ownership of a Workspace
         * @param {string} workspace name of the workspace
         * @param {TransferOwnershipRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferOwnership(workspace: string, body: TransferOwnershipRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).transferOwnership(workspace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WorkspacesApi - factory interface
 * @export
 */
export const WorkspacesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * List workspaces under given workspace.
         * @summary List Workspaces in Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        childWorkspaces(workspace: string, options?: any) {
            return WorkspacesApiFp(configuration).childWorkspaces(workspace, options)(fetch, basePath);
        },
        /**
         * Create a new workspace.
         * @summary Create Workspace
         * @param {CreateWorkspaceRequest} body workspace details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace(body: CreateWorkspaceRequest, options?: any) {
            return WorkspacesApiFp(configuration).createWorkspace(body, options)(fetch, basePath);
        },
        /**
         * Remove a workspace.
         * @summary Delete Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace(workspace: string, options?: any) {
            return WorkspacesApiFp(configuration).deleteWorkspace(workspace, options)(fetch, basePath);
        },
        /**
         * Get information about a single workspace.
         * @summary Retrieve Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspace(workspace: string, options?: any) {
            return WorkspacesApiFp(configuration).getWorkspace(workspace, options)(fetch, basePath);
        },
        /**
         * List all workspaces in an organization.
         * @summary List Workspaces
         * @param {boolean} [fetch_across_regions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaces(fetch_across_regions?: boolean, options?: any) {
            return WorkspacesApiFp(configuration).listWorkspaces(fetch_across_regions, options)(fetch, basePath);
        },
        /**
         * Transfer ownership of a workspace to a new user.
         * @summary Transfer Ownership of a Workspace
         * @param {string} workspace name of the workspace
         * @param {TransferOwnershipRequest} body JSON Object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferOwnership(workspace: string, body: TransferOwnershipRequest, options?: any) {
            return WorkspacesApiFp(configuration).transferOwnership(workspace, body, options)(fetch, basePath);
        },
    };
};

/**
 * WorkspacesApi - object-oriented interface
 * @export
 * @class WorkspacesApi
 * @extends {BaseAPI}
 */
export class WorkspacesApi extends BaseAPI {
    /**
     * List workspaces under given workspace.
     * @summary List Workspaces in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public childWorkspaces(workspace: string, options?: any) {
        return WorkspacesApiFp(this.configuration).childWorkspaces(workspace, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new workspace.
     * @summary Create Workspace
     * @param {CreateWorkspaceRequest} body workspace details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public createWorkspace(body: CreateWorkspaceRequest, options?: any) {
        return WorkspacesApiFp(this.configuration).createWorkspace(body, options)(this.fetch, this.basePath);
    }

    /**
     * Remove a workspace.
     * @summary Delete Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public deleteWorkspace(workspace: string, options?: any) {
        return WorkspacesApiFp(this.configuration).deleteWorkspace(workspace, options)(this.fetch, this.basePath);
    }

    /**
     * Get information about a single workspace.
     * @summary Retrieve Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public getWorkspace(workspace: string, options?: any) {
        return WorkspacesApiFp(this.configuration).getWorkspace(workspace, options)(this.fetch, this.basePath);
    }

    /**
     * List all workspaces in an organization.
     * @summary List Workspaces
     * @param {boolean} [fetch_across_regions] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public listWorkspaces(fetch_across_regions?: boolean, options?: any) {
        return WorkspacesApiFp(this.configuration).listWorkspaces(fetch_across_regions, options)(this.fetch, this.basePath);
    }

    /**
     * Transfer ownership of a workspace to a new user.
     * @summary Transfer Ownership of a Workspace
     * @param {string} workspace name of the workspace
     * @param {TransferOwnershipRequest} body JSON Object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public transferOwnership(workspace: string, body: TransferOwnershipRequest, options?: any) {
        return WorkspacesApiFp(this.configuration).transferOwnership(workspace, body, options)(this.fetch, this.basePath);
    }

}


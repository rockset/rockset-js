// tslint:disable
/**
 * REST API
 * Rockset's REST API allows for creating and managing all resources in Rockset. Each supported endpoint is documented below.  All requests must be authorized with a Rockset API key, which can be created in the [Rockset console](https://console.rockset.com). The API key must be provided as `ApiKey <api_key>` in the `Authorization` request header. For example: ``` Authorization: ApiKey aB35kDjg93J5nsf4GjwMeErAVd832F7ad4vhsW1S02kfZiab42sTsfW5Sxt25asT ```  All endpoints are only accessible via https.  Build something awesome!
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://api.rs2.usw2.rockset.com".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AddDocumentsRequest
 */
export interface AddDocumentsRequest {
    /**
     * Array of JSON documents
     * @type {Array<any>}
     * @memberof AddDocumentsRequest
     */
    data: Array<any>;
}

/**
 * 
 * @export
 * @interface AddDocumentsResponse
 */
export interface AddDocumentsResponse {
    /**
     * information about the added documents
     * @type {Array<DocumentStatus>}
     * @memberof AddDocumentsResponse
     */
    data?: Array<DocumentStatus>;
}

/**
 * API keys are used to authenticate requests to Rockset's API. An API key is tied to the user who creates it. A new API key can be created for each use case, with a maximum of 10 API keys per user.
 * @export
 * @interface ApiKey
 */
export interface ApiKey {
    /**
     * ISO-8601 date
     * @type {string}
     * @memberof ApiKey
     */
    created_at?: string;
    /**
     * descriptive label
     * @type {string}
     * @memberof ApiKey
     */
    name: string;
    /**
     * string of 64 alphanumeric characters
     * @type {string}
     * @memberof ApiKey
     */
    key: string;
}

/**
 * 
 * @export
 * @interface AwsAccessKey
 */
export interface AwsAccessKey {
    /**
     * AWS access key ID
     * @type {string}
     * @memberof AwsAccessKey
     */
    aws_access_key_id: string;
    /**
     * AWS secret access key
     * @type {string}
     * @memberof AwsAccessKey
     */
    aws_secret_access_key: string;
}

/**
 * 
 * @export
 * @interface AwsRole
 */
export interface AwsRole {
    /**
     * ARN of rockset-role created in your account
     * @type {string}
     * @memberof AwsRole
     */
    aws_role_arn: string;
}

/**
 * 
 * @export
 * @interface Collection
 */
export interface Collection {
    /**
     * ISO-8601 date
     * @type {string}
     * @memberof Collection
     */
    created_at?: string;
    /**
     * email of user who created the collection
     * @type {string}
     * @memberof Collection
     */
    created_by?: string;
    /**
     * unique identifer for collection, can contain alphanumeric or dash characters
     * @type {string}
     * @memberof Collection
     */
    name?: string;
    /**
     * text describing the collection
     * @type {string}
     * @memberof Collection
     */
    description?: string;
    /**
     * name of the workspace that the collection is in
     * @type {string}
     * @memberof Collection
     */
    workspace?: string;
    /**
     * current status of collection, one of: CREATED, READY, DELETED
     * @type {string}
     * @memberof Collection
     */
    status?: Collection.StatusEnum;
    /**
     * list of sources from which collection ingests
     * @type {Array<Source>}
     * @memberof Collection
     */
    sources?: Array<Source>;
    /**
     * metrics about the collection
     * @type {CollectionStats}
     * @memberof Collection
     */
    stats?: CollectionStats;
    /**
     * number of seconds after which data is purged based on event time
     * @type {number}
     * @memberof Collection
     */
    retention_secs?: number;
    /**
     * list of mappings applied on all documents in a collection
     * @type {Array<FieldMappingV2>}
     * @memberof Collection
     */
    field_mappings?: Array<FieldMappingV2>;
}

/**
 * @export
 * @namespace Collection
 */
export namespace Collection {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        INITIALIZED = <any> 'INITIALIZED',
        CREATED = <any> 'CREATED',
        READY = <any> 'READY',
        PAUSED = <any> 'PAUSED',
        DELETED = <any> 'DELETED',
        PAUSING = <any> 'PAUSING',
        RESUMING = <any> 'RESUMING',
        BULKINGESTMODE = <any> 'BULK_INGEST_MODE',
        EXITINGBULKINGESTMODE = <any> 'EXITING_BULK_INGEST_MODE',
        UNKNOWN = <any> 'UNKNOWN'
    }
}

/**
 * 
 * @export
 * @interface CollectionStats
 */
export interface CollectionStats {
    /**
     * number of documents in the collection
     * @type {number}
     * @memberof CollectionStats
     */
    doc_count?: number;
    /**
     * total collection size in bytes
     * @type {number}
     * @memberof CollectionStats
     */
    total_size?: number;
    /**
     * number between 0 and 1 that indicates progress of collection creation
     * @type {number}
     * @memberof CollectionStats
     */
    fill_progress?: number;
    /**
     * number of documents purged from the collection
     * @type {number}
     * @memberof CollectionStats
     */
    purged_doc_count?: number;
    /**
     * total collection size in bytes purged
     * @type {number}
     * @memberof CollectionStats
     */
    purged_doc_size?: number;
    /**
     * milliseconds since Unix epoch Jan 1, 1970
     * @type {number}
     * @memberof CollectionStats
     */
    last_updated_ms?: number;
    /**
     * milliseconds since Unix epoch Jan 1, 1970
     * @type {number}
     * @memberof CollectionStats
     */
    last_queried_ms?: number;
    /**
     * total number of bytes inserted into the collection
     * @type {number}
     * @memberof CollectionStats
     */
    bytes_inserted?: number;
    /**
     * total number of bytes overwritten in writing into the collection
     * @type {number}
     * @memberof CollectionStats
     */
    bytes_overwritten?: number;
}

/**
 * 
 * @export
 * @interface CreateApiKeyRequest
 */
export interface CreateApiKeyRequest {
    /**
     * descriptive label
     * @type {string}
     * @memberof CreateApiKeyRequest
     */
    name: string;
}

/**
 * 
 * @export
 * @interface CreateApiKeyResponse
 */
export interface CreateApiKeyResponse {
    /**
     * the API key that was created
     * @type {ApiKey}
     * @memberof CreateApiKeyResponse
     */
    data?: ApiKey;
}

/**
 * 
 * @export
 * @interface CreateCollectionRequest
 */
export interface CreateCollectionRequest {
    /**
     * unique identifer for collection, can contain alphanumeric or dash characters
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    name: string;
    /**
     * text describing the collection
     * @type {string}
     * @memberof CreateCollectionRequest
     */
    description?: string;
    /**
     * list of sources from which to ingest data
     * @type {Array<Source>}
     * @memberof CreateCollectionRequest
     */
    sources?: Array<Source>;
    /**
     * number of seconds after which data is purged, based on event time
     * @type {number}
     * @memberof CreateCollectionRequest
     */
    retention_secs?: number;
    /**
     * configuration for event data
     * @type {EventTimeInfo}
     * @memberof CreateCollectionRequest
     */
    event_time_info?: EventTimeInfo;
    /**
     * list of mappings
     * @type {Array<FieldMappingV2>}
     * @memberof CreateCollectionRequest
     */
    field_mappings?: Array<FieldMappingV2>;
}

/**
 * 
 * @export
 * @interface CreateCollectionResponse
 */
export interface CreateCollectionResponse {
    /**
     * collection that was created
     * @type {Collection}
     * @memberof CreateCollectionResponse
     */
    data?: Collection;
}

/**
 * 
 * @export
 * @interface CreateIntegrationRequest
 */
export interface CreateIntegrationRequest {
    /**
     * descriptive label
     * @type {string}
     * @memberof CreateIntegrationRequest
     */
    name: string;
    /**
     * longer explanation for the integration
     * @type {string}
     * @memberof CreateIntegrationRequest
     */
    description?: string;
    /**
     * Amazon S3 details, must have one of aws_access_key or aws_role
     * @type {S3Integration}
     * @memberof CreateIntegrationRequest
     */
    s3?: S3Integration;
    /**
     * Amazon Kinesis details, must have one of aws_access_key or aws_role
     * @type {KinesisIntegration}
     * @memberof CreateIntegrationRequest
     */
    kinesis?: KinesisIntegration;
    /**
     * Amazon DynamoDB details, must have one of aws_access_key or aws_role
     * @type {DynamodbIntegration}
     * @memberof CreateIntegrationRequest
     */
    dynamodb?: DynamodbIntegration;
    /**
     * Amazon Redshift details
     * @type {RedshiftIntegration}
     * @memberof CreateIntegrationRequest
     */
    redshift?: RedshiftIntegration;
    /**
     * GCS details
     * @type {GcsIntegration}
     * @memberof CreateIntegrationRequest
     */
    gcs?: GcsIntegration;
    /**
     * 
     * @type {SegmentIntegration}
     * @memberof CreateIntegrationRequest
     */
    segment?: SegmentIntegration;
    /**
     * 
     * @type {KafkaIntegration}
     * @memberof CreateIntegrationRequest
     */
    kafka?: KafkaIntegration;
    /**
     * MongoDb details
     * @type {MongoDbIntegration}
     * @memberof CreateIntegrationRequest
     */
    mongodb?: MongoDbIntegration;
}

/**
 * 
 * @export
 * @interface CreateIntegrationResponse
 */
export interface CreateIntegrationResponse {
    /**
     * integration object that was created
     * @type {Integration}
     * @memberof CreateIntegrationResponse
     */
    data?: Integration;
}

/**
 * 
 * @export
 * @interface CreateQueryLambdaRequest
 */
export interface CreateQueryLambdaRequest {
    /**
     * Query Lambda name
     * @type {string}
     * @memberof CreateQueryLambdaRequest
     */
    name: string;
    /**
     * optional description
     * @type {string}
     * @memberof CreateQueryLambdaRequest
     */
    description?: string;
    /**
     * Query Lambda SQL query
     * @type {QueryLambdaSql}
     * @memberof CreateQueryLambdaRequest
     */
    sql: QueryLambdaSql;
}

/**
 * 
 * @export
 * @interface CreateQueryLambdaTagRequest
 */
export interface CreateQueryLambdaTagRequest {
    /**
     * name of Query Lambda tag
     * @type {string}
     * @memberof CreateQueryLambdaTagRequest
     */
    tag_name?: string;
    /**
     * hash identifying a Query Lambda tag
     * @type {string}
     * @memberof CreateQueryLambdaTagRequest
     */
    version?: string;
}

/**
 * 
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     * user email, must be unique
     * @type {string}
     * @memberof CreateUserRequest
     */
    email: string;
    /**
     * List of roles for a given user
     * @type {Array<string>}
     * @memberof CreateUserRequest
     */
    roles?: Array<string>;
}

/**
 * 
 * @export
 * @interface CreateUserResponse
 */
export interface CreateUserResponse {
    /**
     * user that was created
     * @type {User}
     * @memberof CreateUserResponse
     */
    data?: User;
}

/**
 * 
 * @export
 * @interface CreateWorkspaceRequest
 */
export interface CreateWorkspaceRequest {
    /**
     * descriptive label and unique identifier
     * @type {string}
     * @memberof CreateWorkspaceRequest
     */
    name: string;
    /**
     * longer explanation for the workspace
     * @type {string}
     * @memberof CreateWorkspaceRequest
     */
    description?: string;
}

/**
 * 
 * @export
 * @interface CreateWorkspaceResponse
 */
export interface CreateWorkspaceResponse {
    /**
     * the workspace that was created
     * @type {Workspace}
     * @memberof CreateWorkspaceResponse
     */
    data?: Workspace;
}

/**
 * 
 * @export
 * @interface CsvParams
 */
export interface CsvParams {
    /**
     * If the first line in every object specifies the column names
     * @type {boolean}
     * @memberof CsvParams
     */
    firstLineAsColumnNames?: boolean;
    /**
     * a single character that is the column separator
     * @type {string}
     * @memberof CsvParams
     */
    separator?: string;
    /**
     * can be one of: UTF-8, ISO_8859_1, UTF-16
     * @type {string}
     * @memberof CsvParams
     */
    encoding?: string;
    /**
     * names of columns
     * @type {Array<string>}
     * @memberof CsvParams
     */
    columnNames?: Array<string>;
    /**
     * names of columns
     * @type {Array<string>}
     * @memberof CsvParams
     */
    columnTypes?: Array<CsvParams.ColumnTypesEnum>;
    /**
     * character within which a cell value is enclosed,null character if no such character, default is '\"'
     * @type {string}
     * @memberof CsvParams
     */
    quoteChar?: string;
    /**
     * escape character removes any special meaning from the following character,default is '\\'
     * @type {string}
     * @memberof CsvParams
     */
    escapeChar?: string;
}

/**
 * @export
 * @namespace CsvParams
 */
export namespace CsvParams {
    /**
     * @export
     * @enum {string}
     */
    export enum ColumnTypesEnum {
        UNKNOWN = <any> 'UNKNOWN',
        BOOLEAN = <any> 'BOOLEAN',
        BOOL = <any> 'BOOL',
        INTEGER = <any> 'INTEGER',
        INT = <any> 'INT',
        FLOAT = <any> 'FLOAT',
        TIME = <any> 'TIME',
        DATE = <any> 'DATE',
        DATETIME = <any> 'DATETIME',
        TIMESTAMP = <any> 'TIMESTAMP',
        STRING = <any> 'STRING'
    }
}

/**
 * 
 * @export
 * @interface DeleteApiKeyResponse
 */
export interface DeleteApiKeyResponse {
    /**
     * the API key that was deleted
     * @type {ApiKey}
     * @memberof DeleteApiKeyResponse
     */
    data?: ApiKey;
}

/**
 * 
 * @export
 * @interface DeleteCollectionResponse
 */
export interface DeleteCollectionResponse {
    /**
     * collection that was deleted
     * @type {Collection}
     * @memberof DeleteCollectionResponse
     */
    data?: Collection;
}

/**
 * 
 * @export
 * @interface DeleteDocumentsRequest
 */
export interface DeleteDocumentsRequest {
    /**
     * array of document IDs
     * @type {Array<DeleteDocumentsRequestData>}
     * @memberof DeleteDocumentsRequest
     */
    data: Array<DeleteDocumentsRequestData>;
}

/**
 * 
 * @export
 * @interface DeleteDocumentsRequestData
 */
export interface DeleteDocumentsRequestData {
    /**
     * unique document ID
     * @type {string}
     * @memberof DeleteDocumentsRequestData
     */
    _id: string;
}

/**
 * 
 * @export
 * @interface DeleteDocumentsResponse
 */
export interface DeleteDocumentsResponse {
    /**
     * information about deleted documents
     * @type {Array<DocumentStatus>}
     * @memberof DeleteDocumentsResponse
     */
    data?: Array<DocumentStatus>;
}

/**
 * 
 * @export
 * @interface DeleteIntegrationResponse
 */
export interface DeleteIntegrationResponse {
    /**
     * integration object that was deleted
     * @type {Integration}
     * @memberof DeleteIntegrationResponse
     */
    data?: Integration;
}

/**
 * 
 * @export
 * @interface DeleteQueryLambdaResponse
 */
export interface DeleteQueryLambdaResponse {
    /**
     * Query Lambda details
     * @type {QueryLambda}
     * @memberof DeleteQueryLambdaResponse
     */
    data?: QueryLambda;
}

/**
 * 
 * @export
 * @interface DeleteUserResponse
 */
export interface DeleteUserResponse {
    /**
     * user object that was deleted
     * @type {User}
     * @memberof DeleteUserResponse
     */
    data?: User;
}

/**
 * 
 * @export
 * @interface DeleteWorkspaceResponse
 */
export interface DeleteWorkspaceResponse {
    /**
     * the workspace that was deleted
     * @type {Workspace}
     * @memberof DeleteWorkspaceResponse
     */
    data?: Workspace;
}

/**
 * 
 * @export
 * @interface DocumentStatus
 */
export interface DocumentStatus {
    /**
     * collection name
     * @type {string}
     * @memberof DocumentStatus
     */
    _collection?: string;
    /**
     * error message, if any
     * @type {ErrorModel}
     * @memberof DocumentStatus
     */
    error?: ErrorModel;
    /**
     * unique document ID
     * @type {string}
     * @memberof DocumentStatus
     */
    _id?: string;
    /**
     * status, one of ADDED, REPLACED, DELETED, ERROR
     * @type {string}
     * @memberof DocumentStatus
     */
    status?: DocumentStatus.StatusEnum;
    /**
     * unique id used to represent each patch request
     * @type {string}
     * @memberof DocumentStatus
     */
    patch_id?: string;
}

/**
 * @export
 * @namespace DocumentStatus
 */
export namespace DocumentStatus {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        ADDED = <any> 'ADDED',
        REPLACED = <any> 'REPLACED',
        DELETED = <any> 'DELETED',
        PATCHED = <any> 'PATCHED',
        ERROR = <any> 'ERROR'
    }
}

/**
 * 
 * @export
 * @interface DynamodbIntegration
 */
export interface DynamodbIntegration {
    /**
     * credentials for an AWS access key integration
     * @type {AwsAccessKey}
     * @memberof DynamodbIntegration
     */
    aws_access_key?: AwsAccessKey;
    /**
     * role used for external id type authentication
     * @type {AwsRole}
     * @memberof DynamodbIntegration
     */
    aws_role?: AwsRole;
}

/**
 * Describes details about an error
 * @export
 * @interface ErrorModel
 */
export interface ErrorModel {
    /**
     * descriptive message about the error
     * @type {string}
     * @memberof ErrorModel
     */
    message?: string;
    /**
     * category of the error
     * @type {string}
     * @memberof ErrorModel
     */
    type?: ErrorModel.TypeEnum;
    /**
     * Line where the error happened (if applicable)
     * @type {number}
     * @memberof ErrorModel
     */
    line?: number;
    /**
     * Column where the error happened (if applicable)
     * @type {number}
     * @memberof ErrorModel
     */
    column?: number;
    /**
     * Internal trace ID to help with debugging
     * @type {string}
     * @memberof ErrorModel
     */
    trace_id?: string;
}

/**
 * @export
 * @namespace ErrorModel
 */
export namespace ErrorModel {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        AUTHEXCEPTION = <any> 'AUTHEXCEPTION',
        VERSIONEXCEPTION = <any> 'VERSIONEXCEPTION',
        INTERNALERROR = <any> 'INTERNALERROR',
        INVALIDINPUT = <any> 'INVALIDINPUT',
        NOTIMPLEMENTEDYET = <any> 'NOTIMPLEMENTEDYET',
        RESOURCEEXCEEDED = <any> 'RESOURCEEXCEEDED',
        ALREADYEXISTS = <any> 'ALREADYEXISTS',
        NOTALLOWED = <any> 'NOTALLOWED',
        NOTFOUND = <any> 'NOTFOUND',
        DEPENDENTRESOURCES = <any> 'DEPENDENTRESOURCES',
        QUERYERROR = <any> 'QUERY_ERROR',
        NOTREADY = <any> 'NOT_READY',
        FORBIDDEN = <any> 'FORBIDDEN',
        QUERYTIMEOUT = <any> 'QUERY_TIMEOUT',
        INTEGRATIONNOTFOUND = <any> 'INTEGRATION_NOT_FOUND',
        ROLENOTFOUND = <any> 'ROLE_NOT_FOUND',
        CONNECTIONERROR = <any> 'CONNECTION_ERROR',
        CREATING = <any> 'CREATING',
        BADREQUEST = <any> 'BADREQUEST',
        RATELIMITEXCEEDED = <any> 'RATELIMITEXCEEDED'
    }
}

/**
 * 
 * @export
 * @interface EventTimeInfo
 */
export interface EventTimeInfo {
    /**
     * name of the field containing event time
     * @type {string}
     * @memberof EventTimeInfo
     */
    field: string;
    /**
     * format of time field, can be one of: milliseconds_since_epoch, seconds_since_epoch
     * @type {string}
     * @memberof EventTimeInfo
     */
    format?: string;
    /**
     * default time zone, in standard IANA format
     * @type {string}
     * @memberof EventTimeInfo
     */
    time_zone?: string;
}

/**
 * 
 * @export
 * @interface ExecuteQueryLambdaRequest
 */
export interface ExecuteQueryLambdaRequest {
    /**
     * list of named parameters
     * @type {Array<QueryParameter>}
     * @memberof ExecuteQueryLambdaRequest
     */
    parameters?: Array<QueryParameter>;
    /**
     * Row limit to use if no limit specified in the SQL query text
     * @type {number}
     * @memberof ExecuteQueryLambdaRequest
     */
    default_row_limit?: number;
    /**
     * Whether to generate warnings
     * @type {boolean}
     * @memberof ExecuteQueryLambdaRequest
     */
    generate_warnings?: boolean;
}

/**
 * 
 * @export
 * @interface FieldMapping
 */
export interface FieldMapping {
}

/**
 * 
 * @export
 * @interface FieldMappingV2
 */
export interface FieldMappingV2 {
    /**
     * A user specified string that is a name for this mapping
     * @type {string}
     * @memberof FieldMappingV2
     */
    name?: string;
    /**
     * A boolean that determines whether to drop all fields in this document. If set, input and output fields should not be set
     * @type {boolean}
     * @memberof FieldMappingV2
     */
    is_drop_all_fields?: boolean;
    /**
     * A List of InputField for this mapping
     * @type {Array<InputField>}
     * @memberof FieldMappingV2
     */
    input_fields?: Array<InputField>;
    /**
     * An OutputField for this mapping
     * @type {OutputField}
     * @memberof FieldMappingV2
     */
    output_field?: OutputField;
}

/**
 * 
 * @export
 * @interface FieldMask
 */
export interface FieldMask {
    /**
     * 
     * @type {Array<string>}
     * @memberof FieldMask
     */
    input_path: Array<string>;
    /**
     * 
     * @type {FieldMaskMask}
     * @memberof FieldMask
     */
    mask?: FieldMaskMask;
}

/**
 * Field masking function name + args. The args is a JSON object.
 * @export
 * @interface FieldMaskMask
 */
export interface FieldMaskMask {
    /**
     * 
     * @type {string}
     * @memberof FieldMaskMask
     */
    name: string;
    /**
     * 
     * @type {any}
     * @memberof FieldMaskMask
     */
    args?: any;
}

/**
 * 
 * @export
 * @interface FormatParams
 */
export interface FormatParams {
    /**
     * source data is in json format
     * @type {boolean}
     * @memberof FormatParams
     */
    json?: boolean;
    /**
     * 
     * @type {CsvParams}
     * @memberof FormatParams
     */
    csv?: CsvParams;
    /**
     * 
     * @type {XmlParams}
     * @memberof FormatParams
     */
    xml?: XmlParams;
}

/**
 * 
 * @export
 * @interface GcpServiceAccount
 */
export interface GcpServiceAccount {
    /**
     * Contents of JSON Service Account key file
     * @type {string}
     * @memberof GcpServiceAccount
     */
    service_account_key_file_json: string;
}

/**
 * 
 * @export
 * @interface GcsIntegration
 */
export interface GcsIntegration {
    /**
     * credentials for an AWS key integration
     * @type {GcpServiceAccount}
     * @memberof GcsIntegration
     */
    gcp_service_account?: GcpServiceAccount;
}

/**
 * 
 * @export
 * @interface GetCollectionResponse
 */
export interface GetCollectionResponse {
    /**
     * collection that was requested
     * @type {Collection}
     * @memberof GetCollectionResponse
     */
    data?: Collection;
}

/**
 * 
 * @export
 * @interface GetIntegrationResponse
 */
export interface GetIntegrationResponse {
    /**
     * integration object
     * @type {Integration}
     * @memberof GetIntegrationResponse
     */
    data?: Integration;
    /**
     * 
     * @type {Array<Collection>}
     * @memberof GetIntegrationResponse
     */
    collections?: Array<Collection>;
}

/**
 * 
 * @export
 * @interface GetWorkspaceResponse
 */
export interface GetWorkspaceResponse {
    /**
     * the workspace that was requested
     * @type {Workspace}
     * @memberof GetWorkspaceResponse
     */
    data?: Workspace;
}

/**
 * 
 * @export
 * @interface InputField
 */
export interface InputField {
    /**
     * The name of a field, parsed as a SQL qualified name
     * @type {string}
     * @memberof InputField
     */
    field_name?: string;
    /**
     * Define the behaviour if fieldName is missing or is null
     * @type {string}
     * @memberof InputField
     */
    if_missing?: InputField.IfMissingEnum;
    /**
     * If true, then drop fieldName from the document
     * @type {boolean}
     * @memberof InputField
     */
    is_drop?: boolean;
    /**
     * Sql parameter name
     * @type {string}
     * @memberof InputField
     */
    param?: string;
}

/**
 * @export
 * @namespace InputField
 */
export namespace InputField {
    /**
     * @export
     * @enum {string}
     */
    export enum IfMissingEnum {
        SKIP = <any> 'SKIP',
        PASS = <any> 'PASS'
    }
}

/**
 * Integrations that can be associated with data sources to create collections. Only one type of integration may be specified.
 * @export
 * @interface Integration
 */
export interface Integration {
    /**
     * descriptive label and unique identifier
     * @type {string}
     * @memberof Integration
     */
    name: string;
    /**
     * longer explanation for the integration
     * @type {string}
     * @memberof Integration
     */
    description?: string;
    /**
     * email of user who created the integration
     * @type {string}
     * @memberof Integration
     */
    created_by: string;
    /**
     * ISO-8601 date
     * @type {string}
     * @memberof Integration
     */
    created_at?: string;
    /**
     * Amazon S3 details, must have one of aws_access_key or aws_role
     * @type {S3Integration}
     * @memberof Integration
     */
    s3?: S3Integration;
    /**
     * Amazon Kinesis details, must have one of aws_access_key or aws_role
     * @type {KinesisIntegration}
     * @memberof Integration
     */
    kinesis?: KinesisIntegration;
    /**
     * Amazon DynamoDB details, must have one of aws_access_key or aws_role
     * @type {DynamodbIntegration}
     * @memberof Integration
     */
    dynamodb?: DynamodbIntegration;
    /**
     * Amazon Redshift details
     * @type {RedshiftIntegration}
     * @memberof Integration
     */
    redshift?: RedshiftIntegration;
    /**
     * GCS details
     * @type {GcsIntegration}
     * @memberof Integration
     */
    gcs?: GcsIntegration;
    /**
     * Segment details
     * @type {SegmentIntegration}
     * @memberof Integration
     */
    segment?: SegmentIntegration;
    /**
     * Kafka details
     * @type {KafkaIntegration}
     * @memberof Integration
     */
    kafka?: KafkaIntegration;
    /**
     * MongoDb details
     * @type {MongoDbIntegration}
     * @memberof Integration
     */
    mongodb?: MongoDbIntegration;
}

/**
 * 
 * @export
 * @interface KafkaIntegration
 */
export interface KafkaIntegration {
    /**
     * Kafka topics to tail
     * @type {Array<string>}
     * @memberof KafkaIntegration
     */
    kafka_topic_names: Array<string>;
    /**
     * The status of the Kafka source by topic
     * @type {{ [key: string]: StatusKafka; }}
     * @memberof KafkaIntegration
     */
    source_status_by_topic?: { [key: string]: StatusKafka; };
    /**
     * The format of the Kafka topics being tailed
     * @type {string}
     * @memberof KafkaIntegration
     */
    kafka_data_format: KafkaIntegration.KafkaDataFormatEnum;
    /**
     * segment connection string
     * @type {string}
     * @memberof KafkaIntegration
     */
    connection_string?: string;
}

/**
 * @export
 * @namespace KafkaIntegration
 */
export namespace KafkaIntegration {
    /**
     * @export
     * @enum {string}
     */
    export enum KafkaDataFormatEnum {
        JSON = <any> 'JSON',
        AVRO = <any> 'AVRO'
    }
}

/**
 * 
 * @export
 * @interface KinesisIntegration
 */
export interface KinesisIntegration {
    /**
     * credentials for an AWS access key integration
     * @type {AwsAccessKey}
     * @memberof KinesisIntegration
     */
    aws_access_key?: AwsAccessKey;
    /**
     * details of an AWS cross-account role integration
     * @type {AwsRole}
     * @memberof KinesisIntegration
     */
    aws_role?: AwsRole;
}

/**
 * 
 * @export
 * @interface ListApiKeysResponse
 */
export interface ListApiKeysResponse {
    /**
     * list of API key objects
     * @type {Array<ApiKey>}
     * @memberof ListApiKeysResponse
     */
    data?: Array<ApiKey>;
}

/**
 * 
 * @export
 * @interface ListCollectionsResponse
 */
export interface ListCollectionsResponse {
    /**
     * list of all collections
     * @type {Array<Collection>}
     * @memberof ListCollectionsResponse
     */
    data?: Array<Collection>;
}

/**
 * 
 * @export
 * @interface ListIntegrationsResponse
 */
export interface ListIntegrationsResponse {
    /**
     * list of integration objects
     * @type {Array<Integration>}
     * @memberof ListIntegrationsResponse
     */
    data?: Array<Integration>;
}

/**
 * 
 * @export
 * @interface ListQueryLambdaTagsResponse
 */
export interface ListQueryLambdaTagsResponse {
    /**
     * list of all tags associated with a Query Lambda
     * @type {Array<QueryLambdaTag>}
     * @memberof ListQueryLambdaTagsResponse
     */
    data?: Array<QueryLambdaTag>;
}

/**
 * 
 * @export
 * @interface ListQueryLambdaVersionsResponse
 */
export interface ListQueryLambdaVersionsResponse {
    /**
     * list of all versions for a particular Query Lambda
     * @type {Array<QueryLambdaVersion>}
     * @memberof ListQueryLambdaVersionsResponse
     */
    data?: Array<QueryLambdaVersion>;
}

/**
 * 
 * @export
 * @interface ListQueryLambdasResponse
 */
export interface ListQueryLambdasResponse {
    /**
     * list of all Query Lambdas
     * @type {Array<QueryLambda>}
     * @memberof ListQueryLambdasResponse
     */
    data?: Array<QueryLambda>;
}

/**
 * 
 * @export
 * @interface ListUsersResponse
 */
export interface ListUsersResponse {
    /**
     * list of users
     * @type {Array<User>}
     * @memberof ListUsersResponse
     */
    data?: Array<User>;
}

/**
 * 
 * @export
 * @interface ListWorkspacesResponse
 */
export interface ListWorkspacesResponse {
    /**
     * list of workspaces
     * @type {Array<Workspace>}
     * @memberof ListWorkspacesResponse
     */
    data?: Array<Workspace>;
}

/**
 * 
 * @export
 * @interface MongoDbIntegration
 */
export interface MongoDbIntegration {
    /**
     * MongoDB connection URI string
     * @type {string}
     * @memberof MongoDbIntegration
     */
    connection_uri: string;
}

/**
 * An organization in Rockset is a container for users and collections.
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * unique identifier for the organization
     * @type {string}
     * @memberof Organization
     */
    id?: string;
    /**
     * ISO-8601 date
     * @type {string}
     * @memberof Organization
     */
    created_at?: string;
    /**
     * name of the organization
     * @type {string}
     * @memberof Organization
     */
    display_name?: string;
    /**
     * name of the company
     * @type {string}
     * @memberof Organization
     */
    company_name?: string;
    /**
     * organization's unique external ID within Rockset
     * @type {string}
     * @memberof Organization
     */
    external_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    rockset_user?: string;
    /**
     * org state
     * @type {string}
     * @memberof Organization
     */
    state?: Organization.StateEnum;
}

/**
 * @export
 * @namespace Organization
 */
export namespace Organization {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        FREE = <any> 'FREE',
        PAID = <any> 'PAID',
        TRIAL = <any> 'TRIAL',
        TRIALEXPIRED = <any> 'TRIAL_EXPIRED',
        TRIALDEPLETED = <any> 'TRIAL_DEPLETED',
        DELETED = <any> 'DELETED'
    }
}

/**
 * 
 * @export
 * @interface OrganizationResponse
 */
export interface OrganizationResponse {
    /**
     * Organization object
     * @type {Organization}
     * @memberof OrganizationResponse
     */
    data?: Organization;
}

/**
 * 
 * @export
 * @interface OutputField
 */
export interface OutputField {
    /**
     * The name of a field, parsed as a SQL qualified name 
     * @type {string}
     * @memberof OutputField
     */
    field_name?: string;
    /**
     * The name of a sql function
     * @type {SqlExpression}
     * @memberof OutputField
     */
    value?: SqlExpression;
    /**
     * Error in Mapping execution: 'skip' or 'fail' 
     * @type {string}
     * @memberof OutputField
     */
    on_error?: OutputField.OnErrorEnum;
}

/**
 * @export
 * @namespace OutputField
 */
export namespace OutputField {
    /**
     * @export
     * @enum {string}
     */
    export enum OnErrorEnum {
        SKIP = <any> 'SKIP',
        FAIL = <any> 'FAIL'
    }
}

/**
 * 
 * @export
 * @interface PatchDocument
 */
export interface PatchDocument {
    /**
     * Unique id of the document which is being patched
     * @type {string}
     * @memberof PatchDocument
     */
    _id: string;
    /**
     * List of patch operations
     * @type {Array<PatchOperation>}
     * @memberof PatchDocument
     */
    patch: Array<PatchOperation>;
}

/**
 * 
 * @export
 * @interface PatchDocumentsRequest
 */
export interface PatchDocumentsRequest {
    /**
     * List of JSON Patch Documents
     * @type {Array<PatchDocument>}
     * @memberof PatchDocumentsRequest
     */
    data: Array<PatchDocument>;
}

/**
 * 
 * @export
 * @interface PatchDocumentsResponse
 */
export interface PatchDocumentsResponse {
    /**
     * 
     * @type {Array<DocumentStatus>}
     * @memberof PatchDocumentsResponse
     */
    data: Array<DocumentStatus>;
}

/**
 * 
 * @export
 * @interface PatchOperation
 */
export interface PatchOperation {
    /**
     * Operation to be performed in this patch
     * @type {string}
     * @memberof PatchOperation
     */
    op: PatchOperation.OpEnum;
    /**
     * JSON-Pointer referencing a location in the target document where theoperation is performed
     * @type {string}
     * @memberof PatchOperation
     */
    path: string;
    /**
     * Value used in the patch operation. Required for add, replace and test operations
     * @type {any}
     * @memberof PatchOperation
     */
    value?: any;
    /**
     * JSON-Pointer referencing a location in the target document.Required for copy and move operations
     * @type {string}
     * @memberof PatchOperation
     */
    from?: string;
}

/**
 * @export
 * @namespace PatchOperation
 */
export namespace PatchOperation {
    /**
     * @export
     * @enum {string}
     */
    export enum OpEnum {
        ADD = <any> 'ADD',
        REPLACE = <any> 'REPLACE',
        REMOVE = <any> 'REMOVE',
        COPY = <any> 'COPY',
        MOVE = <any> 'MOVE',
        TEST = <any> 'TEST'
    }
}

/**
 * 
 * @export
 * @interface QueryFieldType
 */
export interface QueryFieldType {
    /**
     * name of the field
     * @type {string}
     * @memberof QueryFieldType
     */
    name: string;
    /**
     * data type of the field
     * @type {string}
     * @memberof QueryFieldType
     */
    type: string;
}

/**
 * 
 * @export
 * @interface QueryLambda
 */
export interface QueryLambda {
    /**
     * workspace of this Query Lambda
     * @type {string}
     * @memberof QueryLambda
     */
    workspace?: string;
    /**
     * user that created this Query Lambda
     * @type {string}
     * @memberof QueryLambda
     */
    last_updated_by?: string;
    /**
     * ISO-8601 date of when Query Lambda was last updated
     * @type {string}
     * @memberof QueryLambda
     */
    last_updated?: string;
    /**
     * Query Lambda name
     * @type {string}
     * @memberof QueryLambda
     */
    name?: string;
    /**
     * number of Query Lambda versions
     * @type {number}
     * @memberof QueryLambda
     */
    version_count?: number;
    /**
     * collections queried by underlying SQL query
     * @type {Array<string>}
     * @memberof QueryLambda
     */
    collections?: Array<string>;
}

/**
 * 
 * @export
 * @interface QueryLambdaSql
 */
export interface QueryLambdaSql {
    /**
     * SQL text
     * @type {string}
     * @memberof QueryLambdaSql
     */
    query: string;
    /**
     * default parameters for this Query Lambda
     * @type {Array<QueryParameter>}
     * @memberof QueryLambdaSql
     */
    default_parameters?: Array<QueryParameter>;
}

/**
 * 
 * @export
 * @interface QueryLambdaStats
 */
export interface QueryLambdaStats {
    /**
     * ISO-8601 date
     * @type {string}
     * @memberof QueryLambdaStats
     */
    last_executed?: string;
    /**
     * user who last executed Query Lambda
     * @type {string}
     * @memberof QueryLambdaStats
     */
    last_executed_by?: string;
    /**
     * ISO-8601 date of last execution failure
     * @type {string}
     * @memberof QueryLambdaStats
     */
    last_execution_error?: string;
    /**
     * error message associated with last failed execution
     * @type {string}
     * @memberof QueryLambdaStats
     */
    last_execution_error_message?: string;
}

/**
 * 
 * @export
 * @interface QueryLambdaTag
 */
export interface QueryLambdaTag {
    /**
     * name of Query Lambda tag
     * @type {string}
     * @memberof QueryLambdaTag
     */
    tag_name?: string;
    /**
     * query lambda version
     * @type {QueryLambdaVersion}
     * @memberof QueryLambdaTag
     */
    version?: QueryLambdaVersion;
}

/**
 * 
 * @export
 * @interface QueryLambdaTagResponse
 */
export interface QueryLambdaTagResponse {
    /**
     * updated Query Lambda tag
     * @type {QueryLambdaTag}
     * @memberof QueryLambdaTagResponse
     */
    data?: QueryLambdaTag;
}

/**
 * 
 * @export
 * @interface QueryLambdaVersion
 */
export interface QueryLambdaVersion {
    /**
     * workspace of this Query Lambda
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    workspace?: string;
    /**
     * user that created this Query Lambda
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    created_by?: string;
    /**
     * ISO-8601 date of when Query Lambda was created
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    created_at?: string;
    /**
     * Query Lambda name
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    name?: string;
    /**
     * Query Lambda version
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    version?: string;
    /**
     * optional description
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    description?: string;
    /**
     * Query Lambda SQL query
     * @type {QueryLambdaSql}
     * @memberof QueryLambdaVersion
     */
    sql?: QueryLambdaSql;
    /**
     * collections queried by underlying SQL query
     * @type {Array<string>}
     * @memberof QueryLambdaVersion
     */
    collections?: Array<string>;
    /**
     * status of this Query Lambda
     * @type {string}
     * @memberof QueryLambdaVersion
     */
    state?: QueryLambdaVersion.StateEnum;
    /**
     * stats related to this Query Lambda
     * @type {QueryLambdaStats}
     * @memberof QueryLambdaVersion
     */
    stats?: QueryLambdaStats;
}

/**
 * @export
 * @namespace QueryLambdaVersion
 */
export namespace QueryLambdaVersion {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        ACTIVE = <any> 'ACTIVE',
        INVALIDSQL = <any> 'INVALID_SQL'
    }
}

/**
 * 
 * @export
 * @interface QueryLambdaVersionResponse
 */
export interface QueryLambdaVersionResponse {
    /**
     * Query Lambda version details
     * @type {QueryLambdaVersion}
     * @memberof QueryLambdaVersionResponse
     */
    data?: QueryLambdaVersion;
}

/**
 * 
 * @export
 * @interface QueryParameter
 */
export interface QueryParameter {
    /**
     * name of the field
     * @type {string}
     * @memberof QueryParameter
     */
    name: string;
    /**
     * data type of the field
     * @type {string}
     * @memberof QueryParameter
     */
    type: string;
    /**
     * literal value of the field
     * @type {string}
     * @memberof QueryParameter
     */
    value: string;
}

/**
 * 
 * @export
 * @interface QueryRequest
 */
export interface QueryRequest {
    /**
     * details about the query
     * @type {QueryRequestSql}
     * @memberof QueryRequest
     */
    sql?: QueryRequestSql;
}

/**
 * 
 * @export
 * @interface QueryRequestSql
 */
export interface QueryRequestSql {
    /**
     * list of named parameters
     * @type {Array<QueryParameter>}
     * @memberof QueryRequestSql
     */
    parameters?: Array<QueryParameter>;
    /**
     * SQL query as a string
     * @type {string}
     * @memberof QueryRequestSql
     */
    query: string;
    /**
     * Row limit to use if no limit specified in the query
     * @type {number}
     * @memberof QueryRequestSql
     */
    default_row_limit?: number;
    /**
     * Whether to generate warnings
     * @type {boolean}
     * @memberof QueryRequestSql
     */
    generate_warnings?: boolean;
    /**
     * Whether to generate a performance profile for this query
     * @type {boolean}
     * @memberof QueryRequestSql
     */
    profiling_enabled?: boolean;
}

/**
 * 
 * @export
 * @interface QueryResponse
 */
export interface QueryResponse {
    /**
     * unique id for this query
     * @type {string}
     * @memberof QueryResponse
     */
    query_id?: string;
    /**
     * list of collections queried by the query
     * @type {Array<string>}
     * @memberof QueryResponse
     */
    collections?: Array<string>;
    /**
     * list of objects returned by the query
     * @type {Array<any>}
     * @memberof QueryResponse
     */
    results?: Array<any>;
    /**
     * meta information about the query
     * @type {QueryResponseStats}
     * @memberof QueryResponse
     */
    stats?: QueryResponseStats;
    /**
     * warnings received from the query
     * @type {Array<string>}
     * @memberof QueryResponse
     */
    warnings?: Array<string>;
    /**
     * meta information about each column in the result set
     * @type {Array<QueryFieldType>}
     * @memberof QueryResponse
     */
    column_fields?: Array<QueryFieldType>;
}

/**
 * 
 * @export
 * @interface QueryResponseStats
 */
export interface QueryResponseStats {
    /**
     * query time in milliseconds
     * @type {number}
     * @memberof QueryResponseStats
     */
    elapsed_time_ms?: number;
}

/**
 * 
 * @export
 * @interface RedshiftIntegration
 */
export interface RedshiftIntegration {
    /**
     * AWS access key credentials
     * @type {AwsAccessKey}
     * @memberof RedshiftIntegration
     */
    aws_access_key?: AwsAccessKey;
    /**
     * Username associated with Redshift cluster
     * @type {string}
     * @memberof RedshiftIntegration
     */
    username: string;
    /**
     * Password associated with Redshift cluster
     * @type {string}
     * @memberof RedshiftIntegration
     */
    password: string;
    /**
     * Redshift Cluster host
     * @type {string}
     * @memberof RedshiftIntegration
     */
    host: string;
    /**
     * Redshift Cluster port
     * @type {number}
     * @memberof RedshiftIntegration
     */
    port: number;
    /**
     * unload S3 bucket path
     * @type {string}
     * @memberof RedshiftIntegration
     */
    s3_bucket_path: string;
}

/**
 * 
 * @export
 * @interface S3Integration
 */
export interface S3Integration {
    /**
     * credentials for an AWS access key integration
     * @type {AwsAccessKey}
     * @memberof S3Integration
     */
    aws_access_key?: AwsAccessKey;
    /**
     * details of an AWS cross-account role integration
     * @type {AwsRole}
     * @memberof S3Integration
     */
    aws_role?: AwsRole;
}

/**
 * 
 * @export
 * @interface SegmentIntegration
 */
export interface SegmentIntegration {
    /**
     * segment connection string
     * @type {string}
     * @memberof SegmentIntegration
     */
    connection_string?: string;
}

/**
 * Details about the data source for the given collection. Only one of the following fields are allowed to be defined. Only collections can act as data sources for views. 
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * name of integration to use
     * @type {string}
     * @memberof Source
     */
    integration_name: string;
    /**
     * configuration for ingestion from S3
     * @type {SourceS3}
     * @memberof Source
     */
    s3?: SourceS3;
    /**
     * configuration for ingestion from kinesis stream
     * @type {SourceKinesis}
     * @memberof Source
     */
    kinesis?: SourceKinesis;
    /**
     * configuration for ingestion from GCS
     * @type {SourceGcs}
     * @memberof Source
     */
    gcs?: SourceGcs;
    /**
     * configuration for ingestion from Redshift
     * @type {SourceRedshift}
     * @memberof Source
     */
    redshift?: SourceRedshift;
    /**
     * configuration for ingestion from  a dynamodb table
     * @type {SourceDynamoDb}
     * @memberof Source
     */
    dynamodb?: SourceDynamoDb;
    /**
     * file upload details
     * @type {SourceFileUpload}
     * @memberof Source
     */
    file_upload?: SourceFileUpload;
    /**
     * kafka collection identifier
     * @type {SourceKafka}
     * @memberof Source
     */
    kafka?: SourceKafka;
    /**
     * MongoDB collection details
     * @type {SourceMongoDb}
     * @memberof Source
     */
    mongodb?: SourceMongoDb;
    /**
     * the ingest status of this source
     * @type {Status}
     * @memberof Source
     */
    status?: Status;
    /**
     * format parameters for data from this source
     * @type {FormatParams}
     * @memberof Source
     */
    format_params?: FormatParams;
}

/**
 * 
 * @export
 * @interface SourceDynamoDb
 */
export interface SourceDynamoDb {
    /**
     * AWS region name of DynamoDB table, by default us-west-2 is used
     * @type {string}
     * @memberof SourceDynamoDb
     */
    aws_region?: string;
    /**
     * name of DynamoDB table containing data
     * @type {string}
     * @memberof SourceDynamoDb
     */
    table_name: string;
    /**
     * DynamoDB source status
     * @type {StatusDynamoDb}
     * @memberof SourceDynamoDb
     */
    status?: StatusDynamoDb;
    /**
     * Max RCU usage for scan
     * @type {number}
     * @memberof SourceDynamoDb
     */
    rcu?: number;
}

/**
 * 
 * @export
 * @interface SourceFileUpload
 */
export interface SourceFileUpload {
    /**
     * name of the file
     * @type {string}
     * @memberof SourceFileUpload
     */
    file_name: string;
    /**
     * size of the file in bytes
     * @type {number}
     * @memberof SourceFileUpload
     */
    file_size: number;
    /**
     * time of file upload
     * @type {string}
     * @memberof SourceFileUpload
     */
    file_upload_time: string;
}

/**
 * 
 * @export
 * @interface SourceGcs
 */
export interface SourceGcs {
    /**
     * name of GCS bucket you want to ingest from
     * @type {string}
     * @memberof SourceGcs
     */
    bucket?: string;
    /**
     * Prefix that selects keys to ingest.
     * @type {string}
     * @memberof SourceGcs
     */
    prefix?: string;
}

/**
 * 
 * @export
 * @interface SourceKafka
 */
export interface SourceKafka {
    /**
     * The Kafka topic to be tailed
     * @type {string}
     * @memberof SourceKafka
     */
    kafka_topic_name: string;
    /**
     * Kafka source status
     * @type {StatusKafka}
     * @memberof SourceKafka
     */
    status?: StatusKafka;
}

/**
 * 
 * @export
 * @interface SourceKinesis
 */
export interface SourceKinesis {
    /**
     * name of kinesis stream
     * @type {string}
     * @memberof SourceKinesis
     */
    stream_name: string;
    /**
     * AWS region name of Kinesis stream, by default us-west-2 is used
     * @type {string}
     * @memberof SourceKinesis
     */
    aws_region?: string;
}

/**
 * 
 * @export
 * @interface SourceMongoDb
 */
export interface SourceMongoDb {
    /**
     * MongoDB database name containing this collection
     * @type {string}
     * @memberof SourceMongoDb
     */
    database_name: string;
    /**
     * MongoDB collection name
     * @type {string}
     * @memberof SourceMongoDb
     */
    collection_name: string;
    /**
     * MongoDB source status
     * @type {StatusMongoDb}
     * @memberof SourceMongoDb
     */
    status?: StatusMongoDb;
}

/**
 * 
 * @export
 * @interface SourceRedshift
 */
export interface SourceRedshift {
    /**
     * name of the database in Redshift Cluster
     * @type {string}
     * @memberof SourceRedshift
     */
    database: string;
    /**
     * schema which contains the Redshift table
     * @type {string}
     * @memberof SourceRedshift
     */
    schema: string;
    /**
     * name of Redshift table containing data
     * @type {string}
     * @memberof SourceRedshift
     */
    table_name: string;
    /**
     * field in Redshift source table to monitor for updates
     * @type {string}
     * @memberof SourceRedshift
     */
    incremental_field?: string;
}

/**
 * 
 * @export
 * @interface SourceS3
 */
export interface SourceS3 {
    /**
     * Prefix that selects keys to ingest.
     * @type {string}
     * @memberof SourceS3
     */
    prefix?: string;
    /**
     * Pattern that selects keys to ingest.
     * @type {string}
     * @memberof SourceS3
     */
    pattern?: string;
    /**
     * address of S3 bucket containing data
     * @type {string}
     * @memberof SourceS3
     */
    bucket: string;
}

/**
 * 
 * @export
 * @interface SqlExpression
 */
export interface SqlExpression {
    /**
     * The name of a sql function
     * @type {string}
     * @memberof SqlExpression
     */
    sql?: string;
}

/**
 * 
 * @export
 * @interface Status
 */
export interface Status {
    /**
     * Status of the Source's ingestion, one of: INITIALIZING, WATCHING, PROCESSING, COMPLETED, ERROR
     * @type {string}
     * @memberof Status
     */
    state?: Status.StateEnum;
    /**
     * ISO-8601 date when state was triggered
     * @type {string}
     * @memberof Status
     */
    since?: string;
    /**
     * state message
     * @type {string}
     * @memberof Status
     */
    message?: string;
    /**
     * ISO-8601 date when source was last processed
     * @type {string}
     * @memberof Status
     */
    last_processed_at?: string;
    /**
     * last source item processed by ingester
     * @type {string}
     * @memberof Status
     */
    last_processed_item?: string;
    /**
     * Total items processed of source
     * @type {number}
     * @memberof Status
     */
    total_processed_items?: number;
    /**
     * ISO-8601 date when last error occurred
     * @type {string}
     * @memberof Status
     */
    last_error_at?: string;
    /**
     * last source item that errored
     * @type {string}
     * @memberof Status
     */
    last_error_item?: string;
    /**
     * reason for the last error
     * @type {string}
     * @memberof Status
     */
    last_error_reason?: string;
    /**
     * Total items that errored
     * @type {number}
     * @memberof Status
     */
    total_error_items?: number;
}

/**
 * @export
 * @namespace Status
 */
export namespace Status {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        INITIALIZING = <any> 'INITIALIZING',
        WATCHING = <any> 'WATCHING',
        PROCESSING = <any> 'PROCESSING',
        COMPLETED = <any> 'COMPLETED',
        ERROR = <any> 'ERROR'
    }
}

/**
 * 
 * @export
 * @interface StatusDynamoDb
 */
export interface StatusDynamoDb {
    /**
     * DynamoDB scan start time
     * @type {string}
     * @memberof StatusDynamoDb
     */
    scan_start_time?: string;
    /**
     * DynamoDb scan end time
     * @type {string}
     * @memberof StatusDynamoDb
     */
    scan_end_time?: string;
    /**
     * Number of records inserted using scan
     * @type {number}
     * @memberof StatusDynamoDb
     */
    scan_records_processed?: number;
    /**
     * Number of records in DynamoDB table at time of scan
     * @type {number}
     * @memberof StatusDynamoDb
     */
    scan_total_records?: number;
    /**
     * state of current ingest for this table
     * @type {string}
     * @memberof StatusDynamoDb
     */
    state?: StatusDynamoDb.StateEnum;
    /**
     * ISO-8601 date when source was last processed
     * @type {string}
     * @memberof StatusDynamoDb
     */
    stream_last_processed_at?: string;
}

/**
 * @export
 * @namespace StatusDynamoDb
 */
export namespace StatusDynamoDb {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        INITIALIZING = <any> 'INITIALIZING',
        SCANNINGTABLE = <any> 'SCANNING_TABLE',
        PROCESSINGSTREAM = <any> 'PROCESSING_STREAM'
    }
}

/**
 * 
 * @export
 * @interface StatusKafka
 */
export interface StatusKafka {
    /**
     * State of the Kafka source
     * @type {string}
     * @memberof StatusKafka
     */
    state?: StatusKafka.StateEnum;
    /**
     * Time at which the last document was consumed from Kafka
     * @type {string}
     * @memberof StatusKafka
     */
    last_consumed_time?: string;
    /**
     * Number of documents consumed by this Kafka topic
     * @type {number}
     * @memberof StatusKafka
     */
    num_documents_processed?: number;
}

/**
 * @export
 * @namespace StatusKafka
 */
export namespace StatusKafka {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        NODOCSYET = <any> 'NO_DOCS_YET',
        ACTIVE = <any> 'ACTIVE',
        DORMANT = <any> 'DORMANT'
    }
}

/**
 * 
 * @export
 * @interface StatusKafkaPartition
 */
export interface StatusKafkaPartition {
    /**
     * The number of this partition
     * @type {number}
     * @memberof StatusKafkaPartition
     */
    partition_number?: number;
    /**
     * Number of documents consumed by this partition
     * @type {number}
     * @memberof StatusKafkaPartition
     */
    num_documents_processed?: number;
}

/**
 * 
 * @export
 * @interface StatusMongoDb
 */
export interface StatusMongoDb {
    /**
     * MongoDB scan start time
     * @type {string}
     * @memberof StatusMongoDb
     */
    scan_start_time?: string;
    /**
     * MongoDB scan end time
     * @type {string}
     * @memberof StatusMongoDb
     */
    scan_end_time?: string;
    /**
     * Number of records inserted using scan
     * @type {number}
     * @memberof StatusMongoDb
     */
    scan_records_processed?: number;
    /**
     * Number of records in MongoDB table at time of scan
     * @type {number}
     * @memberof StatusMongoDb
     */
    scan_total_records?: number;
    /**
     * state of current ingest for this table
     * @type {string}
     * @memberof StatusMongoDb
     */
    state?: StatusMongoDb.StateEnum;
    /**
     * ISO-8601 date when new insert from source was last processed
     * @type {string}
     * @memberof StatusMongoDb
     */
    stream_last_insert_processed_at?: string;
    /**
     * ISO-8601 date when update from source was last processed
     * @type {string}
     * @memberof StatusMongoDb
     */
    stream_last_update_processed_at?: string;
    /**
     * ISO-8601 date when delete from source was last processed
     * @type {string}
     * @memberof StatusMongoDb
     */
    stream_last_delete_processed_at?: string;
    /**
     * Number of new records inserted using stream
     * @type {number}
     * @memberof StatusMongoDb
     */
    stream_records_inserted?: number;
    /**
     * Number of new records updated using stream
     * @type {number}
     * @memberof StatusMongoDb
     */
    stream_records_updated?: number;
    /**
     * Number of new records deleted using stream
     * @type {number}
     * @memberof StatusMongoDb
     */
    stream_records_deleted?: number;
}

/**
 * @export
 * @namespace StatusMongoDb
 */
export namespace StatusMongoDb {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        INITIALIZING = <any> 'INITIALIZING',
        SCANNINGTABLE = <any> 'SCANNING_TABLE',
        PROCESSINGSTREAM = <any> 'PROCESSING_STREAM'
    }
}

/**
 * 
 * @export
 * @interface UpdateQueryLambdaRequest
 */
export interface UpdateQueryLambdaRequest {
    /**
     * optional description
     * @type {string}
     * @memberof UpdateQueryLambdaRequest
     */
    description?: string;
    /**
     * Query Lambda SQL query
     * @type {QueryLambdaSql}
     * @memberof UpdateQueryLambdaRequest
     */
    sql?: QueryLambdaSql;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * ISO-8601 date
     * @type {string}
     * @memberof User
     */
    created_at?: string;
    /**
     * user email
     * @type {string}
     * @memberof User
     */
    email: string;
    /**
     * user first name
     * @type {string}
     * @memberof User
     */
    first_name?: string;
    /**
     * user last name
     * @type {string}
     * @memberof User
     */
    last_name?: string;
    /**
     * List of roles for a given user
     * @type {Array<string>}
     * @memberof User
     */
    roles?: Array<string>;
    /**
     * state of user - NEW / ACTIVE
     * @type {string}
     * @memberof User
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    org?: string;
    /**
     * 
     * @type {Array<Organization>}
     * @memberof User
     */
    orgs?: Array<Organization>;
}

/**
 * Workspaces are organizational containers for collections.
 * @export
 * @interface Workspace
 */
export interface Workspace {
    /**
     * ISO-8601 date of when workspace was created
     * @type {string}
     * @memberof Workspace
     */
    created_at?: string;
    /**
     * email of user who created the workspace
     * @type {string}
     * @memberof Workspace
     */
    created_by?: string;
    /**
     * descriptive label and unique identifier
     * @type {string}
     * @memberof Workspace
     */
    name?: string;
    /**
     * longer explanation for the workspace
     * @type {string}
     * @memberof Workspace
     */
    description?: string;
    /**
     * number of collections that are immediate children of workspace
     * @type {number}
     * @memberof Workspace
     */
    collection_count?: number;
}

/**
 * 
 * @export
 * @interface XmlParams
 */
export interface XmlParams {
    /**
     * tag until which xml is ignored
     * @type {string}
     * @memberof XmlParams
     */
    root_tag?: string;
    /**
     * encoding in which data source is encoded
     * @type {string}
     * @memberof XmlParams
     */
    encoding?: string;
    /**
     * tags with which documents are identified
     * @type {string}
     * @memberof XmlParams
     */
    doc_tag?: string;
    /**
     * tag used for the value when there are attributes in the element having no child
     * @type {string}
     * @memberof XmlParams
     */
    value_tag?: string;
    /**
     * tag to differentiate between attributes and elements
     * @type {string}
     * @memberof XmlParams
     */
    attribute_prefix?: string;
}


/**
 * ApiKeysApi - fetch parameter creator
 * @export
 */
export const ApiKeysApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new API key for the authenticated user.
         * @summary Create API Key
         * @param {CreateApiKeyRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey(body: CreateApiKeyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createApiKey.');
            }
            const localVarPath = `/v1/orgs/self/users/self/apikeys`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateApiKeyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new API key for any user (admin only).
         * @summary Create API Key for any user (admin only)
         * @param {CreateApiKeyRequest} body JSON object
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyAdmin(body: CreateApiKeyRequest, user: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createApiKeyAdmin.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling createApiKeyAdmin.');
            }
            const localVarPath = `/v1/orgs/self/users/{user}/apikeys`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateApiKeyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an API key for the authenticated user.
         * @summary Delete API Key
         * @param {string} name name of the API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteApiKey.');
            }
            const localVarPath = `/v1/orgs/self/users/self/apikeys/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an API key for any user (admin only).
         * @summary Delete API Key for any user (admin only)
         * @param {string} name name of the API key
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyAdmin(name: string, user: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteApiKeyAdmin.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling deleteApiKeyAdmin.');
            }
            const localVarPath = `/v1/orgs/self/users/{user}/apikeys/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all API keys for the authenticated user.
         * @summary List API Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeys(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/users/self/apikeys`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all API keys for any user (admin only).
         * @summary List API Keys for any user (admin only)
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysAdmin(user: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling listApiKeysAdmin.');
            }
            const localVarPath = `/v1/orgs/self/users/{user}/apikeys`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiKeysApi - functional programming interface
 * @export
 */
export const ApiKeysApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new API key for the authenticated user.
         * @summary Create API Key
         * @param {CreateApiKeyRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey(body: CreateApiKeyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateApiKeyResponse> {
            const localVarFetchArgs = ApiKeysApiFetchParamCreator(configuration).createApiKey(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new API key for any user (admin only).
         * @summary Create API Key for any user (admin only)
         * @param {CreateApiKeyRequest} body JSON object
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyAdmin(body: CreateApiKeyRequest, user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateApiKeyResponse> {
            const localVarFetchArgs = ApiKeysApiFetchParamCreator(configuration).createApiKeyAdmin(body, user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an API key for the authenticated user.
         * @summary Delete API Key
         * @param {string} name name of the API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteApiKeyResponse> {
            const localVarFetchArgs = ApiKeysApiFetchParamCreator(configuration).deleteApiKey(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an API key for any user (admin only).
         * @summary Delete API Key for any user (admin only)
         * @param {string} name name of the API key
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyAdmin(name: string, user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteApiKeyResponse> {
            const localVarFetchArgs = ApiKeysApiFetchParamCreator(configuration).deleteApiKeyAdmin(name, user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all API keys for the authenticated user.
         * @summary List API Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeys(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListApiKeysResponse> {
            const localVarFetchArgs = ApiKeysApiFetchParamCreator(configuration).listApiKeys(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all API keys for any user (admin only).
         * @summary List API Keys for any user (admin only)
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysAdmin(user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListApiKeysResponse> {
            const localVarFetchArgs = ApiKeysApiFetchParamCreator(configuration).listApiKeysAdmin(user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ApiKeysApi - factory interface
 * @export
 */
export const ApiKeysApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new API key for the authenticated user.
         * @summary Create API Key
         * @param {CreateApiKeyRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey(body: CreateApiKeyRequest, options?: any) {
            return ApiKeysApiFp(configuration).createApiKey(body, options)(fetch, basePath);
        },
        /**
         * Create a new API key for any user (admin only).
         * @summary Create API Key for any user (admin only)
         * @param {CreateApiKeyRequest} body JSON object
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyAdmin(body: CreateApiKeyRequest, user: string, options?: any) {
            return ApiKeysApiFp(configuration).createApiKeyAdmin(body, user, options)(fetch, basePath);
        },
        /**
         * Delete an API key for the authenticated user.
         * @summary Delete API Key
         * @param {string} name name of the API key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey(name: string, options?: any) {
            return ApiKeysApiFp(configuration).deleteApiKey(name, options)(fetch, basePath);
        },
        /**
         * Delete an API key for any user (admin only).
         * @summary Delete API Key for any user (admin only)
         * @param {string} name name of the API key
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyAdmin(name: string, user: string, options?: any) {
            return ApiKeysApiFp(configuration).deleteApiKeyAdmin(name, user, options)(fetch, basePath);
        },
        /**
         * List all API keys for the authenticated user.
         * @summary List API Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeys(options?: any) {
            return ApiKeysApiFp(configuration).listApiKeys(options)(fetch, basePath);
        },
        /**
         * List all API keys for any user (admin only).
         * @summary List API Keys for any user (admin only)
         * @param {string} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysAdmin(user: string, options?: any) {
            return ApiKeysApiFp(configuration).listApiKeysAdmin(user, options)(fetch, basePath);
        },
    };
};

/**
 * ApiKeysApi - object-oriented interface
 * @export
 * @class ApiKeysApi
 * @extends {BaseAPI}
 */
export class ApiKeysApi extends BaseAPI {
    /**
     * Create a new API key for the authenticated user.
     * @summary Create API Key
     * @param {CreateApiKeyRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public createApiKey(body: CreateApiKeyRequest, options?: any) {
        return ApiKeysApiFp(this.configuration).createApiKey(body, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new API key for any user (admin only).
     * @summary Create API Key for any user (admin only)
     * @param {CreateApiKeyRequest} body JSON object
     * @param {string} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public createApiKeyAdmin(body: CreateApiKeyRequest, user: string, options?: any) {
        return ApiKeysApiFp(this.configuration).createApiKeyAdmin(body, user, options)(this.fetch, this.basePath);
    }

    /**
     * Delete an API key for the authenticated user.
     * @summary Delete API Key
     * @param {string} name name of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public deleteApiKey(name: string, options?: any) {
        return ApiKeysApiFp(this.configuration).deleteApiKey(name, options)(this.fetch, this.basePath);
    }

    /**
     * Delete an API key for any user (admin only).
     * @summary Delete API Key for any user (admin only)
     * @param {string} name name of the API key
     * @param {string} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public deleteApiKeyAdmin(name: string, user: string, options?: any) {
        return ApiKeysApiFp(this.configuration).deleteApiKeyAdmin(name, user, options)(this.fetch, this.basePath);
    }

    /**
     * List all API keys for the authenticated user.
     * @summary List API Keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public listApiKeys(options?: any) {
        return ApiKeysApiFp(this.configuration).listApiKeys(options)(this.fetch, this.basePath);
    }

    /**
     * List all API keys for any user (admin only).
     * @summary List API Keys for any user (admin only)
     * @param {string} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public listApiKeysAdmin(user: string, options?: any) {
        return ApiKeysApiFp(this.configuration).listApiKeysAdmin(user, options)(this.fetch, this.basePath);
    }

}

/**
 * CollectionsApi - fetch parameter creator
 * @export
 */
export const CollectionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new collection in a workspace.
         * @summary Create Collection
         * @param {string} workspace name of the workspace
         * @param {CreateCollectionRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection(workspace: string, body: CreateCollectionRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling createCollection.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createCollection.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateCollectionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a collection and all its documents from Rockset.
         * @summary Delete Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollection(workspace: string, collection: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling deleteCollection.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling deleteCollection.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details about a collection.
         * @summary Get Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection(workspace: string, collection: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling getCollection.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling getCollection.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all collections in an organization.
         * @summary List Collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/collections`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all Query Lambdas that hit a specific Rockset Collection.
         * @summary Get Query Lambdas
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdasInCollection(workspace: string, collection: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling listQueryLambdasInCollection.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling listQueryLambdasInCollection.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/lambdas`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all collections in a workspace.
         * @summary List Collections for Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceCollections(workspace: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling workspaceCollections.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionsApi - functional programming interface
 * @export
 */
export const CollectionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create new collection in a workspace.
         * @summary Create Collection
         * @param {string} workspace name of the workspace
         * @param {CreateCollectionRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection(workspace: string, body: CreateCollectionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateCollectionResponse> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).createCollection(workspace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a collection and all its documents from Rockset.
         * @summary Delete Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollection(workspace: string, collection: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteCollectionResponse> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).deleteCollection(workspace, collection, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get details about a collection.
         * @summary Get Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection(workspace: string, collection: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCollectionResponse> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).getCollection(workspace, collection, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all collections in an organization.
         * @summary List Collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListCollectionsResponse> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).listCollections(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all Query Lambdas that hit a specific Rockset Collection.
         * @summary Get Query Lambdas
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdasInCollection(workspace: string, collection: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueryLambdaVersionsResponse> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).listQueryLambdasInCollection(workspace, collection, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all collections in a workspace.
         * @summary List Collections for Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceCollections(workspace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListCollectionsResponse> {
            const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).workspaceCollections(workspace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CollectionsApi - factory interface
 * @export
 */
export const CollectionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create new collection in a workspace.
         * @summary Create Collection
         * @param {string} workspace name of the workspace
         * @param {CreateCollectionRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection(workspace: string, body: CreateCollectionRequest, options?: any) {
            return CollectionsApiFp(configuration).createCollection(workspace, body, options)(fetch, basePath);
        },
        /**
         * Delete a collection and all its documents from Rockset.
         * @summary Delete Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollection(workspace: string, collection: string, options?: any) {
            return CollectionsApiFp(configuration).deleteCollection(workspace, collection, options)(fetch, basePath);
        },
        /**
         * Get details about a collection.
         * @summary Get Collection
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection(workspace: string, collection: string, options?: any) {
            return CollectionsApiFp(configuration).getCollection(workspace, collection, options)(fetch, basePath);
        },
        /**
         * Retrieve all collections in an organization.
         * @summary List Collections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections(options?: any) {
            return CollectionsApiFp(configuration).listCollections(options)(fetch, basePath);
        },
        /**
         * Get all Query Lambdas that hit a specific Rockset Collection.
         * @summary Get Query Lambdas
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdasInCollection(workspace: string, collection: string, options?: any) {
            return CollectionsApiFp(configuration).listQueryLambdasInCollection(workspace, collection, options)(fetch, basePath);
        },
        /**
         * Retrieve all collections in a workspace.
         * @summary List Collections for Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceCollections(workspace: string, options?: any) {
            return CollectionsApiFp(configuration).workspaceCollections(workspace, options)(fetch, basePath);
        },
    };
};

/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
export class CollectionsApi extends BaseAPI {
    /**
     * Create new collection in a workspace.
     * @summary Create Collection
     * @param {string} workspace name of the workspace
     * @param {CreateCollectionRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public createCollection(workspace: string, body: CreateCollectionRequest, options?: any) {
        return CollectionsApiFp(this.configuration).createCollection(workspace, body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a collection and all its documents from Rockset.
     * @summary Delete Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public deleteCollection(workspace: string, collection: string, options?: any) {
        return CollectionsApiFp(this.configuration).deleteCollection(workspace, collection, options)(this.fetch, this.basePath);
    }

    /**
     * Get details about a collection.
     * @summary Get Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getCollection(workspace: string, collection: string, options?: any) {
        return CollectionsApiFp(this.configuration).getCollection(workspace, collection, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all collections in an organization.
     * @summary List Collections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public listCollections(options?: any) {
        return CollectionsApiFp(this.configuration).listCollections(options)(this.fetch, this.basePath);
    }

    /**
     * Get all Query Lambdas that hit a specific Rockset Collection.
     * @summary Get Query Lambdas
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public listQueryLambdasInCollection(workspace: string, collection: string, options?: any) {
        return CollectionsApiFp(this.configuration).listQueryLambdasInCollection(workspace, collection, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all collections in a workspace.
     * @summary List Collections for Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public workspaceCollections(workspace: string, options?: any) {
        return CollectionsApiFp(this.configuration).workspaceCollections(workspace, options)(this.fetch, this.basePath);
    }

}

/**
 * DocumentsApi - fetch parameter creator
 * @export
 */
export const DocumentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add documents to a collection in Rockset.
         * @summary Add Documents
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {AddDocumentsRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocuments(workspace: string, collection: string, body: AddDocumentsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling addDocuments.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling addDocuments.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addDocuments.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/docs`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddDocumentsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete documents from a collection in Rockset.
         * @summary Delete Documents
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {DeleteDocumentsRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocuments(workspace: string, collection: string, body: DeleteDocumentsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling deleteDocuments.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling deleteDocuments.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deleteDocuments.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/docs`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeleteDocumentsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Patch documents in a collection
         * @summary Patch Documents
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {PatchDocumentsRequest} body JSON Patch objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDocuments(workspace: string, collection: string, body: PatchDocumentsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling patchDocuments.');
            }
            // verify required parameter 'collection' is not null or undefined
            if (collection === null || collection === undefined) {
                throw new RequiredError('collection','Required parameter collection was null or undefined when calling patchDocuments.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchDocuments.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/docs`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PatchDocumentsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsApi - functional programming interface
 * @export
 */
export const DocumentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add documents to a collection in Rockset.
         * @summary Add Documents
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {AddDocumentsRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocuments(workspace: string, collection: string, body: AddDocumentsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddDocumentsResponse> {
            const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).addDocuments(workspace, collection, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete documents from a collection in Rockset.
         * @summary Delete Documents
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {DeleteDocumentsRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocuments(workspace: string, collection: string, body: DeleteDocumentsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteDocumentsResponse> {
            const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).deleteDocuments(workspace, collection, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Patch documents in a collection
         * @summary Patch Documents
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {PatchDocumentsRequest} body JSON Patch objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDocuments(workspace: string, collection: string, body: PatchDocumentsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PatchDocumentsResponse> {
            const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).patchDocuments(workspace, collection, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DocumentsApi - factory interface
 * @export
 */
export const DocumentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Add documents to a collection in Rockset.
         * @summary Add Documents
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {AddDocumentsRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocuments(workspace: string, collection: string, body: AddDocumentsRequest, options?: any) {
            return DocumentsApiFp(configuration).addDocuments(workspace, collection, body, options)(fetch, basePath);
        },
        /**
         * Delete documents from a collection in Rockset.
         * @summary Delete Documents
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {DeleteDocumentsRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocuments(workspace: string, collection: string, body: DeleteDocumentsRequest, options?: any) {
            return DocumentsApiFp(configuration).deleteDocuments(workspace, collection, body, options)(fetch, basePath);
        },
        /**
         * Patch documents in a collection
         * @summary Patch Documents
         * @param {string} workspace name of the workspace
         * @param {string} collection name of the collection
         * @param {PatchDocumentsRequest} body JSON Patch objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDocuments(workspace: string, collection: string, body: PatchDocumentsRequest, options?: any) {
            return DocumentsApiFp(configuration).patchDocuments(workspace, collection, body, options)(fetch, basePath);
        },
    };
};

/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export class DocumentsApi extends BaseAPI {
    /**
     * Add documents to a collection in Rockset.
     * @summary Add Documents
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {AddDocumentsRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public addDocuments(workspace: string, collection: string, body: AddDocumentsRequest, options?: any) {
        return DocumentsApiFp(this.configuration).addDocuments(workspace, collection, body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete documents from a collection in Rockset.
     * @summary Delete Documents
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {DeleteDocumentsRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public deleteDocuments(workspace: string, collection: string, body: DeleteDocumentsRequest, options?: any) {
        return DocumentsApiFp(this.configuration).deleteDocuments(workspace, collection, body, options)(this.fetch, this.basePath);
    }

    /**
     * Patch documents in a collection
     * @summary Patch Documents
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {PatchDocumentsRequest} body JSON Patch objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public patchDocuments(workspace: string, collection: string, body: PatchDocumentsRequest, options?: any) {
        return DocumentsApiFp(this.configuration).patchDocuments(workspace, collection, body, options)(this.fetch, this.basePath);
    }

}

/**
 * IntegrationsApi - fetch parameter creator
 * @export
 */
export const IntegrationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new integration with Rockset.
         * @summary Create Integration
         * @param {CreateIntegrationRequest} body integration credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIntegration(body: CreateIntegrationRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createIntegration.');
            }
            const localVarPath = `/v1/orgs/self/integrations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateIntegrationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an integration.
         * @summary Delete Integration
         * @param {string} integration name of the integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIntegration(integration: string, options: any = {}): FetchArgs {
            // verify required parameter 'integration' is not null or undefined
            if (integration === null || integration === undefined) {
                throw new RequiredError('integration','Required parameter integration was null or undefined when calling deleteIntegration.');
            }
            const localVarPath = `/v1/orgs/self/integrations/{integration}`
                .replace(`{${"integration"}}`, encodeURIComponent(String(integration)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a single integration.
         * @summary Get Integration
         * @param {string} integration name of the integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegration(integration: string, options: any = {}): FetchArgs {
            // verify required parameter 'integration' is not null or undefined
            if (integration === null || integration === undefined) {
                throw new RequiredError('integration','Required parameter integration was null or undefined when calling getIntegration.');
            }
            const localVarPath = `/v1/orgs/self/integrations/{integration}`
                .replace(`{${"integration"}}`, encodeURIComponent(String(integration)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all integrations for organization.
         * @summary List Integrations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIntegrations(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/integrations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationsApi - functional programming interface
 * @export
 */
export const IntegrationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new integration with Rockset.
         * @summary Create Integration
         * @param {CreateIntegrationRequest} body integration credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIntegration(body: CreateIntegrationRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateIntegrationResponse> {
            const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).createIntegration(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove an integration.
         * @summary Delete Integration
         * @param {string} integration name of the integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIntegration(integration: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteIntegrationResponse> {
            const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).deleteIntegration(integration, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information about a single integration.
         * @summary Get Integration
         * @param {string} integration name of the integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegration(integration: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetIntegrationResponse> {
            const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).getIntegration(integration, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all integrations for organization.
         * @summary List Integrations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIntegrations(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListIntegrationsResponse> {
            const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).listIntegrations(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * IntegrationsApi - factory interface
 * @export
 */
export const IntegrationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new integration with Rockset.
         * @summary Create Integration
         * @param {CreateIntegrationRequest} body integration credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIntegration(body: CreateIntegrationRequest, options?: any) {
            return IntegrationsApiFp(configuration).createIntegration(body, options)(fetch, basePath);
        },
        /**
         * Remove an integration.
         * @summary Delete Integration
         * @param {string} integration name of the integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIntegration(integration: string, options?: any) {
            return IntegrationsApiFp(configuration).deleteIntegration(integration, options)(fetch, basePath);
        },
        /**
         * Get information about a single integration.
         * @summary Get Integration
         * @param {string} integration name of the integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegration(integration: string, options?: any) {
            return IntegrationsApiFp(configuration).getIntegration(integration, options)(fetch, basePath);
        },
        /**
         * List all integrations for organization.
         * @summary List Integrations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIntegrations(options?: any) {
            return IntegrationsApiFp(configuration).listIntegrations(options)(fetch, basePath);
        },
    };
};

/**
 * IntegrationsApi - object-oriented interface
 * @export
 * @class IntegrationsApi
 * @extends {BaseAPI}
 */
export class IntegrationsApi extends BaseAPI {
    /**
     * Create a new integration with Rockset.
     * @summary Create Integration
     * @param {CreateIntegrationRequest} body integration credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public createIntegration(body: CreateIntegrationRequest, options?: any) {
        return IntegrationsApiFp(this.configuration).createIntegration(body, options)(this.fetch, this.basePath);
    }

    /**
     * Remove an integration.
     * @summary Delete Integration
     * @param {string} integration name of the integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public deleteIntegration(integration: string, options?: any) {
        return IntegrationsApiFp(this.configuration).deleteIntegration(integration, options)(this.fetch, this.basePath);
    }

    /**
     * Get information about a single integration.
     * @summary Get Integration
     * @param {string} integration name of the integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getIntegration(integration: string, options?: any) {
        return IntegrationsApiFp(this.configuration).getIntegration(integration, options)(this.fetch, this.basePath);
    }

    /**
     * List all integrations for organization.
     * @summary List Integrations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public listIntegrations(options?: any) {
        return IntegrationsApiFp(this.configuration).listIntegrations(options)(this.fetch, this.basePath);
    }

}

/**
 * OrganizationsApi - fetch parameter creator
 * @export
 */
export const OrganizationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve information about current organization.
         * @summary Get Organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve information about current organization.
         * @summary Get Organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrganizationResponse> {
            const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getOrganization(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve information about current organization.
         * @summary Get Organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(options?: any) {
            return OrganizationsApiFp(configuration).getOrganization(options)(fetch, basePath);
        },
    };
};

/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI {
    /**
     * Retrieve information about current organization.
     * @summary Get Organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganization(options?: any) {
        return OrganizationsApiFp(this.configuration).getOrganization(options)(this.fetch, this.basePath);
    }

}

/**
 * QueriesApi - fetch parameter creator
 * @export
 */
export const QueriesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Make a SQL query to Rockset.
         * @summary Query
         * @param {QueryRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        query(body: QueryRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling query.');
            }
            const localVarPath = `/v1/orgs/self/queries`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QueryRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueriesApi - functional programming interface
 * @export
 */
export const QueriesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Make a SQL query to Rockset.
         * @summary Query
         * @param {QueryRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        query(body: QueryRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryResponse> {
            const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).query(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QueriesApi - factory interface
 * @export
 */
export const QueriesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Make a SQL query to Rockset.
         * @summary Query
         * @param {QueryRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        query(body: QueryRequest, options?: any) {
            return QueriesApiFp(configuration).query(body, options)(fetch, basePath);
        },
    };
};

/**
 * QueriesApi - object-oriented interface
 * @export
 * @class QueriesApi
 * @extends {BaseAPI}
 */
export class QueriesApi extends BaseAPI {
    /**
     * Make a SQL query to Rockset.
     * @summary Query
     * @param {QueryRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueriesApi
     */
    public query(body: QueryRequest, options?: any) {
        return QueriesApiFp(this.configuration).query(body, options)(this.fetch, this.basePath);
    }

}

/**
 * QueryLambdasApi - fetch parameter creator
 * @export
 */
export const QueryLambdasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a Query Lambda in given workspace.
         * @summary Create Query Lambda
         * @param {string} workspace name of the workspace
         * @param {CreateQueryLambdaRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueryLambda(workspace: string, body: CreateQueryLambdaRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling createQueryLambda.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createQueryLambda.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateQueryLambdaRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a tag for a specific Query Lambda version, or update if it exists
         * @summary Create Query Lambda Tag
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {CreateQueryLambdaTagRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueryLambdaTag(workspace: string, queryLambda: string, body: CreateQueryLambdaTagRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling createQueryLambdaTag.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling createQueryLambdaTag.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createQueryLambdaTag.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/tags`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateQueryLambdaTagRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Query Lambda.
         * @summary Delete Query Lambda
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueryLambda(workspace: string, queryLambda: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling deleteQueryLambda.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling deleteQueryLambda.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a tag for a specific Query Lambda
         * @summary Delete Query Lambda Tag Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} tag name of the tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueryLambdaTag(workspace: string, queryLambda: string, tag: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling deleteQueryLambdaTag.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling deleteQueryLambdaTag.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling deleteQueryLambdaTag.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/tags/{tag}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Query Lambda version.
         * @summary Delete Query Lambda Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} version version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling deleteQueryLambdaVersion.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling deleteQueryLambdaVersion.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling deleteQueryLambdaVersion.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/version/{version}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Run a particular version of a Query Lambda.
         * @summary Run Query Lambda
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} version version
         * @param {ExecuteQueryLambdaRequest} [body] JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeQueryLambda(workspace: string, queryLambda: string, version: string, body?: ExecuteQueryLambdaRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling executeQueryLambda.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling executeQueryLambda.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling executeQueryLambda.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/versions/{version}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ExecuteQueryLambdaRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Run the Query Lambda version associated with a given tag.
         * @summary Run Query Lambda By Tag
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} tag tag
         * @param {ExecuteQueryLambdaRequest} [body] JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeQueryLambdaByTag(workspace: string, queryLambda: string, tag: string, body?: ExecuteQueryLambdaRequest, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling executeQueryLambdaByTag.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling executeQueryLambdaByTag.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling executeQueryLambdaByTag.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/tags/{tag}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ExecuteQueryLambdaRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the specific Query Lambda version associated with a given tag
         * @summary Get Query Lambda Tag
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} tag name of the tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryLambdaTagVersion(workspace: string, queryLambda: string, tag: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling getQueryLambdaTagVersion.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling getQueryLambdaTagVersion.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling getQueryLambdaTagVersion.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/tags/{tag}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific version of a Query Lambda
         * @summary Get Query Lambda Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} version version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling getQueryLambdaVersion.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling getQueryLambdaVersion.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling getQueryLambdaVersion.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/versions/{version}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all Query Lambdas.
         * @summary List Query Lambdas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllQueryLambdas(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/lambdas`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all tags in an organization
         * @summary List Query Lambda Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationTags(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/lambdas/tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all Query Lambda versions associated with a tag
         * @summary List Query Lambda Tag Versions
         * @param {string} tag name of the tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdaTagVersions(tag: string, options: any = {}): FetchArgs {
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling listQueryLambdaTagVersions.');
            }
            const localVarPath = `/v1/orgs/self/lambdas/tags/{tag}`
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all tags associated with a Query Lambda
         * @summary List Query Lambda Tags
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdaTags(workspace: string, queryLambda: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling listQueryLambdaTags.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling listQueryLambdaTags.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/tags`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all versions of a Query Lambda.
         * @summary List Query Lambda Versions
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdaVersions(workspace: string, queryLambda: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling listQueryLambdaVersions.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling listQueryLambdaVersions.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/versions`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all Query Lambdas under given workspace.
         * @summary List Query Lambdas
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdasInWorkspace(workspace: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling listQueryLambdasInWorkspace.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new version of a Query Lambda in given workspace.
         * @summary Update Query Lambda
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {UpdateQueryLambdaRequest} body JSON object
         * @param {boolean} [create] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQueryLambda(workspace: string, queryLambda: string, body: UpdateQueryLambdaRequest, create?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling updateQueryLambda.');
            }
            // verify required parameter 'queryLambda' is not null or undefined
            if (queryLambda === null || queryLambda === undefined) {
                throw new RequiredError('queryLambda','Required parameter queryLambda was null or undefined when calling updateQueryLambda.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateQueryLambda.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/versions`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)))
                .replace(`{${"queryLambda"}}`, encodeURIComponent(String(queryLambda)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (create !== undefined) {
                localVarQueryParameter['create'] = create;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateQueryLambdaRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryLambdasApi - functional programming interface
 * @export
 */
export const QueryLambdasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a Query Lambda in given workspace.
         * @summary Create Query Lambda
         * @param {string} workspace name of the workspace
         * @param {CreateQueryLambdaRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueryLambda(workspace: string, body: CreateQueryLambdaRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryLambdaVersionResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).createQueryLambda(workspace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a tag for a specific Query Lambda version, or update if it exists
         * @summary Create Query Lambda Tag
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {CreateQueryLambdaTagRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueryLambdaTag(workspace: string, queryLambda: string, body: CreateQueryLambdaTagRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryLambdaTagResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).createQueryLambdaTag(workspace, queryLambda, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a Query Lambda.
         * @summary Delete Query Lambda
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueryLambda(workspace: string, queryLambda: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteQueryLambdaResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).deleteQueryLambda(workspace, queryLambda, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a tag for a specific Query Lambda
         * @summary Delete Query Lambda Tag Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} tag name of the tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueryLambdaTag(workspace: string, queryLambda: string, tag: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryLambdaTagResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).deleteQueryLambdaTag(workspace, queryLambda, tag, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a Query Lambda version.
         * @summary Delete Query Lambda Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} version version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryLambdaVersionResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).deleteQueryLambdaVersion(workspace, queryLambda, version, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Run a particular version of a Query Lambda.
         * @summary Run Query Lambda
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} version version
         * @param {ExecuteQueryLambdaRequest} [body] JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeQueryLambda(workspace: string, queryLambda: string, version: string, body?: ExecuteQueryLambdaRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).executeQueryLambda(workspace, queryLambda, version, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Run the Query Lambda version associated with a given tag.
         * @summary Run Query Lambda By Tag
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} tag tag
         * @param {ExecuteQueryLambdaRequest} [body] JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeQueryLambdaByTag(workspace: string, queryLambda: string, tag: string, body?: ExecuteQueryLambdaRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).executeQueryLambdaByTag(workspace, queryLambda, tag, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the specific Query Lambda version associated with a given tag
         * @summary Get Query Lambda Tag
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} tag name of the tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryLambdaTagVersion(workspace: string, queryLambda: string, tag: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryLambdaTagResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).getQueryLambdaTagVersion(workspace, queryLambda, tag, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a specific version of a Query Lambda
         * @summary Get Query Lambda Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} version version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryLambdaVersionResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).getQueryLambdaVersion(workspace, queryLambda, version, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all Query Lambdas.
         * @summary List Query Lambdas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllQueryLambdas(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueryLambdasResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).listAllQueryLambdas(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all tags in an organization
         * @summary List Query Lambda Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationTags(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueryLambdaTagsResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).listOrganizationTags(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all Query Lambda versions associated with a tag
         * @summary List Query Lambda Tag Versions
         * @param {string} tag name of the tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdaTagVersions(tag: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueryLambdaVersionsResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).listQueryLambdaTagVersions(tag, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all tags associated with a Query Lambda
         * @summary List Query Lambda Tags
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdaTags(workspace: string, queryLambda: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueryLambdaTagsResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).listQueryLambdaTags(workspace, queryLambda, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all versions of a Query Lambda.
         * @summary List Query Lambda Versions
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdaVersions(workspace: string, queryLambda: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueryLambdaVersionsResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).listQueryLambdaVersions(workspace, queryLambda, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all Query Lambdas under given workspace.
         * @summary List Query Lambdas
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdasInWorkspace(workspace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueryLambdasResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).listQueryLambdasInWorkspace(workspace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new version of a Query Lambda in given workspace.
         * @summary Update Query Lambda
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {UpdateQueryLambdaRequest} body JSON object
         * @param {boolean} [create] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQueryLambda(workspace: string, queryLambda: string, body: UpdateQueryLambdaRequest, create?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryLambdaVersionResponse> {
            const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).updateQueryLambda(workspace, queryLambda, body, create, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QueryLambdasApi - factory interface
 * @export
 */
export const QueryLambdasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a Query Lambda in given workspace.
         * @summary Create Query Lambda
         * @param {string} workspace name of the workspace
         * @param {CreateQueryLambdaRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueryLambda(workspace: string, body: CreateQueryLambdaRequest, options?: any) {
            return QueryLambdasApiFp(configuration).createQueryLambda(workspace, body, options)(fetch, basePath);
        },
        /**
         * Create a tag for a specific Query Lambda version, or update if it exists
         * @summary Create Query Lambda Tag
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {CreateQueryLambdaTagRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueryLambdaTag(workspace: string, queryLambda: string, body: CreateQueryLambdaTagRequest, options?: any) {
            return QueryLambdasApiFp(configuration).createQueryLambdaTag(workspace, queryLambda, body, options)(fetch, basePath);
        },
        /**
         * Delete a Query Lambda.
         * @summary Delete Query Lambda
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueryLambda(workspace: string, queryLambda: string, options?: any) {
            return QueryLambdasApiFp(configuration).deleteQueryLambda(workspace, queryLambda, options)(fetch, basePath);
        },
        /**
         * Delete a tag for a specific Query Lambda
         * @summary Delete Query Lambda Tag Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} tag name of the tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueryLambdaTag(workspace: string, queryLambda: string, tag: string, options?: any) {
            return QueryLambdasApiFp(configuration).deleteQueryLambdaTag(workspace, queryLambda, tag, options)(fetch, basePath);
        },
        /**
         * Delete a Query Lambda version.
         * @summary Delete Query Lambda Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} version version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options?: any) {
            return QueryLambdasApiFp(configuration).deleteQueryLambdaVersion(workspace, queryLambda, version, options)(fetch, basePath);
        },
        /**
         * Run a particular version of a Query Lambda.
         * @summary Run Query Lambda
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} version version
         * @param {ExecuteQueryLambdaRequest} [body] JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeQueryLambda(workspace: string, queryLambda: string, version: string, body?: ExecuteQueryLambdaRequest, options?: any) {
            return QueryLambdasApiFp(configuration).executeQueryLambda(workspace, queryLambda, version, body, options)(fetch, basePath);
        },
        /**
         * Run the Query Lambda version associated with a given tag.
         * @summary Run Query Lambda By Tag
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} tag tag
         * @param {ExecuteQueryLambdaRequest} [body] JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeQueryLambdaByTag(workspace: string, queryLambda: string, tag: string, body?: ExecuteQueryLambdaRequest, options?: any) {
            return QueryLambdasApiFp(configuration).executeQueryLambdaByTag(workspace, queryLambda, tag, body, options)(fetch, basePath);
        },
        /**
         * Get the specific Query Lambda version associated with a given tag
         * @summary Get Query Lambda Tag
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} tag name of the tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryLambdaTagVersion(workspace: string, queryLambda: string, tag: string, options?: any) {
            return QueryLambdasApiFp(configuration).getQueryLambdaTagVersion(workspace, queryLambda, tag, options)(fetch, basePath);
        },
        /**
         * Get a specific version of a Query Lambda
         * @summary Get Query Lambda Version
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {string} version version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options?: any) {
            return QueryLambdasApiFp(configuration).getQueryLambdaVersion(workspace, queryLambda, version, options)(fetch, basePath);
        },
        /**
         * List all Query Lambdas.
         * @summary List Query Lambdas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllQueryLambdas(options?: any) {
            return QueryLambdasApiFp(configuration).listAllQueryLambdas(options)(fetch, basePath);
        },
        /**
         * List all tags in an organization
         * @summary List Query Lambda Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationTags(options?: any) {
            return QueryLambdasApiFp(configuration).listOrganizationTags(options)(fetch, basePath);
        },
        /**
         * List all Query Lambda versions associated with a tag
         * @summary List Query Lambda Tag Versions
         * @param {string} tag name of the tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdaTagVersions(tag: string, options?: any) {
            return QueryLambdasApiFp(configuration).listQueryLambdaTagVersions(tag, options)(fetch, basePath);
        },
        /**
         * List all tags associated with a Query Lambda
         * @summary List Query Lambda Tags
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdaTags(workspace: string, queryLambda: string, options?: any) {
            return QueryLambdasApiFp(configuration).listQueryLambdaTags(workspace, queryLambda, options)(fetch, basePath);
        },
        /**
         * List all versions of a Query Lambda.
         * @summary List Query Lambda Versions
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdaVersions(workspace: string, queryLambda: string, options?: any) {
            return QueryLambdasApiFp(configuration).listQueryLambdaVersions(workspace, queryLambda, options)(fetch, basePath);
        },
        /**
         * List all Query Lambdas under given workspace.
         * @summary List Query Lambdas
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueryLambdasInWorkspace(workspace: string, options?: any) {
            return QueryLambdasApiFp(configuration).listQueryLambdasInWorkspace(workspace, options)(fetch, basePath);
        },
        /**
         * Create a new version of a Query Lambda in given workspace.
         * @summary Update Query Lambda
         * @param {string} workspace name of the workspace
         * @param {string} queryLambda name of the Query Lambda
         * @param {UpdateQueryLambdaRequest} body JSON object
         * @param {boolean} [create] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQueryLambda(workspace: string, queryLambda: string, body: UpdateQueryLambdaRequest, create?: boolean, options?: any) {
            return QueryLambdasApiFp(configuration).updateQueryLambda(workspace, queryLambda, body, create, options)(fetch, basePath);
        },
    };
};

/**
 * QueryLambdasApi - object-oriented interface
 * @export
 * @class QueryLambdasApi
 * @extends {BaseAPI}
 */
export class QueryLambdasApi extends BaseAPI {
    /**
     * Create a Query Lambda in given workspace.
     * @summary Create Query Lambda
     * @param {string} workspace name of the workspace
     * @param {CreateQueryLambdaRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public createQueryLambda(workspace: string, body: CreateQueryLambdaRequest, options?: any) {
        return QueryLambdasApiFp(this.configuration).createQueryLambda(workspace, body, options)(this.fetch, this.basePath);
    }

    /**
     * Create a tag for a specific Query Lambda version, or update if it exists
     * @summary Create Query Lambda Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {CreateQueryLambdaTagRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public createQueryLambdaTag(workspace: string, queryLambda: string, body: CreateQueryLambdaTagRequest, options?: any) {
        return QueryLambdasApiFp(this.configuration).createQueryLambdaTag(workspace, queryLambda, body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a Query Lambda.
     * @summary Delete Query Lambda
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public deleteQueryLambda(workspace: string, queryLambda: string, options?: any) {
        return QueryLambdasApiFp(this.configuration).deleteQueryLambda(workspace, queryLambda, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a tag for a specific Query Lambda
     * @summary Delete Query Lambda Tag Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag name of the tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public deleteQueryLambdaTag(workspace: string, queryLambda: string, tag: string, options?: any) {
        return QueryLambdasApiFp(this.configuration).deleteQueryLambdaTag(workspace, queryLambda, tag, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a Query Lambda version.
     * @summary Delete Query Lambda Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public deleteQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options?: any) {
        return QueryLambdasApiFp(this.configuration).deleteQueryLambdaVersion(workspace, queryLambda, version, options)(this.fetch, this.basePath);
    }

    /**
     * Run a particular version of a Query Lambda.
     * @summary Run Query Lambda
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {ExecuteQueryLambdaRequest} [body] JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public executeQueryLambda(workspace: string, queryLambda: string, version: string, body?: ExecuteQueryLambdaRequest, options?: any) {
        return QueryLambdasApiFp(this.configuration).executeQueryLambda(workspace, queryLambda, version, body, options)(this.fetch, this.basePath);
    }

    /**
     * Run the Query Lambda version associated with a given tag.
     * @summary Run Query Lambda By Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag tag
     * @param {ExecuteQueryLambdaRequest} [body] JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public executeQueryLambdaByTag(workspace: string, queryLambda: string, tag: string, body?: ExecuteQueryLambdaRequest, options?: any) {
        return QueryLambdasApiFp(this.configuration).executeQueryLambdaByTag(workspace, queryLambda, tag, body, options)(this.fetch, this.basePath);
    }

    /**
     * Get the specific Query Lambda version associated with a given tag
     * @summary Get Query Lambda Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag name of the tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public getQueryLambdaTagVersion(workspace: string, queryLambda: string, tag: string, options?: any) {
        return QueryLambdasApiFp(this.configuration).getQueryLambdaTagVersion(workspace, queryLambda, tag, options)(this.fetch, this.basePath);
    }

    /**
     * Get a specific version of a Query Lambda
     * @summary Get Query Lambda Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public getQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options?: any) {
        return QueryLambdasApiFp(this.configuration).getQueryLambdaVersion(workspace, queryLambda, version, options)(this.fetch, this.basePath);
    }

    /**
     * List all Query Lambdas.
     * @summary List Query Lambdas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public listAllQueryLambdas(options?: any) {
        return QueryLambdasApiFp(this.configuration).listAllQueryLambdas(options)(this.fetch, this.basePath);
    }

    /**
     * List all tags in an organization
     * @summary List Query Lambda Tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public listOrganizationTags(options?: any) {
        return QueryLambdasApiFp(this.configuration).listOrganizationTags(options)(this.fetch, this.basePath);
    }

    /**
     * List all Query Lambda versions associated with a tag
     * @summary List Query Lambda Tag Versions
     * @param {string} tag name of the tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public listQueryLambdaTagVersions(tag: string, options?: any) {
        return QueryLambdasApiFp(this.configuration).listQueryLambdaTagVersions(tag, options)(this.fetch, this.basePath);
    }

    /**
     * List all tags associated with a Query Lambda
     * @summary List Query Lambda Tags
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public listQueryLambdaTags(workspace: string, queryLambda: string, options?: any) {
        return QueryLambdasApiFp(this.configuration).listQueryLambdaTags(workspace, queryLambda, options)(this.fetch, this.basePath);
    }

    /**
     * List all versions of a Query Lambda.
     * @summary List Query Lambda Versions
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public listQueryLambdaVersions(workspace: string, queryLambda: string, options?: any) {
        return QueryLambdasApiFp(this.configuration).listQueryLambdaVersions(workspace, queryLambda, options)(this.fetch, this.basePath);
    }

    /**
     * List all Query Lambdas under given workspace.
     * @summary List Query Lambdas
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public listQueryLambdasInWorkspace(workspace: string, options?: any) {
        return QueryLambdasApiFp(this.configuration).listQueryLambdasInWorkspace(workspace, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new version of a Query Lambda in given workspace.
     * @summary Update Query Lambda
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {UpdateQueryLambdaRequest} body JSON object
     * @param {boolean} [create] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryLambdasApi
     */
    public updateQueryLambda(workspace: string, queryLambda: string, body: UpdateQueryLambdaRequest, create?: boolean, options?: any) {
        return QueryLambdasApiFp(this.configuration).updateQueryLambda(workspace, queryLambda, body, create, options)(this.fetch, this.basePath);
    }

}

/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new user for an organization.
         * @summary Create User
         * @param {CreateUserRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: CreateUserRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createUser.');
            }
            const localVarPath = `/v1/orgs/self/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateUserRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user from an organization.
         * @summary Delete User
         * @param {string} user user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(user: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/v1/orgs/self/users/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve currently active user.
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/users/self`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all users for an organization.
         * @summary List Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new user for an organization.
         * @summary Create User
         * @param {CreateUserRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: CreateUserRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateUserResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).createUser(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a user from an organization.
         * @summary Delete User
         * @param {string} user user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteUserResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).deleteUser(user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve currently active user.
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getCurrentUser(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all users for an organization.
         * @summary List Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListUsersResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).listUsers(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new user for an organization.
         * @summary Create User
         * @param {CreateUserRequest} body JSON object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: CreateUserRequest, options?: any) {
            return UsersApiFp(configuration).createUser(body, options)(fetch, basePath);
        },
        /**
         * Delete a user from an organization.
         * @summary Delete User
         * @param {string} user user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(user: string, options?: any) {
            return UsersApiFp(configuration).deleteUser(user, options)(fetch, basePath);
        },
        /**
         * Retrieve currently active user.
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: any) {
            return UsersApiFp(configuration).getCurrentUser(options)(fetch, basePath);
        },
        /**
         * Retrieve all users for an organization.
         * @summary List Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(options?: any) {
            return UsersApiFp(configuration).listUsers(options)(fetch, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Create a new user for an organization.
     * @summary Create User
     * @param {CreateUserRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(body: CreateUserRequest, options?: any) {
        return UsersApiFp(this.configuration).createUser(body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a user from an organization.
     * @summary Delete User
     * @param {string} user user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(user: string, options?: any) {
        return UsersApiFp(this.configuration).deleteUser(user, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve currently active user.
     * @summary Get Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getCurrentUser(options?: any) {
        return UsersApiFp(this.configuration).getCurrentUser(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all users for an organization.
     * @summary List Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUsers(options?: any) {
        return UsersApiFp(this.configuration).listUsers(options)(this.fetch, this.basePath);
    }

}

/**
 * WorkspacesApi - fetch parameter creator
 * @export
 */
export const WorkspacesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List workspaces under given workspace.
         * @summary List Workspaces
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        childWorkspaces(workspace: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling childWorkspaces.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}/ws`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new workspace in your org.
         * @summary Create Workspace
         * @param {CreateWorkspaceRequest} body workspace details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace(body: CreateWorkspaceRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createWorkspace.');
            }
            const localVarPath = `/v1/orgs/self/ws`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateWorkspaceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a workspace.
         * @summary Delete Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace(workspace: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling deleteWorkspace.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a single workspace.
         * @summary Get Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspace(workspace: string, options: any = {}): FetchArgs {
            // verify required parameter 'workspace' is not null or undefined
            if (workspace === null || workspace === undefined) {
                throw new RequiredError('workspace','Required parameter workspace was null or undefined when calling getWorkspace.');
            }
            const localVarPath = `/v1/orgs/self/ws/{workspace}`
                .replace(`{${"workspace"}}`, encodeURIComponent(String(workspace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all workspaces.
         * @summary List Workspaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaces(options: any = {}): FetchArgs {
            const localVarPath = `/v1/orgs/self/ws`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkspacesApi - functional programming interface
 * @export
 */
export const WorkspacesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List workspaces under given workspace.
         * @summary List Workspaces
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        childWorkspaces(workspace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListWorkspacesResponse> {
            const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).childWorkspaces(workspace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new workspace in your org.
         * @summary Create Workspace
         * @param {CreateWorkspaceRequest} body workspace details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace(body: CreateWorkspaceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateWorkspaceResponse> {
            const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).createWorkspace(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove a workspace.
         * @summary Delete Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace(workspace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteWorkspaceResponse> {
            const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).deleteWorkspace(workspace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information about a single workspace.
         * @summary Get Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspace(workspace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetWorkspaceResponse> {
            const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).getWorkspace(workspace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all workspaces.
         * @summary List Workspaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaces(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListWorkspacesResponse> {
            const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).listWorkspaces(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WorkspacesApi - factory interface
 * @export
 */
export const WorkspacesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * List workspaces under given workspace.
         * @summary List Workspaces
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        childWorkspaces(workspace: string, options?: any) {
            return WorkspacesApiFp(configuration).childWorkspaces(workspace, options)(fetch, basePath);
        },
        /**
         * Create a new workspace in your org.
         * @summary Create Workspace
         * @param {CreateWorkspaceRequest} body workspace details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace(body: CreateWorkspaceRequest, options?: any) {
            return WorkspacesApiFp(configuration).createWorkspace(body, options)(fetch, basePath);
        },
        /**
         * Remove a workspace.
         * @summary Delete Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace(workspace: string, options?: any) {
            return WorkspacesApiFp(configuration).deleteWorkspace(workspace, options)(fetch, basePath);
        },
        /**
         * Get information about a single workspace.
         * @summary Get Workspace
         * @param {string} workspace name of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspace(workspace: string, options?: any) {
            return WorkspacesApiFp(configuration).getWorkspace(workspace, options)(fetch, basePath);
        },
        /**
         * List all workspaces.
         * @summary List Workspaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaces(options?: any) {
            return WorkspacesApiFp(configuration).listWorkspaces(options)(fetch, basePath);
        },
    };
};

/**
 * WorkspacesApi - object-oriented interface
 * @export
 * @class WorkspacesApi
 * @extends {BaseAPI}
 */
export class WorkspacesApi extends BaseAPI {
    /**
     * List workspaces under given workspace.
     * @summary List Workspaces
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public childWorkspaces(workspace: string, options?: any) {
        return WorkspacesApiFp(this.configuration).childWorkspaces(workspace, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new workspace in your org.
     * @summary Create Workspace
     * @param {CreateWorkspaceRequest} body workspace details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public createWorkspace(body: CreateWorkspaceRequest, options?: any) {
        return WorkspacesApiFp(this.configuration).createWorkspace(body, options)(this.fetch, this.basePath);
    }

    /**
     * Remove a workspace.
     * @summary Delete Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public deleteWorkspace(workspace: string, options?: any) {
        return WorkspacesApiFp(this.configuration).deleteWorkspace(workspace, options)(this.fetch, this.basePath);
    }

    /**
     * Get information about a single workspace.
     * @summary Get Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public getWorkspace(workspace: string, options?: any) {
        return WorkspacesApiFp(this.configuration).getWorkspace(workspace, options)(this.fetch, this.basePath);
    }

    /**
     * List all workspaces.
     * @summary List Workspaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public listWorkspaces(options?: any) {
        return WorkspacesApiFp(this.configuration).listWorkspaces(options)(this.fetch, this.basePath);
    }

}


// tslint:disable
/**
 * REST API
 * Rockset's REST API allows for creating and managing all resources in Rockset. Each supported endpoint is documented below.  All requests must be authorized with a Rockset API key, which can be created in the [Rockset console](https://console.rockset.com). The API key must be provided as `ApiKey <api_key>` in the `Authorization` request header. For example: ``` Authorization: ApiKey aB35kDjg93J5nsf4GjwMeErAVd832F7ad4vhsW1S02kfZiab42sTsfW5Sxt25asT ```  All endpoints are only accessible via https.  Build something awesome!
 *
 * OpenAPI spec version: v1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as url from 'url';
import * as portableFetch from 'portable-fetch';
import { Configuration } from './configuration';

const BASE_PATH = 'https://api.rs2.usw2.rockset.com'.replace(/\/+$/, '');

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|',
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = portableFetch,
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name: 'RequiredError';
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 *
 * @export
 * @interface AddDocumentsRequest
 */
export interface AddDocumentsRequest {
  /**
   * Array of JSON documents
   * @type {Array<any>}
   * @memberof AddDocumentsRequest
   */
  data: Array<any>;
}

/**
 *
 * @export
 * @interface AddDocumentsResponse
 */
export interface AddDocumentsResponse {
  /**
   * information about the added documents
   * @type {Array<DocumentStatus>}
   * @memberof AddDocumentsResponse
   */
  data?: Array<DocumentStatus>;
}

/**
 *
 * @export
 * @interface AggregateQueryLambdaStats
 */
export interface AggregateQueryLambdaStats {
  /**
   * average latency over time bucket
   * @type {number}
   * @memberof AggregateQueryLambdaStats
   */
  average_latency?: number;
  /**
   * max latency over time bucket
   * @type {number}
   * @memberof AggregateQueryLambdaStats
   */
  max_latency?: number;
  /**
   * total error count over time bucket
   * @type {number}
   * @memberof AggregateQueryLambdaStats
   */
  error_count?: number;
  /**
   * total query count over time bucket
   * @type {number}
   * @memberof AggregateQueryLambdaStats
   */
  query_count?: number;
  /**
   * timestamp in unix seconds
   * @type {number}
   * @memberof AggregateQueryLambdaStats
   */
  timestamp?: number;
}

/**
 *
 * @export
 * @interface AggregateQueryLambdaStatsResponse
 */
export interface AggregateQueryLambdaStatsResponse {
  /**
   * list of aggregated Query Lambda stats
   * @type {Array<AggregateQueryLambdaStats>}
   * @memberof AggregateQueryLambdaStatsResponse
   */
  data?: Array<AggregateQueryLambdaStats>;
}

/**
 *
 * @export
 * @interface Alias
 */
export interface Alias {
  /**
   * name of the alias
   * @type {string}
   * @memberof Alias
   */
  name?: string;
  /**
   * alias description
   * @type {string}
   * @memberof Alias
   */
  description?: string;
  /**
   * name of the workspace
   * @type {string}
   * @memberof Alias
   */
  workspace?: string;
  /**
   * email of the creator
   * @type {string}
   * @memberof Alias
   */
  creator_email?: string;
  /**
   * list of fully qualified collection names referenced by alias
   * @type {Array<string>}
   * @memberof Alias
   */
  collections?: Array<string>;
  /**
   * state of the alias
   * @type {string}
   * @memberof Alias
   */
  state?: Alias.StateEnum;
  /**
   * ISO-8601 date
   * @type {string}
   * @memberof Alias
   */
  created_at?: string;
  /**
   * ISO-8601 date
   * @type {string}
   * @memberof Alias
   */
  modified_at?: string;
}

/**
 * @export
 * @namespace Alias
 */
export namespace Alias {
  /**
   * @export
   * @enum {string}
   */
  export enum StateEnum {
    CREATED = <any>'CREATED',
    DELETED = <any>'DELETED',
  }
}

/**
 * API keys are used to authenticate requests to Rockset's API. An API key is tied to the user who creates it. A new API key can be created for each use case, with a maximum of 10 API keys per user.
 * @export
 * @interface ApiKey
 */
export interface ApiKey {
  /**
   * ISO-8601 date
   * @type {string}
   * @memberof ApiKey
   */
  created_at?: string;
  /**
   * descriptive label
   * @type {string}
   * @memberof ApiKey
   */
  name: string;
  /**
   * string of 64 alphanumeric characters
   * @type {string}
   * @memberof ApiKey
   */
  key: string;
  /**
   * ISO-8601 date
   * @type {string}
   * @memberof ApiKey
   */
  last_access_time?: string;
  /**
   * user's email
   * @type {string}
   * @memberof ApiKey
   */
  created_by?: string;
}

/**
 *
 * @export
 * @interface AwsAccessKey
 */
export interface AwsAccessKey {
  /**
   * AWS access key ID
   * @type {string}
   * @memberof AwsAccessKey
   */
  aws_access_key_id: string;
  /**
   * AWS secret access key
   * @type {string}
   * @memberof AwsAccessKey
   */
  aws_secret_access_key: string;
}

/**
 *
 * @export
 * @interface AwsRole
 */
export interface AwsRole {
  /**
   * ARN of rockset-role created in your account
   * @type {string}
   * @memberof AwsRole
   */
  aws_role_arn: string;
}

/**
 *
 * @export
 * @interface BodyPart
 */
export interface BodyPart {
  /**
   *
   * @type {ContentDisposition}
   * @memberof BodyPart
   */
  contentDisposition?: ContentDisposition;
  /**
   *
   * @type {any}
   * @memberof BodyPart
   */
  entity?: any;
  /**
   *
   * @type {{ [key: string]: Array<string>; }}
   * @memberof BodyPart
   */
  headers?: { [key: string]: Array<string> };
  /**
   *
   * @type {MediaType}
   * @memberof BodyPart
   */
  mediaType?: MediaType;
  /**
   *
   * @type {MessageBodyWorkers}
   * @memberof BodyPart
   */
  messageBodyWorkers?: MessageBodyWorkers;
  /**
   *
   * @type {MultiPart}
   * @memberof BodyPart
   */
  parent?: MultiPart;
  /**
   *
   * @type {Providers}
   * @memberof BodyPart
   */
  providers?: Providers;
  /**
   *
   * @type {{ [key: string]: Array<ParameterizedHeader>; }}
   * @memberof BodyPart
   */
  parameterizedHeaders?: { [key: string]: Array<ParameterizedHeader> };
}

/**
 *
 * @export
 * @interface Cluster
 */
export interface Cluster {
  /**
   * unique identifier for the cluster
   * @type {string}
   * @memberof Cluster
   */
  id?: string;
  /**
   * cluster type
   * @type {string}
   * @memberof Cluster
   */
  cluster_type?: Cluster.ClusterTypeEnum;
  /**
   * aws region
   * @type {string}
   * @memberof Cluster
   */
  aws_region?: string;
  /**
   * domain of org using cluster
   * @type {string}
   * @memberof Cluster
   */
  domain?: string;
  /**
   * top level domain of org using cluster
   * @type {string}
   * @memberof Cluster
   */
  top_level_domain?: string;
  /**
   * api server url for cluster
   * @type {string}
   * @memberof Cluster
   */
  apiserver_url?: string;
}

/**
 * @export
 * @namespace Cluster
 */
export namespace Cluster {
  /**
   * @export
   * @enum {string}
   */
  export enum ClusterTypeEnum {
    PUBLIC = <any>'PUBLIC',
    PRIVATE = <any>'PRIVATE',
  }
}

/**
 *
 * @export
 * @interface Collection
 */
export interface Collection {
  /**
   * ISO-8601 date
   * @type {string}
   * @memberof Collection
   */
  created_at?: string;
  /**
   * email of user who created the collection
   * @type {string}
   * @memberof Collection
   */
  created_by?: string;
  /**
   * unique identifer for collection, can contain alphanumeric or dash characters
   * @type {string}
   * @memberof Collection
   */
  name?: string;
  /**
   * text describing the collection
   * @type {string}
   * @memberof Collection
   */
  description?: string;
  /**
   * name of the workspace that the collection is in
   * @type {string}
   * @memberof Collection
   */
  workspace?: string;
  /**
   * current status of collection, one of: CREATED, READY, DELETED
   * @type {string}
   * @memberof Collection
   */
  status?: Collection.StatusEnum;
  /**
   * list of sources from which collection ingests
   * @type {Array<Source>}
   * @memberof Collection
   */
  sources?: Array<Source>;
  /**
   * metrics about the collection
   * @type {CollectionStats}
   * @memberof Collection
   */
  stats?: CollectionStats;
  /**
   * number of seconds after which data is purged based on event time
   * @type {number}
   * @memberof Collection
   */
  retention_secs?: number;
  /**
   * list of mappings applied on all documents in a collection
   * @type {Array<FieldMappingV2>}
   * @memberof Collection
   */
  field_mappings?: Array<FieldMappingV2>;
  /**
   * list of aliases for a collection
   * @type {Array<Alias>}
   * @memberof Collection
   */
  aliases?: Array<Alias>;
}

/**
 * @export
 * @namespace Collection
 */
export namespace Collection {
  /**
   * @export
   * @enum {string}
   */
  export enum StatusEnum {
    INITIALIZED = <any>'INITIALIZED',
    CREATED = <any>'CREATED',
    READY = <any>'READY',
    PAUSED = <any>'PAUSED',
    DELETED = <any>'DELETED',
    PAUSING = <any>'PAUSING',
    RESUMING = <any>'RESUMING',
    BULKINGESTMODE = <any>'BULK_INGEST_MODE',
    EXITINGBULKINGESTMODE = <any>'EXITING_BULK_INGEST_MODE',
    UNKNOWN = <any>'UNKNOWN',
  }
}

/**
 *
 * @export
 * @interface CollectionStats
 */
export interface CollectionStats {
  /**
   * number of documents in the collection
   * @type {number}
   * @memberof CollectionStats
   */
  doc_count?: number;
  /**
   * number of documents purged from the collection
   * @type {number}
   * @memberof CollectionStats
   */
  purged_doc_count?: number;
  /**
   * number between 0 and 1 that indicates progress of collection creation
   * @type {number}
   * @memberof CollectionStats
   */
  fill_progress?: number;
  /**
   * milliseconds since Unix epoch Jan 1, 1970
   * @type {number}
   * @memberof CollectionStats
   */
  last_queried_ms?: number;
  /**
   * milliseconds since Unix epoch Jan 1, 1970
   * @type {number}
   * @memberof CollectionStats
   */
  last_updated_ms?: number;
  /**
   * total collection size in bytes
   * @type {number}
   * @memberof CollectionStats
   */
  total_size?: number;
  /**
   * total collection index size in bytes
   * @type {number}
   * @memberof CollectionStats
   */
  total_index_size?: number;
  /**
   * total collection row index size in bytes
   * @type {number}
   * @memberof CollectionStats
   */
  row_index_size?: number;
  /**
   * total collection column index size in bytes
   * @type {number}
   * @memberof CollectionStats
   */
  column_index_size?: number;
  /**
   * total collection inverted index size in bytes
   * @type {number}
   * @memberof CollectionStats
   */
  inverted_index_size?: number;
  /**
   * total collection range index size in bytes
   * @type {number}
   * @memberof CollectionStats
   */
  range_index_size?: number;
  /**
   * total size of bytes purged in bytes
   * @type {number}
   * @memberof CollectionStats
   */
  purged_doc_size?: number;
  /**
   * total number of bytes inserted into the collection
   * @type {number}
   * @memberof CollectionStats
   */
  bytes_inserted?: number;
  /**
   * total number of bytes overwritten in writing into the collection
   * @type {number}
   * @memberof CollectionStats
   */
  bytes_overwritten?: number;
}

/**
 *
 * @export
 * @interface ComputeUsage
 */
export interface ComputeUsage {
  /**
   *
   * @type {string}
   * @memberof ComputeUsage
   */
  compute_type: ComputeUsage.ComputeTypeEnum;
  /**
   *
   * @type {number}
   * @memberof ComputeUsage
   */
  unit_price: number;
  /**
   *
   * @type {number}
   * @memberof ComputeUsage
   */
  fixed_compute_cost: number;
  /**
   *
   * @type {number}
   * @memberof ComputeUsage
   */
  fixed_compute_price: number;
  /**
   *
   * @type {number}
   * @memberof ComputeUsage
   */
  minutes: number;
  /**
   *
   * @type {number}
   * @memberof ComputeUsage
   */
  gb_hours: number;
  /**
   *
   * @type {number}
   * @memberof ComputeUsage
   */
  total_storage_cost: number;
  /**
   *
   * @type {number}
   * @memberof ComputeUsage
   */
  total_compute_cost: number;
}

/**
 * @export
 * @namespace ComputeUsage
 */
export namespace ComputeUsage {
  /**
   * @export
   * @enum {string}
   */
  export enum ComputeTypeEnum {
    FREE = <any>'FREE',
    F3 = <any>'F3',
    C3 = <any>'C3',
    M3 = <any>'M3',
  }
}

/**
 *
 * @export
 * @interface ContactSalesRequest
 */
export interface ContactSalesRequest {
  /**
   * email to cc, determined by user
   * @type {string}
   * @memberof ContactSalesRequest
   */
  cc_email?: string;
  /**
   * user phone number
   * @type {string}
   * @memberof ContactSalesRequest
   */
  phone_number?: string;
  /**
   * category user is contacting us about
   * @type {string}
   * @memberof ContactSalesRequest
   */
  category?: string;
  /**
   * message from user
   * @type {string}
   * @memberof ContactSalesRequest
   */
  message?: string;
  /**
   * source of contact sales trigger
   * @type {string}
   * @memberof ContactSalesRequest
   */
  source?: string;
}

/**
 *
 * @export
 * @interface ContentDisposition
 */
export interface ContentDisposition {
  /**
   *
   * @type {string}
   * @memberof ContentDisposition
   */
  type?: string;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof ContentDisposition
   */
  parameters?: { [key: string]: string };
  /**
   *
   * @type {string}
   * @memberof ContentDisposition
   */
  fileName?: string;
  /**
   *
   * @type {Date}
   * @memberof ContentDisposition
   */
  creationDate?: Date;
  /**
   *
   * @type {Date}
   * @memberof ContentDisposition
   */
  modificationDate?: Date;
  /**
   *
   * @type {Date}
   * @memberof ContentDisposition
   */
  readDate?: Date;
  /**
   *
   * @type {number}
   * @memberof ContentDisposition
   */
  size?: number;
}

/**
 *
 * @export
 * @interface CreateAliasRequest
 */
export interface CreateAliasRequest {
  /**
   * Alias name
   * @type {string}
   * @memberof CreateAliasRequest
   */
  name: string;
  /**
   * optional description
   * @type {string}
   * @memberof CreateAliasRequest
   */
  description?: string;
  /**
   * list of fully qualified collection names referenced by alias
   * @type {Array<string>}
   * @memberof CreateAliasRequest
   */
  collections: Array<string>;
}

/**
 *
 * @export
 * @interface CreateAliasResponse
 */
export interface CreateAliasResponse {
  /**
   * alias that was created
   * @type {Alias}
   * @memberof CreateAliasResponse
   */
  data?: Alias;
}

/**
 *
 * @export
 * @interface CreateApiKeyRequest
 */
export interface CreateApiKeyRequest {
  /**
   * descriptive label
   * @type {string}
   * @memberof CreateApiKeyRequest
   */
  name: string;
}

/**
 *
 * @export
 * @interface CreateApiKeyResponse
 */
export interface CreateApiKeyResponse {
  /**
   * the API key that was created
   * @type {ApiKey}
   * @memberof CreateApiKeyResponse
   */
  data?: ApiKey;
}

/**
 *
 * @export
 * @interface CreateCollectionRequest
 */
export interface CreateCollectionRequest {
  /**
   * unique identifier for collection, can contain alphanumeric or dash characters
   * @type {string}
   * @memberof CreateCollectionRequest
   */
  name: string;
  /**
   * text describing the collection
   * @type {string}
   * @memberof CreateCollectionRequest
   */
  description?: string;
  /**
   * list of sources from which to ingest data
   * @type {Array<Source>}
   * @memberof CreateCollectionRequest
   */
  sources?: Array<Source>;
  /**
   * number of seconds after which data is purged, based on event time
   * @type {number}
   * @memberof CreateCollectionRequest
   */
  retention_secs?: number;
  /**
   * configuration for event data
   * @type {EventTimeInfo}
   * @memberof CreateCollectionRequest
   */
  event_time_info?: EventTimeInfo;
  /**
   * list of mappings
   * @type {Array<FieldMappingV2>}
   * @memberof CreateCollectionRequest
   */
  field_mappings?: Array<FieldMappingV2>;
  /**
   * Create collection in bulk ingest mode
   * @type {boolean}
   * @memberof CreateCollectionRequest
   */
  force_bulk_load?: boolean;
  /**
   * Virtual instance type, chosen at first collection creation
   * @type {string}
   * @memberof CreateCollectionRequest
   */
  instance_type?: CreateCollectionRequest.InstanceTypeEnum;
}

/**
 * @export
 * @namespace CreateCollectionRequest
 */
export namespace CreateCollectionRequest {
  /**
   * @export
   * @enum {string}
   */
  export enum InstanceTypeEnum {
    FREE = <any>'FREE',
    SHARED = <any>'SHARED',
    SMALL = <any>'SMALL',
    MEDIUM = <any>'MEDIUM',
    LARGE = <any>'LARGE',
    XLARGE = <any>'XLARGE',
    XLARGE2 = <any>'XLARGE2',
    XLARGE4 = <any>'XLARGE4',
    XLARGE8 = <any>'XLARGE8',
    XLARGE16 = <any>'XLARGE16',
  }
}

/**
 *
 * @export
 * @interface CreateCollectionResponse
 */
export interface CreateCollectionResponse {
  /**
   * collection that was created
   * @type {Collection}
   * @memberof CreateCollectionResponse
   */
  data?: Collection;
}

/**
 *
 * @export
 * @interface CreateIntegrationRequest
 */
export interface CreateIntegrationRequest {
  /**
   * descriptive label
   * @type {string}
   * @memberof CreateIntegrationRequest
   */
  name: string;
  /**
   * longer explanation for the integration
   * @type {string}
   * @memberof CreateIntegrationRequest
   */
  description?: string;
  /**
   * Amazon S3 details, must have one of aws_access_key or aws_role
   * @type {S3Integration}
   * @memberof CreateIntegrationRequest
   */
  s3?: S3Integration;
  /**
   * Amazon Kinesis details, must have one of aws_access_key or aws_role
   * @type {KinesisIntegration}
   * @memberof CreateIntegrationRequest
   */
  kinesis?: KinesisIntegration;
  /**
   * Amazon DynamoDB details, must have one of aws_access_key or aws_role
   * @type {DynamodbIntegration}
   * @memberof CreateIntegrationRequest
   */
  dynamodb?: DynamodbIntegration;
  /**
   * Amazon Redshift details
   * @type {RedshiftIntegration}
   * @memberof CreateIntegrationRequest
   */
  redshift?: RedshiftIntegration;
  /**
   * GCS details
   * @type {GcsIntegration}
   * @memberof CreateIntegrationRequest
   */
  gcs?: GcsIntegration;
  /**
   *
   * @type {SegmentIntegration}
   * @memberof CreateIntegrationRequest
   */
  segment?: SegmentIntegration;
  /**
   *
   * @type {KafkaIntegration}
   * @memberof CreateIntegrationRequest
   */
  kafka?: KafkaIntegration;
  /**
   * MongoDb details
   * @type {MongoDbIntegration}
   * @memberof CreateIntegrationRequest
   */
  mongodb?: MongoDbIntegration;
}

/**
 *
 * @export
 * @interface CreateIntegrationResponse
 */
export interface CreateIntegrationResponse {
  /**
   * integration object that was created
   * @type {Integration}
   * @memberof CreateIntegrationResponse
   */
  data?: Integration;
}

/**
 *
 * @export
 * @interface CreateOrganizationRequest
 */
export interface CreateOrganizationRequest {
  /**
   * unique identifier for the organization
   * @type {string}
   * @memberof CreateOrganizationRequest
   */
  id: string;
  /**
   * name of the organization
   * @type {string}
   * @memberof CreateOrganizationRequest
   */
  display_name?: string;
  /**
   * compute type for org
   * @type {string}
   * @memberof CreateOrganizationRequest
   */
  requested_compute_type?: CreateOrganizationRequest.RequestedComputeTypeEnum;
  /**
   * name of the creating user
   * @type {string}
   * @memberof CreateOrganizationRequest
   */
  first_name?: string;
  /**
   * name of the creating user
   * @type {string}
   * @memberof CreateOrganizationRequest
   */
  last_name?: string;
  /**
   * email of the creating user
   * @type {string}
   * @memberof CreateOrganizationRequest
   */
  email?: string;
  /**
   * name of the company
   * @type {string}
   * @memberof CreateOrganizationRequest
   */
  company_name?: string;
  /**
   * phone number of the user
   * @type {string}
   * @memberof CreateOrganizationRequest
   */
  phone_number?: string;
  /**
   * whether plan is a 15 day free trial
   * @type {boolean}
   * @memberof CreateOrganizationRequest
   */
  trial?: boolean;
  /**
   * whether to use KMS for S3 operations
   * @type {boolean}
   * @memberof CreateOrganizationRequest
   */
  use_kms_for_s3?: boolean;
  /**
   * cluster id
   * @type {string}
   * @memberof CreateOrganizationRequest
   */
  cluster_id?: string;
  /**
   * encyption key
   * @type {string}
   * @memberof CreateOrganizationRequest
   */
  encryption_key?: string;
}

/**
 * @export
 * @namespace CreateOrganizationRequest
 */
export namespace CreateOrganizationRequest {
  /**
   * @export
   * @enum {string}
   */
  export enum RequestedComputeTypeEnum {
    FREE = <any>'FREE',
    F3 = <any>'F3',
    C3 = <any>'C3',
    M3 = <any>'M3',
  }
}

/**
 *
 * @export
 * @interface CreatePreviewSourceRequest
 */
export interface CreatePreviewSourceRequest {
  /**
   * name of integration to use
   * @type {string}
   * @memberof CreatePreviewSourceRequest
   */
  integration_name?: string;
  /**
   * whether type is file upload
   * @type {boolean}
   * @memberof CreatePreviewSourceRequest
   */
  file_upload?: boolean;
  /**
   * configuration to receive data from kafka
   * @type {SourceKafka}
   * @memberof CreatePreviewSourceRequest
   */
  kafka?: SourceKafka;
}

/**
 *
 * @export
 * @interface CreatePreviewSourceResponse
 */
export interface CreatePreviewSourceResponse {
  /**
   * details of the created preview source
   * @type {PreviewSource}
   * @memberof CreatePreviewSourceResponse
   */
  data?: PreviewSource;
}

/**
 *
 * @export
 * @interface CreateQueryLambdaRequest
 */
export interface CreateQueryLambdaRequest {
  /**
   * Query Lambda name
   * @type {string}
   * @memberof CreateQueryLambdaRequest
   */
  name: string;
  /**
   * optional description
   * @type {string}
   * @memberof CreateQueryLambdaRequest
   */
  description?: string;
  /**
   * Query Lambda SQL query
   * @type {QueryLambdaSql}
   * @memberof CreateQueryLambdaRequest
   */
  sql: QueryLambdaSql;
}

/**
 *
 * @export
 * @interface CreateQueryLambdaTagRequest
 */
export interface CreateQueryLambdaTagRequest {
  /**
   * name of Query Lambda tag
   * @type {string}
   * @memberof CreateQueryLambdaTagRequest
   */
  tag_name: string;
  /**
   * hash identifying a Query Lambda tag
   * @type {string}
   * @memberof CreateQueryLambdaTagRequest
   */
  version: string;
}

/**
 *
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
  /**
   * user email, must be unique
   * @type {string}
   * @memberof CreateUserRequest
   */
  email: string;
  /**
   * List of roles for a given user
   * @type {Array<string>}
   * @memberof CreateUserRequest
   */
  roles: Array<string>;
}

/**
 *
 * @export
 * @interface CreateUserResponse
 */
export interface CreateUserResponse {
  /**
   * user that was created
   * @type {User}
   * @memberof CreateUserResponse
   */
  data?: User;
}

/**
 *
 * @export
 * @interface CreateWorkspaceRequest
 */
export interface CreateWorkspaceRequest {
  /**
   * descriptive label and unique identifier
   * @type {string}
   * @memberof CreateWorkspaceRequest
   */
  name: string;
  /**
   * longer explanation for the workspace
   * @type {string}
   * @memberof CreateWorkspaceRequest
   */
  description?: string;
}

/**
 *
 * @export
 * @interface CreateWorkspaceResponse
 */
export interface CreateWorkspaceResponse {
  /**
   * the workspace that was created
   * @type {Workspace}
   * @memberof CreateWorkspaceResponse
   */
  data?: Workspace;
}

/**
 *
 * @export
 * @interface CsvParams
 */
export interface CsvParams {
  /**
   * If the first line in every object specifies the column names
   * @type {boolean}
   * @memberof CsvParams
   */
  firstLineAsColumnNames?: boolean;
  /**
   * a single character that is the column separator
   * @type {string}
   * @memberof CsvParams
   */
  separator?: string;
  /**
   * can be one of: UTF-8, ISO_8859_1, UTF-16
   * @type {string}
   * @memberof CsvParams
   */
  encoding?: string;
  /**
   * names of columns
   * @type {Array<string>}
   * @memberof CsvParams
   */
  columnNames?: Array<string>;
  /**
   * names of columns
   * @type {Array<string>}
   * @memberof CsvParams
   */
  columnTypes?: Array<CsvParams.ColumnTypesEnum>;
  /**
   * character within which a cell value is enclosed,null character if no such character, default is '\"'
   * @type {string}
   * @memberof CsvParams
   */
  quoteChar?: string;
  /**
   * escape character removes any special meaning from the following character,default is '\\'
   * @type {string}
   * @memberof CsvParams
   */
  escapeChar?: string;
}

/**
 * @export
 * @namespace CsvParams
 */
export namespace CsvParams {
  /**
   * @export
   * @enum {string}
   */
  export enum ColumnTypesEnum {
    UNKNOWN = <any>'UNKNOWN',
    BOOLEAN = <any>'BOOLEAN',
    BOOL = <any>'BOOL',
    INTEGER = <any>'INTEGER',
    INT = <any>'INT',
    FLOAT = <any>'FLOAT',
    TIME = <any>'TIME',
    DATE = <any>'DATE',
    DATETIME = <any>'DATETIME',
    TIMESTAMP = <any>'TIMESTAMP',
    STRING = <any>'STRING',
  }
}

/**
 *
 * @export
 * @interface DeleteAliasResponse
 */
export interface DeleteAliasResponse {
  /**
   * alias that was deleted
   * @type {Alias}
   * @memberof DeleteAliasResponse
   */
  data?: Alias;
}

/**
 *
 * @export
 * @interface DeleteApiKeyResponse
 */
export interface DeleteApiKeyResponse {
  /**
   * the API key that was deleted
   * @type {ApiKey}
   * @memberof DeleteApiKeyResponse
   */
  data?: ApiKey;
}

/**
 *
 * @export
 * @interface DeleteCollectionResponse
 */
export interface DeleteCollectionResponse {
  /**
   * collection that was deleted
   * @type {Collection}
   * @memberof DeleteCollectionResponse
   */
  data?: Collection;
}

/**
 *
 * @export
 * @interface DeleteDocumentsRequest
 */
export interface DeleteDocumentsRequest {
  /**
   * array of document IDs
   * @type {Array<DeleteDocumentsRequestData>}
   * @memberof DeleteDocumentsRequest
   */
  data: Array<DeleteDocumentsRequestData>;
}

/**
 *
 * @export
 * @interface DeleteDocumentsRequestData
 */
export interface DeleteDocumentsRequestData {
  /**
   * unique document ID
   * @type {string}
   * @memberof DeleteDocumentsRequestData
   */
  _id: string;
}

/**
 *
 * @export
 * @interface DeleteDocumentsResponse
 */
export interface DeleteDocumentsResponse {
  /**
   * information about deleted documents
   * @type {Array<DocumentStatus>}
   * @memberof DeleteDocumentsResponse
   */
  data?: Array<DocumentStatus>;
}

/**
 *
 * @export
 * @interface DeleteIntegrationResponse
 */
export interface DeleteIntegrationResponse {
  /**
   * integration object that was deleted
   * @type {Integration}
   * @memberof DeleteIntegrationResponse
   */
  data?: Integration;
}

/**
 *
 * @export
 * @interface DeleteQueryLambdaResponse
 */
export interface DeleteQueryLambdaResponse {
  /**
   * Query Lambda details
   * @type {QueryLambda}
   * @memberof DeleteQueryLambdaResponse
   */
  data?: QueryLambda;
}

/**
 *
 * @export
 * @interface DeleteUserResponse
 */
export interface DeleteUserResponse {
  /**
   * user object that was deleted
   * @type {User}
   * @memberof DeleteUserResponse
   */
  data?: User;
}

/**
 *
 * @export
 * @interface DeleteWorkspaceResponse
 */
export interface DeleteWorkspaceResponse {
  /**
   * the workspace that was deleted
   * @type {Workspace}
   * @memberof DeleteWorkspaceResponse
   */
  data?: Workspace;
}

/**
 *
 * @export
 * @interface DocumentStatus
 */
export interface DocumentStatus {
  /**
   * collection name
   * @type {string}
   * @memberof DocumentStatus
   */
  _collection?: string;
  /**
   * error message, if any
   * @type {ErrorModel}
   * @memberof DocumentStatus
   */
  error?: ErrorModel;
  /**
   * unique document ID
   * @type {string}
   * @memberof DocumentStatus
   */
  _id?: string;
  /**
   * status, one of ADDED, REPLACED, DELETED, ERROR
   * @type {string}
   * @memberof DocumentStatus
   */
  status?: DocumentStatus.StatusEnum;
  /**
   * unique id used to represent each patch request
   * @type {string}
   * @memberof DocumentStatus
   */
  patch_id?: string;
}

/**
 * @export
 * @namespace DocumentStatus
 */
export namespace DocumentStatus {
  /**
   * @export
   * @enum {string}
   */
  export enum StatusEnum {
    ADDED = <any>'ADDED',
    REPLACED = <any>'REPLACED',
    DELETED = <any>'DELETED',
    PATCHED = <any>'PATCHED',
    ERROR = <any>'ERROR',
  }
}

/**
 *
 * @export
 * @interface DynamodbIntegration
 */
export interface DynamodbIntegration {
  /**
   * credentials for an AWS access key integration
   * @type {AwsAccessKey}
   * @memberof DynamodbIntegration
   */
  aws_access_key?: AwsAccessKey;
  /**
   * role used for external id type authentication
   * @type {AwsRole}
   * @memberof DynamodbIntegration
   */
  aws_role?: AwsRole;
}

/**
 * Describes details about an error
 * @export
 * @interface ErrorModel
 */
export interface ErrorModel {
  /**
   * descriptive message about the error
   * @type {string}
   * @memberof ErrorModel
   */
  message?: string;
  /**
   * category of the error
   * @type {string}
   * @memberof ErrorModel
   */
  type?: ErrorModel.TypeEnum;
  /**
   * Line where the error happened (if applicable)
   * @type {number}
   * @memberof ErrorModel
   */
  line?: number;
  /**
   * Column where the error happened (if applicable)
   * @type {number}
   * @memberof ErrorModel
   */
  column?: number;
  /**
   * Internal trace ID to help with debugging
   * @type {string}
   * @memberof ErrorModel
   */
  trace_id?: string;
  /**
   * ID of the error
   * @type {string}
   * @memberof ErrorModel
   */
  error_id?: string;
}

/**
 * @export
 * @namespace ErrorModel
 */
export namespace ErrorModel {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    AUTHEXCEPTION = <any>'AUTHEXCEPTION',
    VERSIONEXCEPTION = <any>'VERSIONEXCEPTION',
    INTERNALERROR = <any>'INTERNALERROR',
    INVALIDINPUT = <any>'INVALIDINPUT',
    NOTIMPLEMENTEDYET = <any>'NOTIMPLEMENTEDYET',
    RESOURCEEXCEEDED = <any>'RESOURCEEXCEEDED',
    ALREADYEXISTS = <any>'ALREADYEXISTS',
    NOTALLOWED = <any>'NOTALLOWED',
    NOTACCEPTABLE = <any>'NOTACCEPTABLE',
    NOTSUPPORTED = <any>'NOTSUPPORTED',
    NOTFOUND = <any>'NOTFOUND',
    DEPENDENTRESOURCES = <any>'DEPENDENTRESOURCES',
    QUERYERROR = <any>'QUERY_ERROR',
    NOTREADY = <any>'NOT_READY',
    FORBIDDEN = <any>'FORBIDDEN',
    QUERYTIMEOUT = <any>'QUERY_TIMEOUT',
    ROLENOTFOUND = <any>'ROLE_NOT_FOUND',
    CONNECTIONERROR = <any>'CONNECTION_ERROR',
    CREATING = <any>'CREATING',
    BADREQUEST = <any>'BADREQUEST',
    RATELIMITEXCEEDED = <any>'RATELIMITEXCEEDED',
  }
}

/**
 *
 * @export
 * @interface EventTimeInfo
 */
export interface EventTimeInfo {
  /**
   * name of the field containing event time
   * @type {string}
   * @memberof EventTimeInfo
   */
  field: string;
  /**
   * format of time field, can be one of: milliseconds_since_epoch, seconds_since_epoch
   * @type {string}
   * @memberof EventTimeInfo
   */
  format?: string;
  /**
   * default time zone, in standard IANA format
   * @type {string}
   * @memberof EventTimeInfo
   */
  time_zone?: string;
}

/**
 *
 * @export
 * @interface ExecuteQueryLambdaRequest
 */
export interface ExecuteQueryLambdaRequest {
  /**
   * list of named parameters
   * @type {Array<QueryParameter>}
   * @memberof ExecuteQueryLambdaRequest
   */
  parameters?: Array<QueryParameter>;
  /**
   * Row limit to use if no limit specified in the SQL query text
   * @type {number}
   * @memberof ExecuteQueryLambdaRequest
   */
  default_row_limit?: number;
  /**
   * Whether to generate warnings
   * @type {boolean}
   * @memberof ExecuteQueryLambdaRequest
   */
  generate_warnings?: boolean;
}

/**
 *
 * @export
 * @interface FieldMapping
 */
export interface FieldMapping {}

/**
 *
 * @export
 * @interface FieldMappingV2
 */
export interface FieldMappingV2 {
  /**
   * A user specified string that is a name for this mapping
   * @type {string}
   * @memberof FieldMappingV2
   */
  name?: string;
  /**
   * A boolean that determines whether to drop all fields in this document. If set, input and output fields should not be set
   * @type {boolean}
   * @memberof FieldMappingV2
   */
  is_drop_all_fields?: boolean;
  /**
   * A List of InputField for this mapping
   * @type {Array<InputField>}
   * @memberof FieldMappingV2
   */
  input_fields?: Array<InputField>;
  /**
   * An OutputField for this mapping
   * @type {OutputField}
   * @memberof FieldMappingV2
   */
  output_field?: OutputField;
}

/**
 *
 * @export
 * @interface FieldMask
 */
export interface FieldMask {
  /**
   *
   * @type {Array<string>}
   * @memberof FieldMask
   */
  input_path: Array<string>;
  /**
   *
   * @type {FieldMaskMask}
   * @memberof FieldMask
   */
  mask?: FieldMaskMask;
}

/**
 * Field masking function name + args. The args is a JSON object.
 * @export
 * @interface FieldMaskMask
 */
export interface FieldMaskMask {
  /**
   *
   * @type {string}
   * @memberof FieldMaskMask
   */
  name: string;
  /**
   *
   * @type {any}
   * @memberof FieldMaskMask
   */
  args?: any;
}

/**
 *
 * @export
 * @interface FileUploadStatus
 */
export interface FileUploadStatus {
  /**
   * name of the file uploaded
   * @type {string}
   * @memberof FileUploadStatus
   */
  file_name?: string;
  /**
   * ISO-8601 date
   * @type {string}
   * @memberof FileUploadStatus
   */
  uploaded_at?: string;
  /**
   * id used to identify a file upload request
   * @type {string}
   * @memberof FileUploadStatus
   */
  file_upload_id?: string;
}

/**
 *
 * @export
 * @interface FormDataBodyPart
 */
export interface FormDataBodyPart {
  /**
   *
   * @type {ContentDisposition}
   * @memberof FormDataBodyPart
   */
  contentDisposition?: ContentDisposition;
  /**
   *
   * @type {any}
   * @memberof FormDataBodyPart
   */
  entity?: any;
  /**
   *
   * @type {{ [key: string]: Array<string>; }}
   * @memberof FormDataBodyPart
   */
  headers?: { [key: string]: Array<string> };
  /**
   *
   * @type {MediaType}
   * @memberof FormDataBodyPart
   */
  mediaType?: MediaType;
  /**
   *
   * @type {MessageBodyWorkers}
   * @memberof FormDataBodyPart
   */
  messageBodyWorkers?: MessageBodyWorkers;
  /**
   *
   * @type {MultiPart}
   * @memberof FormDataBodyPart
   */
  parent?: MultiPart;
  /**
   *
   * @type {Providers}
   * @memberof FormDataBodyPart
   */
  providers?: Providers;
  /**
   *
   * @type {boolean}
   * @memberof FormDataBodyPart
   */
  simple?: boolean;
  /**
   *
   * @type {FormDataContentDisposition}
   * @memberof FormDataBodyPart
   */
  formDataContentDisposition?: FormDataContentDisposition;
  /**
   *
   * @type {string}
   * @memberof FormDataBodyPart
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof FormDataBodyPart
   */
  value?: string;
  /**
   *
   * @type {{ [key: string]: Array<ParameterizedHeader>; }}
   * @memberof FormDataBodyPart
   */
  parameterizedHeaders?: { [key: string]: Array<ParameterizedHeader> };
}

/**
 *
 * @export
 * @interface FormDataContentDisposition
 */
export interface FormDataContentDisposition {
  /**
   *
   * @type {string}
   * @memberof FormDataContentDisposition
   */
  type?: string;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof FormDataContentDisposition
   */
  parameters?: { [key: string]: string };
  /**
   *
   * @type {string}
   * @memberof FormDataContentDisposition
   */
  fileName?: string;
  /**
   *
   * @type {Date}
   * @memberof FormDataContentDisposition
   */
  creationDate?: Date;
  /**
   *
   * @type {Date}
   * @memberof FormDataContentDisposition
   */
  modificationDate?: Date;
  /**
   *
   * @type {Date}
   * @memberof FormDataContentDisposition
   */
  readDate?: Date;
  /**
   *
   * @type {number}
   * @memberof FormDataContentDisposition
   */
  size?: number;
  /**
   *
   * @type {string}
   * @memberof FormDataContentDisposition
   */
  name?: string;
}

/**
 *
 * @export
 * @interface FormatParams
 */
export interface FormatParams {
  /**
   * source data is in json format
   * @type {boolean}
   * @memberof FormatParams
   */
  json?: boolean;
  /**
   *
   * @type {CsvParams}
   * @memberof FormatParams
   */
  csv?: CsvParams;
  /**
   *
   * @type {XmlParams}
   * @memberof FormatParams
   */
  xml?: XmlParams;
}

/**
 *
 * @export
 * @interface GcpServiceAccount
 */
export interface GcpServiceAccount {
  /**
   * Contents of JSON Service Account key file
   * @type {string}
   * @memberof GcpServiceAccount
   */
  service_account_key_file_json: string;
}

/**
 *
 * @export
 * @interface GcsIntegration
 */
export interface GcsIntegration {
  /**
   * credentials for an AWS key integration
   * @type {GcpServiceAccount}
   * @memberof GcsIntegration
   */
  gcp_service_account?: GcpServiceAccount;
}

/**
 *
 * @export
 * @interface GetActivityResponse
 */
export interface GetActivityResponse {
  /**
   * list of activity details
   * @type {Array<any>}
   * @memberof GetActivityResponse
   */
  activities?: Array<any>;
}

/**
 *
 * @export
 * @interface GetAliasResponse
 */
export interface GetAliasResponse {
  /**
   * alias that was requested
   * @type {Alias}
   * @memberof GetAliasResponse
   */
  data?: Alias;
}

/**
 *
 * @export
 * @interface GetCollectionResponse
 */
export interface GetCollectionResponse {
  /**
   * collection that was requested
   * @type {Collection}
   * @memberof GetCollectionResponse
   */
  data?: Collection;
}

/**
 *
 * @export
 * @interface GetIntegrationResponse
 */
export interface GetIntegrationResponse {
  /**
   * integration object
   * @type {Integration}
   * @memberof GetIntegrationResponse
   */
  data?: Integration;
}

/**
 *
 * @export
 * @interface GetUserTosResponse
 */
export interface GetUserTosResponse {
  /**
   * date user has accepted ToS
   * @type {string}
   * @memberof GetUserTosResponse
   */
  data?: string;
}

/**
 *
 * @export
 * @interface GetVirtualInstanceMetricsResponse
 */
export interface GetVirtualInstanceMetricsResponse {
  /**
   * virtual instance
   * @type {VirtualInstance}
   * @memberof GetVirtualInstanceMetricsResponse
   */
  virtual_instance?: VirtualInstance;
  /**
   * virtual instance metrics per time
   * @type {Array<VirtualInstanceMetrics>}
   * @memberof GetVirtualInstanceMetricsResponse
   */
  metrics?: Array<VirtualInstanceMetrics>;
}

/**
 *
 * @export
 * @interface GetVirtualInstanceResponse
 */
export interface GetVirtualInstanceResponse {
  /**
   * virtual instance that was requested
   * @type {VirtualInstance}
   * @memberof GetVirtualInstanceResponse
   */
  data?: VirtualInstance;
}

/**
 *
 * @export
 * @interface GetWorkspaceResponse
 */
export interface GetWorkspaceResponse {
  /**
   * the workspace that was requested
   * @type {Workspace}
   * @memberof GetWorkspaceResponse
   */
  data?: Workspace;
}

/**
 *
 * @export
 * @interface IngestUsage
 */
export interface IngestUsage {
  /**
   *
   * @type {Array<IngestUsagePrice>}
   * @memberof IngestUsage
   */
  states: Array<IngestUsagePrice>;
  /**
   *
   * @type {number}
   * @memberof IngestUsage
   */
  total_cost: number;
}

/**
 *
 * @export
 * @interface IngestUsagePrice
 */
export interface IngestUsagePrice {
  /**
   *
   * @type {number}
   * @memberof IngestUsagePrice
   */
  price?: number;
  /**
   *
   * @type {number}
   * @memberof IngestUsagePrice
   */
  total_bytes_ingested?: number;
  /**
   *
   * @type {number}
   * @memberof IngestUsagePrice
   */
  total_cost?: number;
}

/**
 *
 * @export
 * @interface InputField
 */
export interface InputField {
  /**
   * The name of a field, parsed as a SQL qualified name
   * @type {string}
   * @memberof InputField
   */
  field_name?: string;
  /**
   * Define the behaviour if fieldName is missing or is null
   * @type {string}
   * @memberof InputField
   */
  if_missing?: InputField.IfMissingEnum;
  /**
   * If true, then drop fieldName from the document
   * @type {boolean}
   * @memberof InputField
   */
  is_drop?: boolean;
  /**
   * Sql parameter name
   * @type {string}
   * @memberof InputField
   */
  param?: string;
}

/**
 * @export
 * @namespace InputField
 */
export namespace InputField {
  /**
   * @export
   * @enum {string}
   */
  export enum IfMissingEnum {
    SKIP = <any>'SKIP',
    PASS = <any>'PASS',
  }
}

/**
 *
 * @export
 * @interface InputStream
 */
export interface InputStream {}

/**
 * Instance
 * @export
 * @interface Instance
 */
export interface Instance {
  /**
   * id
   * @type {string}
   * @memberof Instance
   */
  id?: string;
  /**
   * instance type
   * @type {string}
   * @memberof Instance
   */
  instance_type?: Instance.InstanceTypeEnum;
  /**
   * hourly compute
   * @type {number}
   * @memberof Instance
   */
  hourly_compute?: number;
  /**
   * compute usage
   * @type {ComputeUsage}
   * @memberof Instance
   */
  compute_usage?: ComputeUsage;
  /**
   * leaf group
   * @type {LeafGroup}
   * @memberof Instance
   */
  leaf_group?: LeafGroup;
}

/**
 * @export
 * @namespace Instance
 */
export namespace Instance {
  /**
   * @export
   * @enum {string}
   */
  export enum InstanceTypeEnum {
    FREE = <any>'FREE',
    SHARED = <any>'SHARED',
    SMALL = <any>'SMALL',
    MEDIUM = <any>'MEDIUM',
    LARGE = <any>'LARGE',
    XLARGE = <any>'XLARGE',
    XLARGE2 = <any>'XLARGE2',
    XLARGE4 = <any>'XLARGE4',
    XLARGE8 = <any>'XLARGE8',
    XLARGE16 = <any>'XLARGE16',
  }
}

/**
 * Integrations that can be associated with data sources to create collections. Only one type of integration may be specified.
 * @export
 * @interface Integration
 */
export interface Integration {
  /**
   * descriptive label and unique identifier
   * @type {string}
   * @memberof Integration
   */
  name: string;
  /**
   * longer explanation for the integration
   * @type {string}
   * @memberof Integration
   */
  description?: string;
  /**
   * list of collections that use the integration
   * @type {Array<Collection>}
   * @memberof Integration
   */
  collections?: Array<Collection>;
  /**
   * email of user who created the integration
   * @type {string}
   * @memberof Integration
   */
  created_by: string;
  /**
   * ISO-8601 date
   * @type {string}
   * @memberof Integration
   */
  created_at?: string;
  /**
   * Amazon S3 details, must have one of aws_access_key or aws_role
   * @type {S3Integration}
   * @memberof Integration
   */
  s3?: S3Integration;
  /**
   * Amazon Kinesis details, must have one of aws_access_key or aws_role
   * @type {KinesisIntegration}
   * @memberof Integration
   */
  kinesis?: KinesisIntegration;
  /**
   * Amazon DynamoDB details, must have one of aws_access_key or aws_role
   * @type {DynamodbIntegration}
   * @memberof Integration
   */
  dynamodb?: DynamodbIntegration;
  /**
   * Amazon Redshift details
   * @type {RedshiftIntegration}
   * @memberof Integration
   */
  redshift?: RedshiftIntegration;
  /**
   * GCS details
   * @type {GcsIntegration}
   * @memberof Integration
   */
  gcs?: GcsIntegration;
  /**
   * Segment details
   * @type {SegmentIntegration}
   * @memberof Integration
   */
  segment?: SegmentIntegration;
  /**
   * Kafka details
   * @type {KafkaIntegration}
   * @memberof Integration
   */
  kafka?: KafkaIntegration;
  /**
   * MongoDb details
   * @type {MongoDbIntegration}
   * @memberof Integration
   */
  mongodb?: MongoDbIntegration;
}

/**
 *
 * @export
 * @interface InviteState
 */
export interface InviteState {
  /**
   * state of user
   * @type {string}
   * @memberof InviteState
   */
  data?: InviteState.DataEnum;
}

/**
 * @export
 * @namespace InviteState
 */
export namespace InviteState {
  /**
   * @export
   * @enum {string}
   */
  export enum DataEnum {
    PENDING = <any>'PENDING',
    ACCEPTED = <any>'ACCEPTED',
    EXPIRED = <any>'EXPIRED',
    CANCELLED = <any>'CANCELLED',
  }
}

/**
 * An invoice created by Stripe.
 * @export
 * @interface Invoice
 */
export interface Invoice {
  /**
   * total amount billed
   * @type {number}
   * @memberof Invoice
   */
  amount_paid?: number;
  /**
   * total amount billed
   * @type {number}
   * @memberof Invoice
   */
  amount_due?: number;
  /**
   * time in microseconds charge occured
   * @type {number}
   * @memberof Invoice
   */
  date?: number;
  /**
   * pdf link for full invoice with line items
   * @type {string}
   * @memberof Invoice
   */
  pdf_link?: string;
}

/**
 *
 * @export
 * @interface KafkaIntegration
 */
export interface KafkaIntegration {
  /**
   * Kafka topics to tail
   * @type {Array<string>}
   * @memberof KafkaIntegration
   */
  kafka_topic_names: Array<string>;
  /**
   * The status of the Kafka source by topic
   * @type {{ [key: string]: StatusKafka; }}
   * @memberof KafkaIntegration
   */
  source_status_by_topic?: { [key: string]: StatusKafka };
  /**
   * The format of the Kafka topics being tailed
   * @type {string}
   * @memberof KafkaIntegration
   */
  kafka_data_format: KafkaIntegration.KafkaDataFormatEnum;
  /**
   * kafka connection string
   * @type {string}
   * @memberof KafkaIntegration
   */
  connection_string?: string;
}

/**
 * @export
 * @namespace KafkaIntegration
 */
export namespace KafkaIntegration {
  /**
   * @export
   * @enum {string}
   */
  export enum KafkaDataFormatEnum {
    JSON = <any>'JSON',
    AVRO = <any>'AVRO',
  }
}

/**
 *
 * @export
 * @interface KinesisIntegration
 */
export interface KinesisIntegration {
  /**
   * credentials for an AWS access key integration
   * @type {AwsAccessKey}
   * @memberof KinesisIntegration
   */
  aws_access_key?: AwsAccessKey;
  /**
   * details of an AWS cross-account role integration
   * @type {AwsRole}
   * @memberof KinesisIntegration
   */
  aws_role?: AwsRole;
}

/**
 * Leaf Group
 * @export
 * @interface LeafGroup
 */
export interface LeafGroup {
  /**
   * pod type
   * @type {string}
   * @memberof LeafGroup
   */
  pod_type?: LeafGroup.PodTypeEnum;
  /**
   * pod count
   * @type {number}
   * @memberof LeafGroup
   */
  pod_count?: number;
  /**
   * cpu count
   * @type {number}
   * @memberof LeafGroup
   */
  cpu_count?: number;
}

/**
 * @export
 * @namespace LeafGroup
 */
export namespace LeafGroup {
  /**
   * @export
   * @enum {string}
   */
  export enum PodTypeEnum {
    I32XLARGE4CPU = <any>'I3_2XLARGE_4CPU',
  }
}

/**
 *
 * @export
 * @interface ListAliasesResponse
 */
export interface ListAliasesResponse {
  /**
   * list of all aliases
   * @type {Array<Alias>}
   * @memberof ListAliasesResponse
   */
  data?: Array<Alias>;
}

/**
 *
 * @export
 * @interface ListApiKeysResponse
 */
export interface ListApiKeysResponse {
  /**
   * list of API key objects
   * @type {Array<ApiKey>}
   * @memberof ListApiKeysResponse
   */
  data?: Array<ApiKey>;
}

/**
 *
 * @export
 * @interface ListCollectionsResponse
 */
export interface ListCollectionsResponse {
  /**
   * list of all collections
   * @type {Array<Collection>}
   * @memberof ListCollectionsResponse
   */
  data?: Array<Collection>;
}

/**
 *
 * @export
 * @interface ListIntegrationsResponse
 */
export interface ListIntegrationsResponse {
  /**
   * list of integration objects
   * @type {Array<Integration>}
   * @memberof ListIntegrationsResponse
   */
  data?: Array<Integration>;
}

/**
 *
 * @export
 * @interface ListQueryLambdaTagsResponse
 */
export interface ListQueryLambdaTagsResponse {
  /**
   * list of all tags associated with a Query Lambda
   * @type {Array<QueryLambdaTag>}
   * @memberof ListQueryLambdaTagsResponse
   */
  data?: Array<QueryLambdaTag>;
}

/**
 *
 * @export
 * @interface ListQueryLambdaVersionsResponse
 */
export interface ListQueryLambdaVersionsResponse {
  /**
   * list of all versions for a particular Query Lambda
   * @type {Array<QueryLambdaVersion>}
   * @memberof ListQueryLambdaVersionsResponse
   */
  data?: Array<QueryLambdaVersion>;
}

/**
 *
 * @export
 * @interface ListQueryLambdasResponse
 */
export interface ListQueryLambdasResponse {
  /**
   * list of all Query Lambdas
   * @type {Array<QueryLambda>}
   * @memberof ListQueryLambdasResponse
   */
  data?: Array<QueryLambda>;
}

/**
 *
 * @export
 * @interface ListUsersResponse
 */
export interface ListUsersResponse {
  /**
   * list of users
   * @type {Array<User>}
   * @memberof ListUsersResponse
   */
  data?: Array<User>;
}

/**
 *
 * @export
 * @interface ListVirtualInstancesResponse
 */
export interface ListVirtualInstancesResponse {
  /**
   * list of all virtual instances
   * @type {Array<VirtualInstance>}
   * @memberof ListVirtualInstancesResponse
   */
  data?: Array<VirtualInstance>;
}

/**
 *
 * @export
 * @interface ListWorkspacesResponse
 */
export interface ListWorkspacesResponse {
  /**
   * list of workspaces
   * @type {Array<Workspace>}
   * @memberof ListWorkspacesResponse
   */
  data?: Array<Workspace>;
}

/**
 *
 * @export
 * @interface MediaType
 */
export interface MediaType {
  /**
   *
   * @type {string}
   * @memberof MediaType
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof MediaType
   */
  subtype?: string;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof MediaType
   */
  parameters?: { [key: string]: string };
  /**
   *
   * @type {boolean}
   * @memberof MediaType
   */
  wildcardType?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof MediaType
   */
  wildcardSubtype?: boolean;
}

/**
 *
 * @export
 * @interface MessageBodyWorkers
 */
export interface MessageBodyWorkers {}

/**
 *
 * @export
 * @interface MongoDbIntegration
 */
export interface MongoDbIntegration {
  /**
   * MongoDB connection URI string
   * @type {string}
   * @memberof MongoDbIntegration
   */
  connection_uri: string;
}

/**
 *
 * @export
 * @interface MultiPart
 */
export interface MultiPart {
  /**
   *
   * @type {ContentDisposition}
   * @memberof MultiPart
   */
  contentDisposition?: ContentDisposition;
  /**
   *
   * @type {any}
   * @memberof MultiPart
   */
  entity?: any;
  /**
   *
   * @type {{ [key: string]: Array<string>; }}
   * @memberof MultiPart
   */
  headers?: { [key: string]: Array<string> };
  /**
   *
   * @type {MediaType}
   * @memberof MultiPart
   */
  mediaType?: MediaType;
  /**
   *
   * @type {MessageBodyWorkers}
   * @memberof MultiPart
   */
  messageBodyWorkers?: MessageBodyWorkers;
  /**
   *
   * @type {MultiPart}
   * @memberof MultiPart
   */
  parent?: MultiPart;
  /**
   *
   * @type {Providers}
   * @memberof MultiPart
   */
  providers?: Providers;
  /**
   *
   * @type {Array<BodyPart>}
   * @memberof MultiPart
   */
  bodyParts?: Array<BodyPart>;
  /**
   *
   * @type {{ [key: string]: Array<ParameterizedHeader>; }}
   * @memberof MultiPart
   */
  parameterizedHeaders?: { [key: string]: Array<ParameterizedHeader> };
}

/**
 *
 * @export
 * @interface OperatorStats
 */
export interface OperatorStats {
  /**
   * The id of the worker this operator ran on
   * @type {string}
   * @memberof OperatorStats
   */
  worker?: string;
  /**
   * The id of the fragment this operator belonged to
   * @type {number}
   * @memberof OperatorStats
   */
  fragment?: number;
  /**
   * The id of the task this operator belonged to
   * @type {string}
   * @memberof OperatorStats
   */
  task?: string;
  /**
   * The id of this operator in the task
   * @type {number}
   * @memberof OperatorStats
   */
  operator_id?: number;
  /**
   * The class name of this operator
   * @type {string}
   * @memberof OperatorStats
   */
  operator_name?: string;
  /**
   * Microseconds since UNIX epoch of the first time data was received from any of this operator's inputs
   * @type {number}
   * @memberof OperatorStats
   */
  start_time_us?: number;
  /**
   * Microseconds since UNIX epoch of the last time data was sent to any of this operator's outputs
   * @type {number}
   * @memberof OperatorStats
   */
  end_time_us?: number;
  /**
   * Maximum memory used by this operator during execution
   * @type {number}
   * @memberof OperatorStats
   */
  max_memory?: number;
  /**
   * Total bytes received across all inputs
   * @type {number}
   * @memberof OperatorStats
   */
  input_bytes?: number;
  /**
   * Total rows received across all inputs
   * @type {number}
   * @memberof OperatorStats
   */
  input_rows?: number;
  /**
   * Total bytes sent across all outputs
   * @type {number}
   * @memberof OperatorStats
   */
  output_bytes?: number;
  /**
   * Total rows sent across all outputs
   * @type {number}
   * @memberof OperatorStats
   */
  output_rows?: number;
  /**
   * Total time in microseconds spent doing useful work
   * @type {number}
   * @memberof OperatorStats
   */
  processing_time_us?: number;
}

/**
 *
 * @export
 * @interface OrgCompute
 */
export interface OrgCompute {
  /**
   *
   * @type {{ [key: string]: ComputeUsage; }}
   * @memberof OrgCompute
   */
  series: { [key: string]: ComputeUsage };
  /**
   *
   * @type {number}
   * @memberof OrgCompute
   */
  cost: number;
  /**
   *
   * @type {{ [key: string]: ComputeUsage; }}
   * @memberof OrgCompute
   */
  types: { [key: string]: ComputeUsage };
  /**
   *
   * @type {number}
   * @memberof OrgCompute
   */
  compute_cost: number;
  /**
   *
   * @type {Array<Instance>}
   * @memberof OrgCompute
   */
  instances: Array<Instance>;
}

/**
 *
 * @export
 * @interface OrgComputeResponse
 */
export interface OrgComputeResponse {
  /**
   * OrgCompute object
   * @type {OrgCompute}
   * @memberof OrgComputeResponse
   */
  data?: OrgCompute;
}

/**
 *
 * @export
 * @interface OrgIngestResponse
 */
export interface OrgIngestResponse {
  /**
   * OrgIngest object
   * @type {IngestUsage}
   * @memberof OrgIngestResponse
   */
  data?: IngestUsage;
}

/**
 * Invoice history for an organization.
 * @export
 * @interface OrgInvoices
 */
export interface OrgInvoices {
  /**
   * list of historical invoices
   * @type {Array<Invoice>}
   * @memberof OrgInvoices
   */
  invoices?: Array<Invoice>;
}

/**
 *
 * @export
 * @interface OrgInvoicesResponse
 */
export interface OrgInvoicesResponse {
  /**
   * OrgInvoices object
   * @type {OrgInvoices}
   * @memberof OrgInvoicesResponse
   */
  data?: OrgInvoices;
}

/**
 *
 * @export
 * @interface OrgMembership
 */
export interface OrgMembership {
  /**
   *
   * @type {Organization}
   * @memberof OrgMembership
   */
  organization: Organization;
  /**
   *
   * @type {Array<string>}
   * @memberof OrgMembership
   */
  roles: Array<string>;
  /**
   *
   * @type {string}
   * @memberof OrgMembership
   */
  invite_state: OrgMembership.InviteStateEnum;
  /**
   *
   * @type {string}
   * @memberof OrgMembership
   */
  invited_by: string;
  /**
   * email of the user
   * @type {string}
   * @memberof OrgMembership
   */
  email?: string;
  /**
   * ISO-8601 date
   * @type {string}
   * @memberof OrgMembership
   */
  expires_at: string;
  /**
   * ISO-8601 date
   * @type {string}
   * @memberof OrgMembership
   */
  created_at: string;
}

/**
 * @export
 * @namespace OrgMembership
 */
export namespace OrgMembership {
  /**
   * @export
   * @enum {string}
   */
  export enum InviteStateEnum {
    PENDING = <any>'PENDING',
    ACCEPTED = <any>'ACCEPTED',
    EXPIRED = <any>'EXPIRED',
    CANCELLED = <any>'CANCELLED',
  }
}

/**
 * Information related to payment for an organization.
 * @export
 * @interface OrgPaymentMethod
 */
export interface OrgPaymentMethod {
  /**
   * stripe source ID associated with credit card
   * @type {string}
   * @memberof OrgPaymentMethod
   */
  card_source_id?: string;
  /**
   * brand of credit card
   * @type {string}
   * @memberof OrgPaymentMethod
   */
  card_brand?: string;
  /**
   * origin country of credit card
   * @type {string}
   * @memberof OrgPaymentMethod
   */
  card_country?: string;
  /**
   * credit card expiration month
   * @type {string}
   * @memberof OrgPaymentMethod
   */
  card_exp_month?: string;
  /**
   * credit card expiration year
   * @type {string}
   * @memberof OrgPaymentMethod
   */
  card_exp_year?: string;
  /**
   * debit or credit
   * @type {string}
   * @memberof OrgPaymentMethod
   */
  card_funding?: string;
  /**
   * last 4 digits of credit card
   * @type {string}
   * @memberof OrgPaymentMethod
   */
  card_last4?: string;
  /**
   * status of credit card
   * @type {string}
   * @memberof OrgPaymentMethod
   */
  card_status?: string;
  /**
   * stripe customer id. not a secret.
   * @type {string}
   * @memberof OrgPaymentMethod
   */
  customer_id?: string;
}

/**
 *
 * @export
 * @interface OrgPaymentMethodResponse
 */
export interface OrgPaymentMethodResponse {
  /**
   * OrgPaymentMethod object
   * @type {OrgPaymentMethod}
   * @memberof OrgPaymentMethodResponse
   */
  data?: OrgPaymentMethod;
}

/**
 *
 * @export
 * @interface OrgRecentActivity
 */
export interface OrgRecentActivity {
  /**
   * unix millis of the most recent activity for the org
   * @type {number}
   * @memberof OrgRecentActivity
   */
  last_activity_millis?: number;
  /**
   * type of activity which was most recently performed
   * @type {string}
   * @memberof OrgRecentActivity
   */
  activity_type?: string;
  /**
   * unix millis of the time the org is scheduled to be deleted
   * @type {number}
   * @memberof OrgRecentActivity
   */
  scheduled_deletion_time_millis?: number;
}

/**
 *
 * @export
 * @interface OrgRecentActivityResponse
 */
export interface OrgRecentActivityResponse {
  /**
   * OrgRecentActivity object
   * @type {OrgRecentActivity}
   * @memberof OrgRecentActivityResponse
   */
  data?: OrgRecentActivity;
}

/**
 * Settings for an organization.
 * @export
 * @interface OrgSettings
 */
export interface OrgSettings {
  /**
   * Max number of aggregators per query
   * @type {number}
   * @memberof OrgSettings
   */
  aggregator_parallelism?: number;
  /**
   * collection limit per organization
   * @type {number}
   * @memberof OrgSettings
   */
  collection_limit?: number;
  /**
   * alias limit per organization
   * @type {number}
   * @memberof OrgSettings
   */
  alias_limit?: number;
  /**
   * Query Lambda limit per organization
   * @type {number}
   * @memberof OrgSettings
   */
  query_lambda_count_limit?: number;
  /**
   * version limit per Query Lambda
   * @type {number}
   * @memberof OrgSettings
   */
  query_lambda_version_count_limit?: number;
  /**
   * Unique tag limit per organization
   * @type {number}
   * @memberof OrgSettings
   */
  unique_tag_count_limit?: number;
  /**
   * concurrent queries limit per organization
   * @type {number}
   * @memberof OrgSettings
   */
  concurrent_queries_limit?: number;
  /**
   * identifier for encryption key for org
   * @type {string}
   * @memberof OrgSettings
   */
  encryption_key?: string;
  /**
   * number of file uploads allowed per collection
   * @type {number}
   * @memberof OrgSettings
   */
  file_upload_limit_per_collection?: number;
  /**
   * input rate limit in megabytes per second
   * @type {number}
   * @memberof OrgSettings
   */
  input_rate_limit_kbps?: number;
  /**
   * number of partitions in the log store for each collection
   * @type {number}
   * @memberof OrgSettings
   */
  log_partitions_per_collection?: number;
  /**
   * custom unit price for ingest
   * @type {number}
   * @memberof OrgSettings
   */
  custom_ingest_price?: number;
  /**
   * custom trial credit amount
   * @type {number}
   * @memberof OrgSettings
   */
  custom_trial_credit?: number;
  /**
   * hourly compute price
   * @type {number}
   * @memberof OrgSettings
   */
  hourly_compute_price?: number;
  /**
   * the minimum monthly bill for an organization
   * @type {number}
   * @memberof OrgSettings
   */
  min_monthly_bill?: number;
  /**
   * Pending invites limit per organization
   * @type {number}
   * @memberof OrgSettings
   */
  pending_invites_limit?: number;
  /**
   * Total users limit per organization
   * @type {number}
   * @memberof OrgSettings
   */
  total_users_limit?: number;
  /**
   * Max amount of memory allocated per query per worker node
   * @type {number}
   * @memberof OrgSettings
   */
  query_memory_limit_bytes?: number;
  /**
   * whether role-based access control is enabled
   * @type {number}
   * @memberof OrgSettings
   */
  replication_factor?: number;
  /**
   * min number of shards in Rockset for each collection
   * @type {number}
   * @memberof OrgSettings
   */
  min_shards_per_collection?: number;
  /**
   * max number of shards in Rockset for each collection
   * @type {number}
   * @memberof OrgSettings
   */
  max_shards_per_collection?: number;
  /**
   * storage size limit in bytes
   * @type {number}
   * @memberof OrgSettings
   */
  size_limit_bytes?: number;
  /**
   * whether Single Sign On is enabled
   * @type {boolean}
   * @memberof OrgSettings
   */
  sso_enabled?: boolean;
  /**
   * state of the org
   * @type {string}
   * @memberof OrgSettings
   */
  state?: OrgSettings.StateEnum;
  /**
   * data when trial ends
   * @type {number}
   * @memberof OrgSettings
   */
  trial_end?: number;
  /**
   * date when trial began
   * @type {number}
   * @memberof OrgSettings
   */
  trial_start?: number;
  /**
   * list of console feature flags that are on
   * @type {Array<string>}
   * @memberof OrgSettings
   */
  console_flags?: Array<string>;
  /**
   * whether users from specified domains can be auto-provisioned with accounts
   * @type {boolean}
   * @memberof OrgSettings
   */
  auto_provision?: boolean;
  /**
   * default role for autoprovisioned users
   * @type {string}
   * @memberof OrgSettings
   */
  auto_provision_role?: string;
  /**
   * domain for which accounts can be autoprovisioned
   * @type {string}
   * @memberof OrgSettings
   */
  auto_provision_domain?: string;
  /**
   * connection name of SSO connection
   * @type {string}
   * @memberof OrgSettings
   */
  sso_connection?: string;
  /**
   * whether or not SSO is the only permitted form of auth
   * @type {boolean}
   * @memberof OrgSettings
   */
  sso_only?: boolean;
  /**
   * whether or not instance-based pricing is enabled for this org
   * @type {boolean}
   * @memberof OrgSettings
   */
  instance_pricing?: boolean;
}

/**
 * @export
 * @namespace OrgSettings
 */
export namespace OrgSettings {
  /**
   * @export
   * @enum {string}
   */
  export enum StateEnum {
    FREE = <any>'FREE',
    PAID = <any>'PAID',
    TRIAL = <any>'TRIAL',
    TRIALEXPIRED = <any>'TRIAL_EXPIRED',
    TRIALDEPLETED = <any>'TRIAL_DEPLETED',
    INACTIVE = <any>'INACTIVE',
    DELETED = <any>'DELETED',
  }
}

/**
 *
 * @export
 * @interface OrgSettingsResponse
 */
export interface OrgSettingsResponse {
  /**
   * OrgSettings object
   * @type {OrgSettings}
   * @memberof OrgSettingsResponse
   */
  data?: OrgSettings;
}

/**
 *
 * @export
 * @interface OrgStorage
 */
export interface OrgStorage {
  /**
   *
   * @type {{ [key: string]: Usage; }}
   * @memberof OrgStorage
   */
  series: { [key: string]: Usage };
  /**
   *
   * @type {number}
   * @memberof OrgStorage
   */
  cost: number;
  /**
   *
   * @type {{ [key: string]: Usage; }}
   * @memberof OrgStorage
   */
  prices: { [key: string]: Usage };
}

/**
 *
 * @export
 * @interface OrgStorageResponse
 */
export interface OrgStorageResponse {
  /**
   * OrgUsage object
   * @type {OrgStorage}
   * @memberof OrgStorageResponse
   */
  data?: OrgStorage;
}

/**
 *
 * @export
 * @interface OrgTrialUsage
 */
export interface OrgTrialUsage {
  /**
   *
   * @type {number}
   * @memberof OrgTrialUsage
   */
  trial_credit_used: number;
  /**
   *
   * @type {number}
   * @memberof OrgTrialUsage
   */
  trial_credit_remaining: number;
  /**
   *
   * @type {number}
   * @memberof OrgTrialUsage
   */
  trial_start: number;
  /**
   *
   * @type {number}
   * @memberof OrgTrialUsage
   */
  trial_end: number;
  /**
   *
   * @type {number}
   * @memberof OrgTrialUsage
   */
  month_credit_used: number;
}

/**
 *
 * @export
 * @interface OrgTrialUsageResponse
 */
export interface OrgTrialUsageResponse {
  /**
   * OrgTrialUsage object
   * @type {OrgTrialUsage}
   * @memberof OrgTrialUsageResponse
   */
  data?: OrgTrialUsage;
}

/**
 * Usage statistics for an organization.
 * @export
 * @interface OrgUsage
 */
export interface OrgUsage {
  /**
   * number of active documents
   * @type {number}
   * @memberof OrgUsage
   */
  active_document_count?: number;
  /**
   * number of collections
   * @type {number}
   * @memberof OrgUsage
   */
  collection_count?: number;
  /**
   * number of users
   * @type {number}
   * @memberof OrgUsage
   */
  user_count?: number;
  /**
   * number of integrations
   * @type {number}
   * @memberof OrgUsage
   */
  integration_count?: number;
  /**
   * timestamp of last update
   * @type {string}
   * @memberof OrgUsage
   */
  last_updated_ms?: string;
  /**
   * timestamp of last query
   * @type {string}
   * @memberof OrgUsage
   */
  last_queried_ms?: string;
  /**
   * total size in bytes of all collections
   * @type {number}
   * @memberof OrgUsage
   */
  total_size_bytes?: number;
  /**
   *
   * @type {number}
   * @memberof OrgUsage
   */
  total_index_size?: number;
  /**
   * total queries performed in org
   * @type {number}
   * @memberof OrgUsage
   */
  total_queries?: number;
}

/**
 *
 * @export
 * @interface OrgUsageResponse
 */
export interface OrgUsageResponse {
  /**
   * OrgUsage object
   * @type {OrgUsage}
   * @memberof OrgUsageResponse
   */
  data?: OrgUsage;
}

/**
 * An organization in Rockset is a container for users and collections.
 * @export
 * @interface Organization
 */
export interface Organization {
  /**
   * unique identifier for the organization
   * @type {string}
   * @memberof Organization
   */
  id?: string;
  /**
   * ISO-8601 date
   * @type {string}
   * @memberof Organization
   */
  created_at?: string;
  /**
   * name of the organization
   * @type {string}
   * @memberof Organization
   */
  display_name?: string;
  /**
   * name of the company
   * @type {string}
   * @memberof Organization
   */
  company_name?: string;
  /**
   * organization's unique external ID within Rockset
   * @type {string}
   * @memberof Organization
   */
  external_id?: string;
  /**
   * Rockset's global AWS user
   * @type {string}
   * @memberof Organization
   */
  rockset_user?: string;
  /**
   * org state
   * @type {string}
   * @memberof Organization
   */
  state?: Organization.StateEnum;
  /**
   * list of clusters associated with this org
   * @type {Array<Cluster>}
   * @memberof Organization
   */
  clusters?: Array<Cluster>;
}

/**
 * @export
 * @namespace Organization
 */
export namespace Organization {
  /**
   * @export
   * @enum {string}
   */
  export enum StateEnum {
    FREE = <any>'FREE',
    PAID = <any>'PAID',
    TRIAL = <any>'TRIAL',
    TRIALEXPIRED = <any>'TRIAL_EXPIRED',
    TRIALDEPLETED = <any>'TRIAL_DEPLETED',
    INACTIVE = <any>'INACTIVE',
    DELETED = <any>'DELETED',
  }
}

/**
 *
 * @export
 * @interface OrganizationResponse
 */
export interface OrganizationResponse {
  /**
   * Organization object
   * @type {Organization}
   * @memberof OrganizationResponse
   */
  data?: Organization;
}

/**
 *
 * @export
 * @interface OutputField
 */
export interface OutputField {
  /**
   * The name of a field, parsed as a SQL qualified name
   * @type {string}
   * @memberof OutputField
   */
  field_name?: string;
  /**
   * The name of a sql function
   * @type {SqlExpression}
   * @memberof OutputField
   */
  value?: SqlExpression;
  /**
   * Error in Mapping execution: 'skip' or 'fail'
   * @type {string}
   * @memberof OutputField
   */
  on_error?: OutputField.OnErrorEnum;
}

/**
 * @export
 * @namespace OutputField
 */
export namespace OutputField {
  /**
   * @export
   * @enum {string}
   */
  export enum OnErrorEnum {
    SKIP = <any>'SKIP',
    FAIL = <any>'FAIL',
  }
}

/**
 *
 * @export
 * @interface ParameterizedHeader
 */
export interface ParameterizedHeader {
  /**
   *
   * @type {string}
   * @memberof ParameterizedHeader
   */
  value?: string;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof ParameterizedHeader
   */
  parameters?: { [key: string]: string };
}

/**
 *
 * @export
 * @interface PatchDocument
 */
export interface PatchDocument {
  /**
   * Unique id of the document which is being patched
   * @type {string}
   * @memberof PatchDocument
   */
  _id: string;
  /**
   * List of patch operations
   * @type {Array<PatchOperation>}
   * @memberof PatchDocument
   */
  patch: Array<PatchOperation>;
}

/**
 *
 * @export
 * @interface PatchDocumentsRequest
 */
export interface PatchDocumentsRequest {
  /**
   * List of JSON Patch Documents
   * @type {Array<PatchDocument>}
   * @memberof PatchDocumentsRequest
   */
  data: Array<PatchDocument>;
}

/**
 *
 * @export
 * @interface PatchDocumentsResponse
 */
export interface PatchDocumentsResponse {
  /**
   *
   * @type {Array<DocumentStatus>}
   * @memberof PatchDocumentsResponse
   */
  data: Array<DocumentStatus>;
}

/**
 *
 * @export
 * @interface PatchOperation
 */
export interface PatchOperation {
  /**
   * Operation to be performed in this patch
   * @type {string}
   * @memberof PatchOperation
   */
  op: PatchOperation.OpEnum;
  /**
   * JSON-Pointer referencing a location in the target document where theoperation is performed
   * @type {string}
   * @memberof PatchOperation
   */
  path: string;
  /**
   * Value used in the patch operation. Required for add, replace, test, and increment operations
   * @type {any}
   * @memberof PatchOperation
   */
  value?: any;
  /**
   * JSON-Pointer referencing a location in the target document.Required for copy and move operations
   * @type {string}
   * @memberof PatchOperation
   */
  from?: string;
}

/**
 * @export
 * @namespace PatchOperation
 */
export namespace PatchOperation {
  /**
   * @export
   * @enum {string}
   */
  export enum OpEnum {
    ADD = <any>'ADD',
    REPLACE = <any>'REPLACE',
    REMOVE = <any>'REMOVE',
    COPY = <any>'COPY',
    MOVE = <any>'MOVE',
    TEST = <any>'TEST',
    INCREMENT = <any>'INCREMENT',
  }
}

/**
 *
 * @export
 * @interface PreviewCollectionRequest
 */
export interface PreviewCollectionRequest {
  /**
   * list of sources from which to ingest data
   * @type {Array<Source>}
   * @memberof PreviewCollectionRequest
   */
  sources?: Array<Source>;
  /**
   * configuration for event data
   * @type {EventTimeInfo}
   * @memberof PreviewCollectionRequest
   */
  event_time_info?: EventTimeInfo;
  /**
   * list of mappings
   * @type {Array<FieldMappingV2>}
   * @memberof PreviewCollectionRequest
   */
  field_mappings?: Array<FieldMappingV2>;
}

/**
 *
 * @export
 * @interface PreviewCollectionResponse
 */
export interface PreviewCollectionResponse {
  /**
   * sample documents
   * @type {Array<Array<any>>}
   * @memberof PreviewCollectionResponse
   */
  sample_documents?: Array<Array<any>>;
  /**
   * mapped_fields
   * @type {Array<string>}
   * @memberof PreviewCollectionResponse
   */
  mapped_fields?: Array<string>;
}

/**
 *
 * @export
 * @interface PreviewSource
 */
export interface PreviewSource {
  /**
   * UUID unique to the source
   * @type {string}
   * @memberof PreviewSource
   */
  preview_source_id?: string;
  /**
   * integration used for this source
   * @type {string}
   * @memberof PreviewSource
   */
  integration_name?: string;
  /**
   * whether type is file upload
   * @type {boolean}
   * @memberof PreviewSource
   */
  file_upload?: boolean;
  /**
   * configuration for receiving data from kafka
   * @type {SourceKafka}
   * @memberof PreviewSource
   */
  kafka?: SourceKafka;
  /**
   * time at which this preview source expires (ISO-8601 format)
   * @type {string}
   * @memberof PreviewSource
   */
  expire_at?: string;
}

/**
 *
 * @export
 * @interface Providers
 */
export interface Providers {}

/**
 *
 * @export
 * @interface QueryError
 */
export interface QueryError {
  /**
   * The type of error
   * @type {string}
   * @memberof QueryError
   */
  type?: string;
  /**
   * A message associated with the error, containing more information about it
   * @type {string}
   * @memberof QueryError
   */
  message?: string;
  /**
   * The HTTP status code associated with this error, had it been sent as the response status code
   * @type {number}
   * @memberof QueryError
   */
  status_code?: number;
}

/**
 *
 * @export
 * @interface QueryFieldType
 */
export interface QueryFieldType {
  /**
   * name of the field
   * @type {string}
   * @memberof QueryFieldType
   */
  name: string;
  /**
   * data type of the field
   * @type {string}
   * @memberof QueryFieldType
   */
  type: string;
}

/**
 *
 * @export
 * @interface QueryLambda
 */
export interface QueryLambda {
  /**
   * workspace of this Query Lambda
   * @type {string}
   * @memberof QueryLambda
   */
  workspace?: string;
  /**
   * user that created this Query Lambda
   * @type {string}
   * @memberof QueryLambda
   */
  last_updated_by?: string;
  /**
   * ISO-8601 date of when Query Lambda was last updated
   * @type {string}
   * @memberof QueryLambda
   */
  last_updated?: string;
  /**
   * Query Lambda name
   * @type {string}
   * @memberof QueryLambda
   */
  name?: string;
  /**
   * number of Query Lambda versions
   * @type {number}
   * @memberof QueryLambda
   */
  version_count?: number;
  /**
   * collections/aliases queried by underlying SQL query
   * @type {Array<string>}
   * @memberof QueryLambda
   */
  collections?: Array<string>;
  /**
   * Query Lambda version details for most recently created version
   * @type {QueryLambdaVersion}
   * @memberof QueryLambda
   */
  latest_version?: QueryLambdaVersion;
}

/**
 *
 * @export
 * @interface QueryLambdaSql
 */
export interface QueryLambdaSql {
  /**
   * SQL text
   * @type {string}
   * @memberof QueryLambdaSql
   */
  query: string;
  /**
   * default parameters for this Query Lambda
   * @type {Array<QueryParameter>}
   * @memberof QueryLambdaSql
   */
  default_parameters?: Array<QueryParameter>;
}

/**
 *
 * @export
 * @interface QueryLambdaStats
 */
export interface QueryLambdaStats {
  /**
   * ISO-8601 date
   * @type {string}
   * @memberof QueryLambdaStats
   */
  last_executed?: string;
  /**
   * user who last executed Query Lambda
   * @type {string}
   * @memberof QueryLambdaStats
   */
  last_executed_by?: string;
  /**
   * ISO-8601 date of last execution failure
   * @type {string}
   * @memberof QueryLambdaStats
   */
  last_execution_error?: string;
  /**
   * error message associated with last failed execution
   * @type {string}
   * @memberof QueryLambdaStats
   */
  last_execution_error_message?: string;
}

/**
 *
 * @export
 * @interface QueryLambdaTag
 */
export interface QueryLambdaTag {
  /**
   * name of Query Lambda tag
   * @type {string}
   * @memberof QueryLambdaTag
   */
  tag_name?: string;
  /**
   * query lambda version
   * @type {QueryLambdaVersion}
   * @memberof QueryLambdaTag
   */
  version?: QueryLambdaVersion;
}

/**
 *
 * @export
 * @interface QueryLambdaTagResponse
 */
export interface QueryLambdaTagResponse {
  /**
   * updated Query Lambda tag
   * @type {QueryLambdaTag}
   * @memberof QueryLambdaTagResponse
   */
  data?: QueryLambdaTag;
}

/**
 *
 * @export
 * @interface QueryLambdaVersion
 */
export interface QueryLambdaVersion {
  /**
   * workspace of this Query Lambda
   * @type {string}
   * @memberof QueryLambdaVersion
   */
  workspace?: string;
  /**
   * user that created this Query Lambda
   * @type {string}
   * @memberof QueryLambdaVersion
   */
  created_by?: string;
  /**
   * ISO-8601 date of when Query Lambda was created
   * @type {string}
   * @memberof QueryLambdaVersion
   */
  created_at?: string;
  /**
   * Query Lambda name
   * @type {string}
   * @memberof QueryLambdaVersion
   */
  name?: string;
  /**
   * Query Lambda version
   * @type {string}
   * @memberof QueryLambdaVersion
   */
  version?: string;
  /**
   * optional description
   * @type {string}
   * @memberof QueryLambdaVersion
   */
  description?: string;
  /**
   * Query Lambda SQL query
   * @type {QueryLambdaSql}
   * @memberof QueryLambdaVersion
   */
  sql?: QueryLambdaSql;
  /**
   * collections queried by underlying SQL query
   * @type {Array<string>}
   * @memberof QueryLambdaVersion
   */
  collections?: Array<string>;
  /**
   * status of this Query Lambda
   * @type {string}
   * @memberof QueryLambdaVersion
   */
  state?: QueryLambdaVersion.StateEnum;
  /**
   * stats related to this Query Lambda
   * @type {QueryLambdaStats}
   * @memberof QueryLambdaVersion
   */
  stats?: QueryLambdaStats;
}

/**
 * @export
 * @namespace QueryLambdaVersion
 */
export namespace QueryLambdaVersion {
  /**
   * @export
   * @enum {string}
   */
  export enum StateEnum {
    ACTIVE = <any>'ACTIVE',
    INVALIDSQL = <any>'INVALID_SQL',
  }
}

/**
 *
 * @export
 * @interface QueryLambdaVersionResponse
 */
export interface QueryLambdaVersionResponse {
  /**
   * Query Lambda version details
   * @type {QueryLambdaVersion}
   * @memberof QueryLambdaVersionResponse
   */
  data?: QueryLambdaVersion;
}

/**
 *
 * @export
 * @interface QueryParameter
 */
export interface QueryParameter {
  /**
   * name of the field
   * @type {string}
   * @memberof QueryParameter
   */
  name: string;
  /**
   * data type of the field
   * @type {string}
   * @memberof QueryParameter
   */
  type: string;
  /**
   * literal value of the field
   * @type {string}
   * @memberof QueryParameter
   */
  value: string;
}

/**
 *
 * @export
 * @interface QueryRequest
 */
export interface QueryRequest {
  /**
   * details about the query
   * @type {QueryRequestSql}
   * @memberof QueryRequest
   */
  sql?: QueryRequestSql;
}

/**
 *
 * @export
 * @interface QueryRequestSql
 */
export interface QueryRequestSql {
  /**
   * list of named parameters
   * @type {Array<QueryParameter>}
   * @memberof QueryRequestSql
   */
  parameters?: Array<QueryParameter>;
  /**
   * SQL query as a string
   * @type {string}
   * @memberof QueryRequestSql
   */
  query: string;
  /**
   * Row limit to use if no limit specified in the query
   * @type {number}
   * @memberof QueryRequestSql
   */
  default_row_limit?: number;
  /**
   * Whether to generate warnings
   * @type {boolean}
   * @memberof QueryRequestSql
   */
  generate_warnings?: boolean;
  /**
   * Whether to generate a performance profile for this query
   * @type {boolean}
   * @memberof QueryRequestSql
   */
  profiling_enabled?: boolean;
}

/**
 *
 * @export
 * @interface QueryResponse
 */
export interface QueryResponse {
  /**
   * list of aliases specified and referenced collections in query
   * @type {Array<QueryResponseAlias>}
   * @memberof QueryResponse
   */
  aliases?: Array<QueryResponseAlias>;
  /**
   * unique id for this query
   * @type {string}
   * @memberof QueryResponse
   */
  query_id?: string;
  /**
   * list of collections queried by the query
   * @type {Array<string>}
   * @memberof QueryResponse
   */
  collections?: Array<string>;
  /**
   * list of objects returned by the query
   * @type {Array<any>}
   * @memberof QueryResponse
   */
  results?: Array<any>;
  /**
   * meta information about the query
   * @type {QueryResponseStats}
   * @memberof QueryResponse
   */
  stats?: QueryResponseStats;
  /**
   * warnings received from the query
   * @type {Array<string>}
   * @memberof QueryResponse
   */
  warnings?: Array<string>;
  /**
   * errors encountered while streaming the query
   * @type {Array<QueryError>}
   * @memberof QueryResponse
   */
  query_errors?: Array<QueryError>;
  /**
   * meta information about each column in the result set
   * @type {Array<QueryFieldType>}
   * @memberof QueryResponse
   */
  column_fields?: Array<QueryFieldType>;
}

/**
 *
 * @export
 * @interface QueryResponseAlias
 */
export interface QueryResponseAlias {
  /**
   * name of the alias
   * @type {string}
   * @memberof QueryResponseAlias
   */
  name: string;
  /**
   * list of fully qualified collection names referenced by the alias
   * @type {Array<string>}
   * @memberof QueryResponseAlias
   */
  collections: Array<string>;
}

/**
 *
 * @export
 * @interface QueryResponseStats
 */
export interface QueryResponseStats {
  /**
   * query time in milliseconds
   * @type {number}
   * @memberof QueryResponseStats
   */
  elapsed_time_ms?: number;
}

/**
 *
 * @export
 * @interface QueryStats
 */
export interface QueryStats {
  /**
   * query time in milliseconds
   * @type {number}
   * @memberof QueryStats
   */
  elapsed_time_ms?: number;
  /**
   * rows scanned as part of query execution
   * @type {number}
   * @memberof QueryStats
   */
  rows_scanned?: number;
  /**
   * number of rows returned from the query
   * @type {number}
   * @memberof QueryStats
   */
  rows_returned?: number;
  /**
   * Statistics for each operator from query execution
   * @type {Array<OperatorStats>}
   * @memberof QueryStats
   */
  operators?: Array<OperatorStats>;
  /**
   * Statistics for each exchange source from query execution
   * @type {Array<RpcSourceStats>}
   * @memberof QueryStats
   */
  exchange_sources?: Array<RpcSourceStats>;
  /**
   * Statistics for each exchange sink from query execution
   * @type {Array<RpcSinkStats>}
   * @memberof QueryStats
   */
  exchange_sinks?: Array<RpcSinkStats>;
  /**
   * DOT graph representing the execution steps of this query
   * @type {string}
   * @memberof QueryStats
   */
  execution_graph?: string;
  /**
   * Execution plan (output of EXPLAIN) of this query
   * @type {string}
   * @memberof QueryStats
   */
  execution_plan?: string;
  /**
   * SQL text of Query that was executed
   * @type {string}
   * @memberof QueryStats
   */
  query_text?: string;
}

/**
 *
 * @export
 * @interface QueryStatsResponse
 */
export interface QueryStatsResponse {
  /**
   *
   * @type {QueryStats}
   * @memberof QueryStatsResponse
   */
  data?: QueryStats;
}

/**
 *
 * @export
 * @interface RecordActivityRequest
 */
export interface RecordActivityRequest {
  /**
   * should this activity trigger a notification message
   * @type {boolean}
   * @memberof RecordActivityRequest
   */
  notify?: boolean;
  /**
   * message to be sent
   * @type {string}
   * @memberof RecordActivityRequest
   */
  message?: string;
  /**
   * details of the activity
   * @type {{ [key: string]: any; }}
   * @memberof RecordActivityRequest
   */
  details?: { [key: string]: any };
}

/**
 *
 * @export
 * @interface RedshiftIntegration
 */
export interface RedshiftIntegration {
  /**
   * AWS access key credentials
   * @type {AwsAccessKey}
   * @memberof RedshiftIntegration
   */
  aws_access_key?: AwsAccessKey;
  /**
   * Username associated with Redshift cluster
   * @type {string}
   * @memberof RedshiftIntegration
   */
  username: string;
  /**
   * Password associated with Redshift cluster
   * @type {string}
   * @memberof RedshiftIntegration
   */
  password: string;
  /**
   * Redshift Cluster host
   * @type {string}
   * @memberof RedshiftIntegration
   */
  host: string;
  /**
   * Redshift Cluster port
   * @type {number}
   * @memberof RedshiftIntegration
   */
  port: number;
  /**
   * unload S3 bucket path
   * @type {string}
   * @memberof RedshiftIntegration
   */
  s3_bucket_path: string;
}

/**
 *
 * @export
 * @interface RpcSinkStats
 */
export interface RpcSinkStats {
  /**
   * The id of the worker this operator ran on
   * @type {string}
   * @memberof RpcSinkStats
   */
  worker?: string;
  /**
   * The id of the fragment this operator belonged to
   * @type {number}
   * @memberof RpcSinkStats
   */
  fragment?: number;
  /**
   * The id of the task this operator belonged to
   * @type {string}
   * @memberof RpcSinkStats
   */
  task?: string;
  /**
   * The id of this operator in the task
   * @type {number}
   * @memberof RpcSinkStats
   */
  operator_id?: number;
  /**
   * The class name of upstream operator
   * @type {string}
   * @memberof RpcSinkStats
   */
  src_operator_name?: string;
  /**
   * Total bytes received from the input
   * @type {number}
   * @memberof RpcSinkStats
   */
  input_bytes?: number;
  /**
   * Maximum bytes received in one data chunk
   * @type {number}
   * @memberof RpcSinkStats
   */
  max_input_bytes?: number;
  /**
   * Total rows received from the input
   * @type {number}
   * @memberof RpcSinkStats
   */
  input_rows?: number;
  /**
   * Total data chunks received from the input
   * @type {number}
   * @memberof RpcSinkStats
   */
  input_data_chunks?: number;
  /**
   * Total data chunks sent to the output
   * @type {number}
   * @memberof RpcSinkStats
   */
  output_data_chunks?: number;
  /**
   * Total messages sent to the output
   * @type {number}
   * @memberof RpcSinkStats
   */
  output_messages?: number;
  /**
   * Total time in microseconds spent doing useful work
   * @type {number}
   * @memberof RpcSinkStats
   */
  processing_time_us?: number;
}

/**
 *
 * @export
 * @interface RpcSourceStats
 */
export interface RpcSourceStats {
  /**
   * The id of the worker this operator ran on
   * @type {string}
   * @memberof RpcSourceStats
   */
  worker?: string;
  /**
   * The id of the fragment this operator belonged to
   * @type {number}
   * @memberof RpcSourceStats
   */
  fragment?: number;
  /**
   * The id of the task this operator belonged to
   * @type {string}
   * @memberof RpcSourceStats
   */
  task?: string;
  /**
   * The id of this operator in the task
   * @type {number}
   * @memberof RpcSourceStats
   */
  operator_id?: number;
  /**
   * The class name of downstream operator
   * @type {string}
   * @memberof RpcSourceStats
   */
  dest_operator_name?: string;
  /**
   * Total bytes received from the input
   * @type {number}
   * @memberof RpcSourceStats
   */
  input_bytes?: number;
  /**
   * Maximum bytes received in one data chunk
   * @type {number}
   * @memberof RpcSourceStats
   */
  max_input_bytes?: number;
  /**
   * Total rows received from the input
   * @type {number}
   * @memberof RpcSourceStats
   */
  input_rows?: number;
  /**
   * Total data chunks received from the input
   * @type {number}
   * @memberof RpcSourceStats
   */
  input_data_chunks?: number;
  /**
   * Total messages received from the input
   * @type {number}
   * @memberof RpcSourceStats
   */
  input_messages?: number;
  /**
   * Total time in microseconds spent doing useful work
   * @type {number}
   * @memberof RpcSourceStats
   */
  processing_time_us?: number;
}

/**
 *
 * @export
 * @interface S3Integration
 */
export interface S3Integration {
  /**
   * credentials for an AWS access key integration
   * @type {AwsAccessKey}
   * @memberof S3Integration
   */
  aws_access_key?: AwsAccessKey;
  /**
   * details of an AWS cross-account role integration
   * @type {AwsRole}
   * @memberof S3Integration
   */
  aws_role?: AwsRole;
}

/**
 *
 * @export
 * @interface SegmentIntegration
 */
export interface SegmentIntegration {
  /**
   * segment connection string
   * @type {string}
   * @memberof SegmentIntegration
   */
  connection_string?: string;
}

/**
 * Details about the data source for the given collection. Only one of the following fields are allowed to be defined. Only collections can act as data sources for views.
 * @export
 * @interface Source
 */
export interface Source {
  /**
   * name of integration to use
   * @type {string}
   * @memberof Source
   */
  integration_name: string;
  /**
   * configuration for ingestion from S3
   * @type {SourceS3}
   * @memberof Source
   */
  s3?: SourceS3;
  /**
   * configuration for ingestion from kinesis stream
   * @type {SourceKinesis}
   * @memberof Source
   */
  kinesis?: SourceKinesis;
  /**
   * configuration for ingestion from GCS
   * @type {SourceGcs}
   * @memberof Source
   */
  gcs?: SourceGcs;
  /**
   * configuration for ingestion from Redshift
   * @type {SourceRedshift}
   * @memberof Source
   */
  redshift?: SourceRedshift;
  /**
   * configuration for ingestion from  a dynamodb table
   * @type {SourceDynamoDb}
   * @memberof Source
   */
  dynamodb?: SourceDynamoDb;
  /**
   * file upload details
   * @type {SourceFileUpload}
   * @memberof Source
   */
  file_upload?: SourceFileUpload;
  /**
   * kafka collection identifier
   * @type {SourceKafka}
   * @memberof Source
   */
  kafka?: SourceKafka;
  /**
   * MongoDB collection details
   * @type {SourceMongoDb}
   * @memberof Source
   */
  mongodb?: SourceMongoDb;
  /**
   * the ingest status of this source
   * @type {Status}
   * @memberof Source
   */
  status?: Status;
  /**
   * format parameters for data from this source
   * @type {FormatParams}
   * @memberof Source
   */
  format_params?: FormatParams;
}

/**
 *
 * @export
 * @interface SourceConfig
 */
export interface SourceConfig {
  /**
   * dynamo source information
   * @type {SourceConfigDynamo}
   * @memberof SourceConfig
   */
  dynamo_config?: SourceConfigDynamo;
}

/**
 *
 * @export
 * @interface SourceConfigDynamo
 */
export interface SourceConfigDynamo {
  /**
   * RCUs configured on source DynamoDb Table
   * @type {number}
   * @memberof SourceConfigDynamo
   */
  rcu?: number;
  /**
   * estimated time in seconds to scan DynamoDb Table
   * @type {number}
   * @memberof SourceConfigDynamo
   */
  estimated_time_seconds?: number;
  /**
   * size of DynamoDb Table in Bytes
   * @type {number}
   * @memberof SourceConfigDynamo
   */
  table_size_bytes?: number;
  /**
   * number of records in DynamoDb Table
   * @type {number}
   * @memberof SourceConfigDynamo
   */
  num_records?: number;
}

/**
 *
 * @export
 * @interface SourceConfigRequest
 */
export interface SourceConfigRequest {
  /**
   * name of integration to use
   * @type {string}
   * @memberof SourceConfigRequest
   */
  integration_name: string;
  /**
   * configuration for ingestion from a DynamoDB table
   * @type {SourceDynamoDb}
   * @memberof SourceConfigRequest
   */
  dynamodb?: SourceDynamoDb;
}

/**
 *
 * @export
 * @interface SourceConfigResponse
 */
export interface SourceConfigResponse {
  /**
   * source information that was requested
   * @type {SourceConfig}
   * @memberof SourceConfigResponse
   */
  data?: SourceConfig;
}

/**
 *
 * @export
 * @interface SourceDynamoDb
 */
export interface SourceDynamoDb {
  /**
   * AWS region name of DynamoDB table, by default us-west-2 is used
   * @type {string}
   * @memberof SourceDynamoDb
   */
  aws_region?: string;
  /**
   * name of DynamoDB table containing data
   * @type {string}
   * @memberof SourceDynamoDb
   */
  table_name: string;
  /**
   * DynamoDB source status
   * @type {StatusDynamoDb}
   * @memberof SourceDynamoDb
   */
  status?: StatusDynamoDb;
  /**
   * Max RCU usage for scan
   * @type {number}
   * @memberof SourceDynamoDb
   */
  rcu?: number;
}

/**
 *
 * @export
 * @interface SourceFileUpload
 */
export interface SourceFileUpload {
  /**
   * name of the file
   * @type {string}
   * @memberof SourceFileUpload
   */
  file_name: string;
  /**
   * size of the file in bytes
   * @type {number}
   * @memberof SourceFileUpload
   */
  file_size: number;
  /**
   * time of file upload
   * @type {string}
   * @memberof SourceFileUpload
   */
  file_upload_time: string;
}

/**
 *
 * @export
 * @interface SourceGcs
 */
export interface SourceGcs {
  /**
   * name of GCS bucket you want to ingest from
   * @type {string}
   * @memberof SourceGcs
   */
  bucket?: string;
  /**
   * Prefix that selects keys to ingest.
   * @type {string}
   * @memberof SourceGcs
   */
  prefix?: string;
}

/**
 *
 * @export
 * @interface SourceKafka
 */
export interface SourceKafka {
  /**
   * The Kafka topic to be tailed
   * @type {string}
   * @memberof SourceKafka
   */
  kafka_topic_name: string;
  /**
   * Kafka source status
   * @type {StatusKafka}
   * @memberof SourceKafka
   */
  status?: StatusKafka;
}

/**
 *
 * @export
 * @interface SourceKinesis
 */
export interface SourceKinesis {
  /**
   * name of kinesis stream
   * @type {string}
   * @memberof SourceKinesis
   */
  stream_name: string;
  /**
   * AWS region name of Kinesis stream, by default us-west-2 is used
   * @type {string}
   * @memberof SourceKinesis
   */
  aws_region?: string;
}

/**
 *
 * @export
 * @interface SourceMongoDb
 */
export interface SourceMongoDb {
  /**
   * MongoDB database name containing this collection
   * @type {string}
   * @memberof SourceMongoDb
   */
  database_name: string;
  /**
   * MongoDB collection name
   * @type {string}
   * @memberof SourceMongoDb
   */
  collection_name: string;
  /**
   * MongoDB source status
   * @type {StatusMongoDb}
   * @memberof SourceMongoDb
   */
  status?: StatusMongoDb;
}

/**
 *
 * @export
 * @interface SourceRedshift
 */
export interface SourceRedshift {
  /**
   * name of the database in Redshift Cluster
   * @type {string}
   * @memberof SourceRedshift
   */
  database: string;
  /**
   * schema which contains the Redshift table
   * @type {string}
   * @memberof SourceRedshift
   */
  schema: string;
  /**
   * name of Redshift table containing data
   * @type {string}
   * @memberof SourceRedshift
   */
  table_name: string;
  /**
   * field in Redshift source table to monitor for updates
   * @type {string}
   * @memberof SourceRedshift
   */
  incremental_field?: string;
}

/**
 *
 * @export
 * @interface SourceS3
 */
export interface SourceS3 {
  /**
   * AWS credential with ListObjects and GetObject access
   * @type {string}
   * @memberof SourceS3
   */
  access_key?: string;
  /**
   * AWS credential with ListObjects and GetObject access
   * @type {string}
   * @memberof SourceS3
   */
  secret_access?: string;
  /**
   * Prefix that selects keys to ingest.
   * @type {string}
   * @memberof SourceS3
   */
  prefix?: string;
  /**
   * Pattern that selects keys to ingest.
   * @type {string}
   * @memberof SourceS3
   */
  pattern?: string;
  /**
   * AWS region containing source bucket
   * @type {string}
   * @memberof SourceS3
   */
  region?: string;
  /**
   * address of S3 bucket containing data
   * @type {string}
   * @memberof SourceS3
   */
  bucket: string;
  /**
   * list of prefixes to paths from which data should be ingested
   * @type {Array<string>}
   * @memberof SourceS3
   */
  prefixes: Array<string>;
  /**
   * do not use
   * @type {string}
   * @memberof SourceS3
   */
  format?: SourceS3.FormatEnum;
  /**
   * custom transformation on data field
   * @type {Array<FieldMask>}
   * @memberof SourceS3
   */
  mappings?: Array<FieldMask>;
}

/**
 * @export
 * @namespace SourceS3
 */
export namespace SourceS3 {
  /**
   * @export
   * @enum {string}
   */
  export enum FormatEnum {
    JSON = <any>'JSON',
  }
}

/**
 *
 * @export
 * @interface SqlExpression
 */
export interface SqlExpression {
  /**
   * The name of a sql function
   * @type {string}
   * @memberof SqlExpression
   */
  sql?: string;
}

/**
 *
 * @export
 * @interface Status
 */
export interface Status {
  /**
   * Status of the Source's ingestion, one of: INITIALIZING, WATCHING, PROCESSING, COMPLETED, ERROR
   * @type {string}
   * @memberof Status
   */
  state?: Status.StateEnum;
  /**
   * ISO-8601 date when state was triggered
   * @type {string}
   * @memberof Status
   */
  since?: string;
  /**
   * state message
   * @type {string}
   * @memberof Status
   */
  message?: string;
  /**
   * ISO-8601 date when source was last processed
   * @type {string}
   * @memberof Status
   */
  last_processed_at?: string;
  /**
   * last source item processed by ingester
   * @type {string}
   * @memberof Status
   */
  last_processed_item?: string;
  /**
   * Total items processed of source
   * @type {number}
   * @memberof Status
   */
  total_processed_items?: number;
  /**
   * ISO-8601 date when last error occurred
   * @type {string}
   * @memberof Status
   */
  last_error_at?: string;
  /**
   * last source item that errored
   * @type {string}
   * @memberof Status
   */
  last_error_item?: string;
  /**
   * reason for the last error
   * @type {string}
   * @memberof Status
   */
  last_error_reason?: string;
  /**
   * Total items that errored
   * @type {number}
   * @memberof Status
   */
  total_error_items?: number;
}

/**
 * @export
 * @namespace Status
 */
export namespace Status {
  /**
   * @export
   * @enum {string}
   */
  export enum StateEnum {
    INITIALIZING = <any>'INITIALIZING',
    WATCHING = <any>'WATCHING',
    PROCESSING = <any>'PROCESSING',
    COMPLETED = <any>'COMPLETED',
    ERROR = <any>'ERROR',
  }
}

/**
 *
 * @export
 * @interface StatusDynamoDb
 */
export interface StatusDynamoDb {
  /**
   * DynamoDB scan start time
   * @type {string}
   * @memberof StatusDynamoDb
   */
  scan_start_time?: string;
  /**
   * DynamoDb scan end time
   * @type {string}
   * @memberof StatusDynamoDb
   */
  scan_end_time?: string;
  /**
   * Number of records inserted using scan
   * @type {number}
   * @memberof StatusDynamoDb
   */
  scan_records_processed?: number;
  /**
   * Number of records in DynamoDB table at time of scan
   * @type {number}
   * @memberof StatusDynamoDb
   */
  scan_total_records?: number;
  /**
   * state of current ingest for this table
   * @type {string}
   * @memberof StatusDynamoDb
   */
  state?: StatusDynamoDb.StateEnum;
  /**
   * ISO-8601 date when source was last processed
   * @type {string}
   * @memberof StatusDynamoDb
   */
  stream_last_processed_at?: string;
}

/**
 * @export
 * @namespace StatusDynamoDb
 */
export namespace StatusDynamoDb {
  /**
   * @export
   * @enum {string}
   */
  export enum StateEnum {
    INITIALIZING = <any>'INITIALIZING',
    SCANNINGTABLE = <any>'SCANNING_TABLE',
    PROCESSINGSTREAM = <any>'PROCESSING_STREAM',
  }
}

/**
 *
 * @export
 * @interface StatusKafka
 */
export interface StatusKafka {
  /**
   * State of the Kafka source
   * @type {string}
   * @memberof StatusKafka
   */
  state?: StatusKafka.StateEnum;
  /**
   * Time at which the last document was consumed from Kafka
   * @type {string}
   * @memberof StatusKafka
   */
  last_consumed_time?: string;
  /**
   * Number of documents consumed by this Kafka topic
   * @type {number}
   * @memberof StatusKafka
   */
  num_documents_processed?: number;
}

/**
 * @export
 * @namespace StatusKafka
 */
export namespace StatusKafka {
  /**
   * @export
   * @enum {string}
   */
  export enum StateEnum {
    NODOCSYET = <any>'NO_DOCS_YET',
    ACTIVE = <any>'ACTIVE',
    DORMANT = <any>'DORMANT',
  }
}

/**
 *
 * @export
 * @interface StatusKafkaPartition
 */
export interface StatusKafkaPartition {
  /**
   * The number of this partition
   * @type {number}
   * @memberof StatusKafkaPartition
   */
  partition_number?: number;
  /**
   * Number of documents consumed by this partition
   * @type {number}
   * @memberof StatusKafkaPartition
   */
  num_documents_processed?: number;
}

/**
 *
 * @export
 * @interface StatusMongoDb
 */
export interface StatusMongoDb {
  /**
   * MongoDB scan start time
   * @type {string}
   * @memberof StatusMongoDb
   */
  scan_start_time?: string;
  /**
   * MongoDB scan end time
   * @type {string}
   * @memberof StatusMongoDb
   */
  scan_end_time?: string;
  /**
   * Number of records inserted using scan
   * @type {number}
   * @memberof StatusMongoDb
   */
  scan_records_processed?: number;
  /**
   * Number of records in MongoDB table at time of scan
   * @type {number}
   * @memberof StatusMongoDb
   */
  scan_total_records?: number;
  /**
   * state of current ingest for this table
   * @type {string}
   * @memberof StatusMongoDb
   */
  state?: StatusMongoDb.StateEnum;
  /**
   * ISO-8601 date when new insert from source was last processed
   * @type {string}
   * @memberof StatusMongoDb
   */
  stream_last_insert_processed_at?: string;
  /**
   * ISO-8601 date when update from source was last processed
   * @type {string}
   * @memberof StatusMongoDb
   */
  stream_last_update_processed_at?: string;
  /**
   * ISO-8601 date when delete from source was last processed
   * @type {string}
   * @memberof StatusMongoDb
   */
  stream_last_delete_processed_at?: string;
  /**
   * Number of new records inserted using stream
   * @type {number}
   * @memberof StatusMongoDb
   */
  stream_records_inserted?: number;
  /**
   * Number of new records updated using stream
   * @type {number}
   * @memberof StatusMongoDb
   */
  stream_records_updated?: number;
  /**
   * Number of new records deleted using stream
   * @type {number}
   * @memberof StatusMongoDb
   */
  stream_records_deleted?: number;
}

/**
 * @export
 * @namespace StatusMongoDb
 */
export namespace StatusMongoDb {
  /**
   * @export
   * @enum {string}
   */
  export enum StateEnum {
    INITIALIZING = <any>'INITIALIZING',
    SCANNINGTABLE = <any>'SCANNING_TABLE',
    PROCESSINGSTREAM = <any>'PROCESSING_STREAM',
  }
}

/**
 *
 * @export
 * @interface StatusResponse
 */
export interface StatusResponse {
  /**
   *
   * @type {string}
   * @memberof StatusResponse
   */
  message?: string;
}

/**
 *
 * @export
 * @interface SwitchVirtualInstanceTypeRequest
 */
export interface SwitchVirtualInstanceTypeRequest {
  /**
   * Requested virtual instance type
   * @type {string}
   * @memberof SwitchVirtualInstanceTypeRequest
   */
  new_type: SwitchVirtualInstanceTypeRequest.NewTypeEnum;
}

/**
 * @export
 * @namespace SwitchVirtualInstanceTypeRequest
 */
export namespace SwitchVirtualInstanceTypeRequest {
  /**
   * @export
   * @enum {string}
   */
  export enum NewTypeEnum {
    FREE = <any>'FREE',
    SHARED = <any>'SHARED',
    SMALL = <any>'SMALL',
    MEDIUM = <any>'MEDIUM',
    LARGE = <any>'LARGE',
    XLARGE = <any>'XLARGE',
    XLARGE2 = <any>'XLARGE2',
    XLARGE4 = <any>'XLARGE4',
    XLARGE8 = <any>'XLARGE8',
    XLARGE16 = <any>'XLARGE16',
  }
}

/**
 *
 * @export
 * @interface SwitchVirtualInstanceTypeResponse
 */
export interface SwitchVirtualInstanceTypeResponse {
  /**
   * virtual instance that was switched
   * @type {VirtualInstance}
   * @memberof SwitchVirtualInstanceTypeResponse
   */
  data?: VirtualInstance;
}

/**
 *
 * @export
 * @interface TelemetryRequest
 */
export interface TelemetryRequest {
  /**
   * event details
   * @type {{ [key: string]: any; }}
   * @memberof TelemetryRequest
   */
  event?: { [key: string]: any };
}

/**
 *
 * @export
 * @interface UpdateAliasRequest
 */
export interface UpdateAliasRequest {
  /**
   * optional description
   * @type {string}
   * @memberof UpdateAliasRequest
   */
  description?: string;
  /**
   * list of fully qualified collection names referenced by alias
   * @type {Array<string>}
   * @memberof UpdateAliasRequest
   */
  collections: Array<string>;
}

/**
 *
 * @export
 * @interface UpdateOrgPaymentMethodRequest
 */
export interface UpdateOrgPaymentMethodRequest {
  /**
   * Stripe source
   * @type {string}
   * @memberof UpdateOrgPaymentMethodRequest
   */
  source?: string;
}

/**
 *
 * @export
 * @interface UpdateQueryLambdaRequest
 */
export interface UpdateQueryLambdaRequest {
  /**
   * optional description
   * @type {string}
   * @memberof UpdateQueryLambdaRequest
   */
  description?: string;
  /**
   * Query Lambda SQL query
   * @type {QueryLambdaSql}
   * @memberof UpdateQueryLambdaRequest
   */
  sql?: QueryLambdaSql;
}

/**
 *
 * @export
 * @interface UpdateSsoRequest
 */
export interface UpdateSsoRequest {
  /**
   * x09 SAML certificate
   * @type {string}
   * @memberof UpdateSsoRequest
   */
  cert?: string;
  /**
   * SSO provided endpoint to trigger login
   * @type {string}
   * @memberof UpdateSsoRequest
   */
  sign_in_endpoint?: string;
  /**
   * auto provision accounts for users in domain
   * @type {boolean}
   * @memberof UpdateSsoRequest
   */
  auto_provision?: boolean;
  /**
   * auto provision accounts with this role
   * @type {string}
   * @memberof UpdateSsoRequest
   */
  auto_provision_role?: string;
  /**
   * force sso as only auth mechanism for org
   * @type {boolean}
   * @memberof UpdateSsoRequest
   */
  sso_only?: boolean;
}

/**
 *
 * @export
 * @interface UpdateUserNuxRequest
 */
export interface UpdateUserNuxRequest {
  /**
   * data integration for this user's nux
   * @type {string}
   * @memberof UpdateUserNuxRequest
   */
  data_integration?: UpdateUserNuxRequest.DataIntegrationEnum;
  /**
   * way in which user wants to export query in nux
   * @type {string}
   * @memberof UpdateUserNuxRequest
   */
  query_integration_type?: UpdateUserNuxRequest.QueryIntegrationTypeEnum;
  /**
   * specific query integration for this user's nux
   * @type {string}
   * @memberof UpdateUserNuxRequest
   */
  query_integration?: UpdateUserNuxRequest.QueryIntegrationEnum;
  /**
   * boolean for if user has dismissed nux
   * @type {boolean}
   * @memberof UpdateUserNuxRequest
   */
  dismissed_nux?: boolean;
}

/**
 * @export
 * @namespace UpdateUserNuxRequest
 */
export namespace UpdateUserNuxRequest {
  /**
   * @export
   * @enum {string}
   */
  export enum DataIntegrationEnum {
    S3 = <any>'S3',
    KINESIS = <any>'KINESIS',
    DYNAMODB = <any>'DYNAMODB',
    GCS = <any>'GCS',
    REDSHIFT = <any>'REDSHIFT',
    KAFKA = <any>'KAFKA',
    FILE = <any>'FILE',
    WRITE = <any>'WRITE',
    PUBLIC = <any>'PUBLIC',
    MONGODB = <any>'MONGODB',
    UNKNOWN = <any>'UNKNOWN',
  }
  /**
   * @export
   * @enum {string}
   */
  export enum QueryIntegrationTypeEnum {
    VIZ = <any>'VIZ',
    CODE = <any>'CODE',
    UNKNOWN = <any>'UNKNOWN',
  }
  /**
   * @export
   * @enum {string}
   */
  export enum QueryIntegrationEnum {
    GRAFANA = <any>'GRAFANA',
    REDASH = <any>'REDASH',
    SUPERSET = <any>'SUPERSET',
    TABLEAU = <any>'TABLEAU',
    GOLANG = <any>'GOLANG',
    JAVA = <any>'JAVA',
    NODEJS = <any>'NODEJS',
    PYTHON = <any>'PYTHON',
    RLANG = <any>'RLANG',
    REST = <any>'REST',
    UNKNOWN = <any>'UNKNOWN',
  }
}

/**
 *
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
  /**
   * user first name
   * @type {string}
   * @memberof UpdateUserRequest
   */
  first_name?: string;
  /**
   * user last name
   * @type {string}
   * @memberof UpdateUserRequest
   */
  last_name?: string;
  /**
   * user phone number
   * @type {string}
   * @memberof UpdateUserRequest
   */
  phone_number?: string;
  /**
   * number of times to prompt user for demo
   * @type {number}
   * @memberof UpdateUserRequest
   */
  demo_remaining_prompts?: number;
}

/**
 *
 * @export
 * @interface UploadFileResponse
 */
export interface UploadFileResponse {
  /**
   * information about the file uploaded
   * @type {FileUploadStatus}
   * @memberof UploadFileResponse
   */
  data?: FileUploadStatus;
}

/**
 *
 * @export
 * @interface Usage
 */
export interface Usage {
  /**
   *
   * @type {number}
   * @memberof Usage
   */
  price?: number;
  /**
   *
   * @type {number}
   * @memberof Usage
   */
  gb_hours?: number;
  /**
   *
   * @type {number}
   * @memberof Usage
   */
  gb_months: number;
  /**
   *
   * @type {number}
   * @memberof Usage
   */
  total_cost: number;
}

/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   * ISO-8601 date
   * @type {string}
   * @memberof User
   */
  created_at?: string;
  /**
   * user email
   * @type {string}
   * @memberof User
   */
  email: string;
  /**
   * user first name
   * @type {string}
   * @memberof User
   */
  first_name?: string;
  /**
   * user last name
   * @type {string}
   * @memberof User
   */
  last_name?: string;
  /**
   * user phone number
   * @type {string}
   * @memberof User
   */
  phone_number?: string;
  /**
   * List of roles for a given user
   * @type {Array<string>}
   * @memberof User
   */
  roles?: Array<string>;
  /**
   * state of user - NEW / ACTIVE
   * @type {string}
   * @memberof User
   */
  state?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  org?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  invite_state?: User.InviteStateEnum;
  /**
   *
   * @type {Array<Organization>}
   * @memberof User
   */
  orgs?: Array<Organization>;
  /**
   *
   * @type {Array<OrgMembership>}
   * @memberof User
   */
  org_memberships?: Array<OrgMembership>;
}

/**
 * @export
 * @namespace User
 */
export namespace User {
  /**
   * @export
   * @enum {string}
   */
  export enum InviteStateEnum {
    PENDING = <any>'PENDING',
    ACCEPTED = <any>'ACCEPTED',
    EXPIRED = <any>'EXPIRED',
    CANCELLED = <any>'CANCELLED',
  }
}

/**
 *
 * @export
 * @interface UserNux
 */
export interface UserNux {
  /**
   * user email
   * @type {string}
   * @memberof UserNux
   */
  email: string;
  /**
   * data integration for this user's nux
   * @type {string}
   * @memberof UserNux
   */
  data_integration?: UserNux.DataIntegrationEnum;
  /**
   * way in which user wants to export query in nux
   * @type {string}
   * @memberof UserNux
   */
  query_integration_type?: UserNux.QueryIntegrationTypeEnum;
  /**
   * specific query integration for this user's nux
   * @type {string}
   * @memberof UserNux
   */
  query_integration?: UserNux.QueryIntegrationEnum;
  /**
   * boolean for if user has dismissed nux
   * @type {boolean}
   * @memberof UserNux
   */
  dismissed_nux?: boolean;
}

/**
 * @export
 * @namespace UserNux
 */
export namespace UserNux {
  /**
   * @export
   * @enum {string}
   */
  export enum DataIntegrationEnum {
    S3 = <any>'S3',
    KINESIS = <any>'KINESIS',
    DYNAMODB = <any>'DYNAMODB',
    GCS = <any>'GCS',
    REDSHIFT = <any>'REDSHIFT',
    KAFKA = <any>'KAFKA',
    FILE = <any>'FILE',
    WRITE = <any>'WRITE',
    PUBLIC = <any>'PUBLIC',
    MONGODB = <any>'MONGODB',
    UNKNOWN = <any>'UNKNOWN',
  }
  /**
   * @export
   * @enum {string}
   */
  export enum QueryIntegrationTypeEnum {
    VIZ = <any>'VIZ',
    CODE = <any>'CODE',
    UNKNOWN = <any>'UNKNOWN',
  }
  /**
   * @export
   * @enum {string}
   */
  export enum QueryIntegrationEnum {
    GRAFANA = <any>'GRAFANA',
    REDASH = <any>'REDASH',
    SUPERSET = <any>'SUPERSET',
    TABLEAU = <any>'TABLEAU',
    GOLANG = <any>'GOLANG',
    JAVA = <any>'JAVA',
    NODEJS = <any>'NODEJS',
    PYTHON = <any>'PYTHON',
    RLANG = <any>'RLANG',
    REST = <any>'REST',
    UNKNOWN = <any>'UNKNOWN',
  }
}

/**
 *
 * @export
 * @interface UserQuery
 */
export interface UserQuery {
  /**
   * success/invalid status of query
   * @type {string}
   * @memberof UserQuery
   */
  label?: string;
  /**
   * query that user executed
   * @type {string}
   * @memberof UserQuery
   */
  query_sql?: string;
  /**
   * ISO 8601 time at which the query was executed
   * @type {string}
   * @memberof UserQuery
   */
  query_time?: string;
}

/**
 *
 * @export
 * @interface UserQueryHistoryResponse
 */
export interface UserQueryHistoryResponse {
  /**
   * query history of this user
   * @type {Array<UserQuery>}
   * @memberof UserQueryHistoryResponse
   */
  data?: Array<UserQuery>;
}

/**
 *
 * @export
 * @interface UserState
 */
export interface UserState {
  /**
   * state of user
   * @type {string}
   * @memberof UserState
   */
  data?: UserState.DataEnum;
  /**
   * number of prompts left for user
   * @type {number}
   * @memberof UserState
   */
  demo_remaining_prompts?: number;
}

/**
 * @export
 * @namespace UserState
 */
export namespace UserState {
  /**
   * @export
   * @enum {string}
   */
  export enum DataEnum {
    NEW = <any>'NEW',
    ACTIVE = <any>'ACTIVE',
  }
}

/**
 *
 * @export
 * @interface ValidateExpressionRequest
 */
export interface ValidateExpressionRequest {
  /**
   * SQL expression to be validated
   * @type {string}
   * @memberof ValidateExpressionRequest
   */
  sql_expression?: string;
}

/**
 *
 * @export
 * @interface ValidateExpressionResponse
 */
export interface ValidateExpressionResponse {
  /**
   * input parameters of validated SQL expression
   * @type {Array<string>}
   * @memberof ValidateExpressionResponse
   */
  parameters?: Array<string>;
}

/**
 *
 * @export
 * @interface ValidateQueryResponse
 */
export interface ValidateQueryResponse {
  /**
   * list of aliases specifiedQueryRunner and referenced collections in query
   * @type {Array<QueryResponseAlias>}
   * @memberof ValidateQueryResponse
   */
  aliases?: Array<QueryResponseAlias>;
  /**
   * list of collection specified in query
   * @type {Array<string>}
   * @memberof ValidateQueryResponse
   */
  name: Array<string>;
  /**
   * list of collection specified in query
   * @type {Array<string>}
   * @memberof ValidateQueryResponse
   */
  collections: Array<string>;
  /**
   * list of parameters specified in query
   * @type {Array<string>}
   * @memberof ValidateQueryResponse
   */
  parameters: Array<string>;
}

/**
 *
 * @export
 * @interface VirtualInstance
 */
export interface VirtualInstance {
  /**
   * virtual instance state
   * @type {string}
   * @memberof VirtualInstance
   */
  state?: VirtualInstance.StateEnum;
  /**
   * virtual instance current type
   * @type {string}
   * @memberof VirtualInstance
   */
  current_type?: VirtualInstance.CurrentTypeEnum;
  /**
   * virtual instance desired type
   * @type {string}
   * @memberof VirtualInstance
   */
  desired_type?: VirtualInstance.DesiredTypeEnum;
  /**
   * virtual instance default pod count
   * @type {number}
   * @memberof VirtualInstance
   */
  default_pod_count?: number;
  /**
   * virtual instance scaled pod count
   * @type {number}
   * @memberof VirtualInstance
   */
  scaled_pod_count?: number;
  /**
   * unique identifier for virtual instance
   * @type {string}
   * @memberof VirtualInstance
   */
  id?: string;
}

/**
 * @export
 * @namespace VirtualInstance
 */
export namespace VirtualInstance {
  /**
   * @export
   * @enum {string}
   */
  export enum StateEnum {
    PROVISIONINGRESOURCES = <any>'PROVISIONING_RESOURCES',
    REBALANCINGCOLLECTIONS = <any>'REBALANCING_COLLECTIONS',
    ACTIVE = <any>'ACTIVE',
    DELETED = <any>'DELETED',
  }
  /**
   * @export
   * @enum {string}
   */
  export enum CurrentTypeEnum {
    FREE = <any>'FREE',
    SHARED = <any>'SHARED',
    SMALL = <any>'SMALL',
    MEDIUM = <any>'MEDIUM',
    LARGE = <any>'LARGE',
    XLARGE = <any>'XLARGE',
    XLARGE2 = <any>'XLARGE2',
    XLARGE4 = <any>'XLARGE4',
    XLARGE8 = <any>'XLARGE8',
    XLARGE16 = <any>'XLARGE16',
  }
  /**
   * @export
   * @enum {string}
   */
  export enum DesiredTypeEnum {
    FREE = <any>'FREE',
    SHARED = <any>'SHARED',
    SMALL = <any>'SMALL',
    MEDIUM = <any>'MEDIUM',
    LARGE = <any>'LARGE',
    XLARGE = <any>'XLARGE',
    XLARGE2 = <any>'XLARGE2',
    XLARGE4 = <any>'XLARGE4',
    XLARGE8 = <any>'XLARGE8',
    XLARGE16 = <any>'XLARGE16',
  }
}

/**
 *
 * @export
 * @interface VirtualInstanceMetrics
 */
export interface VirtualInstanceMetrics {
  /**
   * virtual instance current type
   * @type {string}
   * @memberof VirtualInstanceMetrics
   */
  current_type?: VirtualInstanceMetrics.CurrentTypeEnum;
  /**
   * virtual instance desired type
   * @type {string}
   * @memberof VirtualInstanceMetrics
   */
  desired_type?: VirtualInstanceMetrics.DesiredTypeEnum;
  /**
   * virtual instance state
   * @type {string}
   * @memberof VirtualInstanceMetrics
   */
  state?: VirtualInstanceMetrics.StateEnum;
  /**
   * virtual instance leaf cpu load
   * @type {number}
   * @memberof VirtualInstanceMetrics
   */
  leaf_cpu_load?: number;
  /**
   * virtual instance leaf cpu utilization
   * @type {number}
   * @memberof VirtualInstanceMetrics
   */
  leaf_cpu_utilization?: number;
  /**
   * virtual instance leaf cpu allocated
   * @type {number}
   * @memberof VirtualInstanceMetrics
   */
  leaf_cpu_allocated?: number;
  /**
   * virtual instance leaf memory used
   * @type {number}
   * @memberof VirtualInstanceMetrics
   */
  leaf_memory_used?: number;
  /**
   * virtual instance leaf memory allocated
   * @type {number}
   * @memberof VirtualInstanceMetrics
   */
  leaf_memory_allocated?: number;
  /**
   * virtual instance aggregator cpu load
   * @type {number}
   * @memberof VirtualInstanceMetrics
   */
  aggregator_cpu_load?: number;
  /**
   * virtual instance aggregator cpu utilization
   * @type {number}
   * @memberof VirtualInstanceMetrics
   */
  aggregator_cpu_utilization?: number;
  /**
   * virtual instance aggregator cpu allocated
   * @type {number}
   * @memberof VirtualInstanceMetrics
   */
  aggregator_cpu_allocated?: number;
  /**
   * virtual instance aggregator memory used
   * @type {number}
   * @memberof VirtualInstanceMetrics
   */
  aggregator_memory_used?: number;
  /**
   * virtual instance aggregator memory allocated
   * @type {number}
   * @memberof VirtualInstanceMetrics
   */
  aggregator_memory_allocated?: number;
  /**
   * virtual instance queries in flight
   * @type {number}
   * @memberof VirtualInstanceMetrics
   */
  queries_in_flight?: number;
  /**
   * metrics timestamp millis
   * @type {number}
   * @memberof VirtualInstanceMetrics
   */
  time_millis?: number;
}

/**
 * @export
 * @namespace VirtualInstanceMetrics
 */
export namespace VirtualInstanceMetrics {
  /**
   * @export
   * @enum {string}
   */
  export enum CurrentTypeEnum {
    FREE = <any>'FREE',
    SHARED = <any>'SHARED',
    SMALL = <any>'SMALL',
    MEDIUM = <any>'MEDIUM',
    LARGE = <any>'LARGE',
    XLARGE = <any>'XLARGE',
    XLARGE2 = <any>'XLARGE2',
    XLARGE4 = <any>'XLARGE4',
    XLARGE8 = <any>'XLARGE8',
    XLARGE16 = <any>'XLARGE16',
  }
  /**
   * @export
   * @enum {string}
   */
  export enum DesiredTypeEnum {
    FREE = <any>'FREE',
    SHARED = <any>'SHARED',
    SMALL = <any>'SMALL',
    MEDIUM = <any>'MEDIUM',
    LARGE = <any>'LARGE',
    XLARGE = <any>'XLARGE',
    XLARGE2 = <any>'XLARGE2',
    XLARGE4 = <any>'XLARGE4',
    XLARGE8 = <any>'XLARGE8',
    XLARGE16 = <any>'XLARGE16',
  }
  /**
   * @export
   * @enum {string}
   */
  export enum StateEnum {
    PROVISIONINGRESOURCES = <any>'PROVISIONING_RESOURCES',
    REBALANCINGCOLLECTIONS = <any>'REBALANCING_COLLECTIONS',
    ACTIVE = <any>'ACTIVE',
    DELETED = <any>'DELETED',
  }
}

/**
 * Workspaces are organizational containers for collections.
 * @export
 * @interface Workspace
 */
export interface Workspace {
  /**
   * ISO-8601 date of when workspace was created
   * @type {string}
   * @memberof Workspace
   */
  created_at?: string;
  /**
   * email of user who created the workspace
   * @type {string}
   * @memberof Workspace
   */
  created_by?: string;
  /**
   * descriptive label and unique identifier
   * @type {string}
   * @memberof Workspace
   */
  name?: string;
  /**
   * longer explanation for the workspace
   * @type {string}
   * @memberof Workspace
   */
  description?: string;
  /**
   * number of collections that are immediate children of workspace
   * @type {number}
   * @memberof Workspace
   */
  collection_count?: number;
}

/**
 *
 * @export
 * @interface XmlParams
 */
export interface XmlParams {
  /**
   * tag until which xml is ignored
   * @type {string}
   * @memberof XmlParams
   */
  root_tag?: string;
  /**
   * encoding in which data source is encoded
   * @type {string}
   * @memberof XmlParams
   */
  encoding?: string;
  /**
   * tags with which documents are identified
   * @type {string}
   * @memberof XmlParams
   */
  doc_tag?: string;
  /**
   * tag used for the value when there are attributes in the element having no child
   * @type {string}
   * @memberof XmlParams
   */
  value_tag?: string;
  /**
   * tag to differentiate between attributes and elements
   * @type {string}
   * @memberof XmlParams
   */
  attribute_prefix?: string;
}

/**
 * AliasesApi - fetch parameter creator
 * @export
 */
export const AliasesApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     * Create new alias in a workspace.
     * @summary Create alias
     * @param {string} workspace name of the workspace
     * @param {CreateAliasRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAlias(workspace: string, body: CreateAliasRequest, options: any = {}): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling createAlias.',
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createAlias.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/aliases`.replace(
        `{${'workspace'}}`,
        encodeURIComponent(String(workspace)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'CreateAliasRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete an alias.
     * @summary Delete Alias
     * @param {string} workspace name of the workspace
     * @param {string} alias name of the alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAlias(workspace: string, alias: string, options: any = {}): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling deleteAlias.',
        );
      }
      // verify required parameter 'alias' is not null or undefined
      if (alias === null || alias === undefined) {
        throw new RequiredError(
          'alias',
          'Required parameter alias was null or undefined when calling deleteAlias.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/aliases/{alias}`
        .replace(`{${'workspace'}}`, encodeURIComponent(String(workspace)))
        .replace(`{${'alias'}}`, encodeURIComponent(String(alias)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get details about a alias
     * @summary Get Alias
     * @param {string} workspace name of the workspace
     * @param {string} alias name of the alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlias(workspace: string, alias: string, options: any = {}): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling getAlias.',
        );
      }
      // verify required parameter 'alias' is not null or undefined
      if (alias === null || alias === undefined) {
        throw new RequiredError(
          'alias',
          'Required parameter alias was null or undefined when calling getAlias.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/aliases/{alias}`
        .replace(`{${'workspace'}}`, encodeURIComponent(String(workspace)))
        .replace(`{${'alias'}}`, encodeURIComponent(String(alias)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve all aliases in an organization
     * @summary List Aliases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAliases(options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self/aliases`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all Query Lambdas that hit a specific Rockset Alias.
     * @summary Get Query Lambdas with Alias
     * @param {string} workspace
     * @param {string} alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listQueryLambdasWithAlias(workspace: string, alias: string, options: any = {}): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling listQueryLambdasWithAlias.',
        );
      }
      // verify required parameter 'alias' is not null or undefined
      if (alias === null || alias === undefined) {
        throw new RequiredError(
          'alias',
          'Required parameter alias was null or undefined when calling listQueryLambdasWithAlias.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/aliases/{alias}/lambdas`
        .replace(`{${'workspace'}}`, encodeURIComponent(String(workspace)))
        .replace(`{${'alias'}}`, encodeURIComponent(String(alias)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update alias in a workspace.
     * @summary Update alias
     * @param {string} workspace name of the workspace
     * @param {string} alias name of the alias
     * @param {UpdateAliasRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAlias(
      workspace: string,
      alias: string,
      body: UpdateAliasRequest,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling updateAlias.',
        );
      }
      // verify required parameter 'alias' is not null or undefined
      if (alias === null || alias === undefined) {
        throw new RequiredError(
          'alias',
          'Required parameter alias was null or undefined when calling updateAlias.',
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateAlias.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/aliases/{alias}`
        .replace(`{${'workspace'}}`, encodeURIComponent(String(workspace)))
        .replace(`{${'alias'}}`, encodeURIComponent(String(alias)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'UpdateAliasRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve all aliases in a workspace.
     * @summary List Aliases for Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspaceAliases(workspace: string, options: any = {}): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling workspaceAliases.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/aliases`.replace(
        `{${'workspace'}}`,
        encodeURIComponent(String(workspace)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AliasesApi - functional programming interface
 * @export
 */
export const AliasesApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Create new alias in a workspace.
     * @summary Create alias
     * @param {string} workspace name of the workspace
     * @param {CreateAliasRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAlias(
      workspace: string,
      body: CreateAliasRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CreateAliasResponse> {
      const localVarFetchArgs = AliasesApiFetchParamCreator(configuration).createAlias(
        workspace,
        body,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Delete an alias.
     * @summary Delete Alias
     * @param {string} workspace name of the workspace
     * @param {string} alias name of the alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAlias(
      workspace: string,
      alias: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteAliasResponse> {
      const localVarFetchArgs = AliasesApiFetchParamCreator(configuration).deleteAlias(
        workspace,
        alias,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get details about a alias
     * @summary Get Alias
     * @param {string} workspace name of the workspace
     * @param {string} alias name of the alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlias(
      workspace: string,
      alias: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<GetAliasResponse> {
      const localVarFetchArgs = AliasesApiFetchParamCreator(configuration).getAlias(
        workspace,
        alias,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieve all aliases in an organization
     * @summary List Aliases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAliases(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ListAliasesResponse> {
      const localVarFetchArgs = AliasesApiFetchParamCreator(configuration).listAliases(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get all Query Lambdas that hit a specific Rockset Alias.
     * @summary Get Query Lambdas with Alias
     * @param {string} workspace
     * @param {string} alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listQueryLambdasWithAlias(
      workspace: string,
      alias: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueryLambdasResponse> {
      const localVarFetchArgs = AliasesApiFetchParamCreator(
        configuration,
      ).listQueryLambdasWithAlias(workspace, alias, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Update alias in a workspace.
     * @summary Update alias
     * @param {string} workspace name of the workspace
     * @param {string} alias name of the alias
     * @param {UpdateAliasRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAlias(
      workspace: string,
      alias: string,
      body: UpdateAliasRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<GetAliasResponse> {
      const localVarFetchArgs = AliasesApiFetchParamCreator(configuration).updateAlias(
        workspace,
        alias,
        body,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieve all aliases in a workspace.
     * @summary List Aliases for Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspaceAliases(
      workspace: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ListAliasesResponse> {
      const localVarFetchArgs = AliasesApiFetchParamCreator(configuration).workspaceAliases(
        workspace,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * AliasesApi - factory interface
 * @export
 */
export const AliasesApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Create new alias in a workspace.
     * @summary Create alias
     * @param {string} workspace name of the workspace
     * @param {CreateAliasRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAlias(workspace: string, body: CreateAliasRequest, options?: any) {
      return AliasesApiFp(configuration).createAlias(workspace, body, options)(fetch, basePath);
    },
    /**
     * Delete an alias.
     * @summary Delete Alias
     * @param {string} workspace name of the workspace
     * @param {string} alias name of the alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAlias(workspace: string, alias: string, options?: any) {
      return AliasesApiFp(configuration).deleteAlias(workspace, alias, options)(fetch, basePath);
    },
    /**
     * Get details about a alias
     * @summary Get Alias
     * @param {string} workspace name of the workspace
     * @param {string} alias name of the alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlias(workspace: string, alias: string, options?: any) {
      return AliasesApiFp(configuration).getAlias(workspace, alias, options)(fetch, basePath);
    },
    /**
     * Retrieve all aliases in an organization
     * @summary List Aliases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAliases(options?: any) {
      return AliasesApiFp(configuration).listAliases(options)(fetch, basePath);
    },
    /**
     * Get all Query Lambdas that hit a specific Rockset Alias.
     * @summary Get Query Lambdas with Alias
     * @param {string} workspace
     * @param {string} alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listQueryLambdasWithAlias(workspace: string, alias: string, options?: any) {
      return AliasesApiFp(configuration).listQueryLambdasWithAlias(workspace, alias, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Update alias in a workspace.
     * @summary Update alias
     * @param {string} workspace name of the workspace
     * @param {string} alias name of the alias
     * @param {UpdateAliasRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAlias(workspace: string, alias: string, body: UpdateAliasRequest, options?: any) {
      return AliasesApiFp(configuration).updateAlias(workspace, alias, body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Retrieve all aliases in a workspace.
     * @summary List Aliases for Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspaceAliases(workspace: string, options?: any) {
      return AliasesApiFp(configuration).workspaceAliases(workspace, options)(fetch, basePath);
    },
  };
};

/**
 * AliasesApi - object-oriented interface
 * @export
 * @class AliasesApi
 * @extends {BaseAPI}
 */
export class AliasesApi extends BaseAPI {
  /**
   * Create new alias in a workspace.
   * @summary Create alias
   * @param {string} workspace name of the workspace
   * @param {CreateAliasRequest} body JSON object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AliasesApi
   */
  public createAlias(workspace: string, body: CreateAliasRequest, options?: any) {
    return AliasesApiFp(this.configuration).createAlias(workspace, body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Delete an alias.
   * @summary Delete Alias
   * @param {string} workspace name of the workspace
   * @param {string} alias name of the alias
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AliasesApi
   */
  public deleteAlias(workspace: string, alias: string, options?: any) {
    return AliasesApiFp(this.configuration).deleteAlias(workspace, alias, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Get details about a alias
   * @summary Get Alias
   * @param {string} workspace name of the workspace
   * @param {string} alias name of the alias
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AliasesApi
   */
  public getAlias(workspace: string, alias: string, options?: any) {
    return AliasesApiFp(this.configuration).getAlias(workspace, alias, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Retrieve all aliases in an organization
   * @summary List Aliases
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AliasesApi
   */
  public listAliases(options?: any) {
    return AliasesApiFp(this.configuration).listAliases(options)(this.fetch, this.basePath);
  }

  /**
   * Get all Query Lambdas that hit a specific Rockset Alias.
   * @summary Get Query Lambdas with Alias
   * @param {string} workspace
   * @param {string} alias
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AliasesApi
   */
  public listQueryLambdasWithAlias(workspace: string, alias: string, options?: any) {
    return AliasesApiFp(this.configuration).listQueryLambdasWithAlias(workspace, alias, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Update alias in a workspace.
   * @summary Update alias
   * @param {string} workspace name of the workspace
   * @param {string} alias name of the alias
   * @param {UpdateAliasRequest} body JSON object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AliasesApi
   */
  public updateAlias(workspace: string, alias: string, body: UpdateAliasRequest, options?: any) {
    return AliasesApiFp(this.configuration).updateAlias(workspace, alias, body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Retrieve all aliases in a workspace.
   * @summary List Aliases for Workspace
   * @param {string} workspace name of the workspace
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AliasesApi
   */
  public workspaceAliases(workspace: string, options?: any) {
    return AliasesApiFp(this.configuration).workspaceAliases(workspace, options)(
      this.fetch,
      this.basePath,
    );
  }
}

/**
 * ApiKeysApi - fetch parameter creator
 * @export
 */
export const ApiKeysApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     * Create a new API key for the authenticated user.
     * @summary Create API Key
     * @param {CreateApiKeyRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApiKey(body: CreateApiKeyRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createApiKey.',
        );
      }
      const localVarPath = `/v1/orgs/self/users/self/apikeys`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'CreateApiKeyRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new API key for any user in your organization. Accessible to Admin users only.
     * @summary Create API Key (any user)
     * @param {CreateApiKeyRequest} body JSON object
     * @param {string} user user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApiKeyAdmin(body: CreateApiKeyRequest, user: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createApiKeyAdmin.',
        );
      }
      // verify required parameter 'user' is not null or undefined
      if (user === null || user === undefined) {
        throw new RequiredError(
          'user',
          'Required parameter user was null or undefined when calling createApiKeyAdmin.',
        );
      }
      const localVarPath = `/v1/orgs/self/users/{user}/apikeys`.replace(
        `{${'user'}}`,
        encodeURIComponent(String(user)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'CreateApiKeyRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete an API key for the authenticated user.
     * @summary Delete API Key
     * @param {string} name name of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApiKey(name: string, options: any = {}): FetchArgs {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          'name',
          'Required parameter name was null or undefined when calling deleteApiKey.',
        );
      }
      const localVarPath = `/v1/orgs/self/users/self/apikeys/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete an API key for any user in your organization. Accessible to Admin users only.
     * @summary Delete API Key (any user)
     * @param {string} name name of the API key
     * @param {string} user user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApiKeyAdmin(name: string, user: string, options: any = {}): FetchArgs {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          'name',
          'Required parameter name was null or undefined when calling deleteApiKeyAdmin.',
        );
      }
      // verify required parameter 'user' is not null or undefined
      if (user === null || user === undefined) {
        throw new RequiredError(
          'user',
          'Required parameter user was null or undefined when calling deleteApiKeyAdmin.',
        );
      }
      const localVarPath = `/v1/orgs/self/users/{user}/apikeys/{name}`
        .replace(`{${'name'}}`, encodeURIComponent(String(name)))
        .replace(`{${'user'}}`, encodeURIComponent(String(user)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List all API keys for the authenticated user.
     * @summary List API Keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listApiKeys(options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self/users/self/apikeys`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List all API keys for any user in your organization. Accessible to Admin users only.
     * @summary List API Keys (any user)
     * @param {string} user user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listApiKeysAdmin(user: string, options: any = {}): FetchArgs {
      // verify required parameter 'user' is not null or undefined
      if (user === null || user === undefined) {
        throw new RequiredError(
          'user',
          'Required parameter user was null or undefined when calling listApiKeysAdmin.',
        );
      }
      const localVarPath = `/v1/orgs/self/users/{user}/apikeys`.replace(
        `{${'user'}}`,
        encodeURIComponent(String(user)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ApiKeysApi - functional programming interface
 * @export
 */
export const ApiKeysApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Create a new API key for the authenticated user.
     * @summary Create API Key
     * @param {CreateApiKeyRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApiKey(
      body: CreateApiKeyRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CreateApiKeyResponse> {
      const localVarFetchArgs = ApiKeysApiFetchParamCreator(configuration).createApiKey(
        body,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Create a new API key for any user in your organization. Accessible to Admin users only.
     * @summary Create API Key (any user)
     * @param {CreateApiKeyRequest} body JSON object
     * @param {string} user user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApiKeyAdmin(
      body: CreateApiKeyRequest,
      user: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CreateApiKeyResponse> {
      const localVarFetchArgs = ApiKeysApiFetchParamCreator(configuration).createApiKeyAdmin(
        body,
        user,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Delete an API key for the authenticated user.
     * @summary Delete API Key
     * @param {string} name name of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApiKey(
      name: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteApiKeyResponse> {
      const localVarFetchArgs = ApiKeysApiFetchParamCreator(configuration).deleteApiKey(
        name,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Delete an API key for any user in your organization. Accessible to Admin users only.
     * @summary Delete API Key (any user)
     * @param {string} name name of the API key
     * @param {string} user user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApiKeyAdmin(
      name: string,
      user: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteApiKeyResponse> {
      const localVarFetchArgs = ApiKeysApiFetchParamCreator(configuration).deleteApiKeyAdmin(
        name,
        user,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * List all API keys for the authenticated user.
     * @summary List API Keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listApiKeys(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ListApiKeysResponse> {
      const localVarFetchArgs = ApiKeysApiFetchParamCreator(configuration).listApiKeys(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * List all API keys for any user in your organization. Accessible to Admin users only.
     * @summary List API Keys (any user)
     * @param {string} user user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listApiKeysAdmin(
      user: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ListApiKeysResponse> {
      const localVarFetchArgs = ApiKeysApiFetchParamCreator(configuration).listApiKeysAdmin(
        user,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * ApiKeysApi - factory interface
 * @export
 */
export const ApiKeysApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Create a new API key for the authenticated user.
     * @summary Create API Key
     * @param {CreateApiKeyRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApiKey(body: CreateApiKeyRequest, options?: any) {
      return ApiKeysApiFp(configuration).createApiKey(body, options)(fetch, basePath);
    },
    /**
     * Create a new API key for any user in your organization. Accessible to Admin users only.
     * @summary Create API Key (any user)
     * @param {CreateApiKeyRequest} body JSON object
     * @param {string} user user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApiKeyAdmin(body: CreateApiKeyRequest, user: string, options?: any) {
      return ApiKeysApiFp(configuration).createApiKeyAdmin(body, user, options)(fetch, basePath);
    },
    /**
     * Delete an API key for the authenticated user.
     * @summary Delete API Key
     * @param {string} name name of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApiKey(name: string, options?: any) {
      return ApiKeysApiFp(configuration).deleteApiKey(name, options)(fetch, basePath);
    },
    /**
     * Delete an API key for any user in your organization. Accessible to Admin users only.
     * @summary Delete API Key (any user)
     * @param {string} name name of the API key
     * @param {string} user user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApiKeyAdmin(name: string, user: string, options?: any) {
      return ApiKeysApiFp(configuration).deleteApiKeyAdmin(name, user, options)(fetch, basePath);
    },
    /**
     * List all API keys for the authenticated user.
     * @summary List API Keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listApiKeys(options?: any) {
      return ApiKeysApiFp(configuration).listApiKeys(options)(fetch, basePath);
    },
    /**
     * List all API keys for any user in your organization. Accessible to Admin users only.
     * @summary List API Keys (any user)
     * @param {string} user user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listApiKeysAdmin(user: string, options?: any) {
      return ApiKeysApiFp(configuration).listApiKeysAdmin(user, options)(fetch, basePath);
    },
  };
};

/**
 * ApiKeysApi - object-oriented interface
 * @export
 * @class ApiKeysApi
 * @extends {BaseAPI}
 */
export class ApiKeysApi extends BaseAPI {
  /**
   * Create a new API key for the authenticated user.
   * @summary Create API Key
   * @param {CreateApiKeyRequest} body JSON object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiKeysApi
   */
  public createApiKey(body: CreateApiKeyRequest, options?: any) {
    return ApiKeysApiFp(this.configuration).createApiKey(body, options)(this.fetch, this.basePath);
  }

  /**
   * Create a new API key for any user in your organization. Accessible to Admin users only.
   * @summary Create API Key (any user)
   * @param {CreateApiKeyRequest} body JSON object
   * @param {string} user user email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiKeysApi
   */
  public createApiKeyAdmin(body: CreateApiKeyRequest, user: string, options?: any) {
    return ApiKeysApiFp(this.configuration).createApiKeyAdmin(body, user, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Delete an API key for the authenticated user.
   * @summary Delete API Key
   * @param {string} name name of the API key
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiKeysApi
   */
  public deleteApiKey(name: string, options?: any) {
    return ApiKeysApiFp(this.configuration).deleteApiKey(name, options)(this.fetch, this.basePath);
  }

  /**
   * Delete an API key for any user in your organization. Accessible to Admin users only.
   * @summary Delete API Key (any user)
   * @param {string} name name of the API key
   * @param {string} user user email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiKeysApi
   */
  public deleteApiKeyAdmin(name: string, user: string, options?: any) {
    return ApiKeysApiFp(this.configuration).deleteApiKeyAdmin(name, user, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * List all API keys for the authenticated user.
   * @summary List API Keys
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiKeysApi
   */
  public listApiKeys(options?: any) {
    return ApiKeysApiFp(this.configuration).listApiKeys(options)(this.fetch, this.basePath);
  }

  /**
   * List all API keys for any user in your organization. Accessible to Admin users only.
   * @summary List API Keys (any user)
   * @param {string} user user email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiKeysApi
   */
  public listApiKeysAdmin(user: string, options?: any) {
    return ApiKeysApiFp(this.configuration).listApiKeysAdmin(user, options)(
      this.fetch,
      this.basePath,
    );
  }
}

/**
 * CollectionsApi - fetch parameter creator
 * @export
 */
export const CollectionsApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     * Create new collection in a workspace.
     * @summary Create Collection
     * @param {string} workspace name of the workspace
     * @param {CreateCollectionRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCollection(
      workspace: string,
      body: CreateCollectionRequest,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling createCollection.',
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createCollection.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/collections`.replace(
        `{${'workspace'}}`,
        encodeURIComponent(String(workspace)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'CreateCollectionRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create an ephemeral source (expires after 24h) to perform preview on.
     * @summary Create Preview Source
     * @param {CreatePreviewSourceRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPreviewSource(body: CreatePreviewSourceRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createPreviewSource.',
        );
      }
      const localVarPath = `/v1/orgs/self/collections/previews/sources`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'CreatePreviewSourceRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a collection and all its documents from Rockset.
     * @summary Delete Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCollection(workspace: string, collection: string, options: any = {}): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling deleteCollection.',
        );
      }
      // verify required parameter 'collection' is not null or undefined
      if (collection === null || collection === undefined) {
        throw new RequiredError(
          'collection',
          'Required parameter collection was null or undefined when calling deleteCollection.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}`
        .replace(`{${'workspace'}}`, encodeURIComponent(String(workspace)))
        .replace(`{${'collection'}}`, encodeURIComponent(String(collection)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get details about a collection.
     * @summary Get Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollection(workspace: string, collection: string, options: any = {}): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling getCollection.',
        );
      }
      // verify required parameter 'collection' is not null or undefined
      if (collection === null || collection === undefined) {
        throw new RequiredError(
          'collection',
          'Required parameter collection was null or undefined when calling getCollection.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}`
        .replace(`{${'workspace'}}`, encodeURIComponent(String(workspace)))
        .replace(`{${'collection'}}`, encodeURIComponent(String(collection)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get samples for a collection in Rockset.
     * @summary Get Collection Samples
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSamples(workspace: string, collection: string, options: any = {}): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling getSamples.',
        );
      }
      // verify required parameter 'collection' is not null or undefined
      if (collection === null || collection === undefined) {
        throw new RequiredError(
          'collection',
          'Required parameter collection was null or undefined when calling getSamples.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/samples`
        .replace(`{${'workspace'}}`, encodeURIComponent(String(workspace)))
        .replace(`{${'collection'}}`, encodeURIComponent(String(collection)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get schema for a collection in Rockset.
     * @summary Get Collection Schema
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {number} [depth] max nested depth level to search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSchema(workspace: string, collection: string, depth?: number, options: any = {}): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling getSchema.',
        );
      }
      // verify required parameter 'collection' is not null or undefined
      if (collection === null || collection === undefined) {
        throw new RequiredError(
          'collection',
          'Required parameter collection was null or undefined when calling getSchema.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/schema`
        .replace(`{${'workspace'}}`, encodeURIComponent(String(workspace)))
        .replace(`{${'collection'}}`, encodeURIComponent(String(collection)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (depth !== undefined) {
        localVarQueryParameter['depth'] = depth;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve information about source.
     * @summary Get Source config
     * @param {SourceConfigRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSourceConfigs(body: SourceConfigRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling getSourceConfigs.',
        );
      }
      const localVarPath = `/v1/orgs/self/collections/configs`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'SourceConfigRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all Aliases for a specific Rockset Collection.
     * @summary Get Aliases for Collection
     * @param {string} workspace
     * @param {string} collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAliasesForCollection(workspace: string, collection: string, options: any = {}): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling listAliasesForCollection.',
        );
      }
      // verify required parameter 'collection' is not null or undefined
      if (collection === null || collection === undefined) {
        throw new RequiredError(
          'collection',
          'Required parameter collection was null or undefined when calling listAliasesForCollection.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/aliases`
        .replace(`{${'workspace'}}`, encodeURIComponent(String(workspace)))
        .replace(`{${'collection'}}`, encodeURIComponent(String(collection)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve all collections in an organization.
     * @summary List Collections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCollections(options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self/collections`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all Query Lambdas that hit a specific Rockset Collection.
     * @summary Get Query Lambdas for Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listQueryLambdasInCollection(
      workspace: string,
      collection: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling listQueryLambdasInCollection.',
        );
      }
      // verify required parameter 'collection' is not null or undefined
      if (collection === null || collection === undefined) {
        throw new RequiredError(
          'collection',
          'Required parameter collection was null or undefined when calling listQueryLambdasInCollection.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/lambdas`
        .replace(`{${'workspace'}}`, encodeURIComponent(String(workspace)))
        .replace(`{${'collection'}}`, encodeURIComponent(String(collection)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get sample documents given collection configuration.
     * @summary Preview Collection
     * @param {PreviewCollectionRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    previewCollection(body: PreviewCollectionRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling previewCollection.',
        );
      }
      const localVarPath = `/v1/orgs/self/collections/previews`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'PreviewCollectionRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update state of a collection.
     * @summary Update state of Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {'READY' | 'PAUSED'} state new state of this collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setCollectionState(
      workspace: string,
      collection: string,
      state: 'READY' | 'PAUSED',
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling setCollectionState.',
        );
      }
      // verify required parameter 'collection' is not null or undefined
      if (collection === null || collection === undefined) {
        throw new RequiredError(
          'collection',
          'Required parameter collection was null or undefined when calling setCollectionState.',
        );
      }
      // verify required parameter 'state' is not null or undefined
      if (state === null || state === undefined) {
        throw new RequiredError(
          'state',
          'Required parameter state was null or undefined when calling setCollectionState.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/state/{state}`
        .replace(`{${'workspace'}}`, encodeURIComponent(String(workspace)))
        .replace(`{${'collection'}}`, encodeURIComponent(String(collection)))
        .replace(`{${'state'}}`, encodeURIComponent(String(state)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Upload a file to a collection in Rockset.
     * @summary Upload a file
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {InputStream} body file input stream
     * @param {FormDataContentDisposition} body2 file metadata
     * @param {FormDataBodyPart} [body3] file format params
     * @param {string} [body4] file size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile(
      workspace: string,
      collection: string,
      body: InputStream,
      body2: FormDataContentDisposition,
      body3?: FormDataBodyPart,
      body4?: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling uploadFile.',
        );
      }
      // verify required parameter 'collection' is not null or undefined
      if (collection === null || collection === undefined) {
        throw new RequiredError(
          'collection',
          'Required parameter collection was null or undefined when calling uploadFile.',
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling uploadFile.',
        );
      }
      // verify required parameter 'body2' is not null or undefined
      if (body2 === null || body2 === undefined) {
        throw new RequiredError(
          'body2',
          'Required parameter body2 was null or undefined when calling uploadFile.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/uploads`
        .replace(`{${'workspace'}}`, encodeURIComponent(String(workspace)))
        .replace(`{${'collection'}}`, encodeURIComponent(String(collection)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'string' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body4 || {}) : body4 || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Upload a file to a preview source that can be used to generate preview docs
     * @summary Upload File to Preview Source
     * @param {string} preview_source_id preview source identifier
     * @param {InputStream} body file input stream
     * @param {FormDataContentDisposition} body2 file metadata
     * @param {string} [body3] file size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFilePreviewSource(
      preview_source_id: string,
      body: InputStream,
      body2: FormDataContentDisposition,
      body3?: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'preview_source_id' is not null or undefined
      if (preview_source_id === null || preview_source_id === undefined) {
        throw new RequiredError(
          'preview_source_id',
          'Required parameter preview_source_id was null or undefined when calling uploadFilePreviewSource.',
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling uploadFilePreviewSource.',
        );
      }
      // verify required parameter 'body2' is not null or undefined
      if (body2 === null || body2 === undefined) {
        throw new RequiredError(
          'body2',
          'Required parameter body2 was null or undefined when calling uploadFilePreviewSource.',
        );
      }
      const localVarPath = `/v1/orgs/self/collections/previews/sources/{preview_source_id}/uploads`.replace(
        `{${'preview_source_id'}}`,
        encodeURIComponent(String(preview_source_id)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'string' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body3 || {}) : body3 || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve all collections in a workspace.
     * @summary List Collections for Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspaceCollections(workspace: string, options: any = {}): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling workspaceCollections.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/collections`.replace(
        `{${'workspace'}}`,
        encodeURIComponent(String(workspace)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CollectionsApi - functional programming interface
 * @export
 */
export const CollectionsApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Create new collection in a workspace.
     * @summary Create Collection
     * @param {string} workspace name of the workspace
     * @param {CreateCollectionRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCollection(
      workspace: string,
      body: CreateCollectionRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CreateCollectionResponse> {
      const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).createCollection(
        workspace,
        body,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Create an ephemeral source (expires after 24h) to perform preview on.
     * @summary Create Preview Source
     * @param {CreatePreviewSourceRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPreviewSource(
      body: CreatePreviewSourceRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CreatePreviewSourceResponse> {
      const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).createPreviewSource(
        body,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Delete a collection and all its documents from Rockset.
     * @summary Delete Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCollection(
      workspace: string,
      collection: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteCollectionResponse> {
      const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).deleteCollection(
        workspace,
        collection,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get details about a collection.
     * @summary Get Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollection(
      workspace: string,
      collection: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<GetCollectionResponse> {
      const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).getCollection(
        workspace,
        collection,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get samples for a collection in Rockset.
     * @summary Get Collection Samples
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSamples(
      workspace: string,
      collection: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<QueryResponse> {
      const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).getSamples(
        workspace,
        collection,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get schema for a collection in Rockset.
     * @summary Get Collection Schema
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {number} [depth] max nested depth level to search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSchema(
      workspace: string,
      collection: string,
      depth?: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<QueryResponse> {
      const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).getSchema(
        workspace,
        collection,
        depth,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieve information about source.
     * @summary Get Source config
     * @param {SourceConfigRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSourceConfigs(
      body: SourceConfigRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<SourceConfigResponse> {
      const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).getSourceConfigs(
        body,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get all Aliases for a specific Rockset Collection.
     * @summary Get Aliases for Collection
     * @param {string} workspace
     * @param {string} collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAliasesForCollection(
      workspace: string,
      collection: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ListAliasesResponse> {
      const localVarFetchArgs = CollectionsApiFetchParamCreator(
        configuration,
      ).listAliasesForCollection(workspace, collection, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieve all collections in an organization.
     * @summary List Collections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCollections(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ListCollectionsResponse> {
      const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).listCollections(
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get all Query Lambdas that hit a specific Rockset Collection.
     * @summary Get Query Lambdas for Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listQueryLambdasInCollection(
      workspace: string,
      collection: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueryLambdaVersionsResponse> {
      const localVarFetchArgs = CollectionsApiFetchParamCreator(
        configuration,
      ).listQueryLambdasInCollection(workspace, collection, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get sample documents given collection configuration.
     * @summary Preview Collection
     * @param {PreviewCollectionRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    previewCollection(
      body: PreviewCollectionRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<PreviewCollectionResponse> {
      const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).previewCollection(
        body,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Update state of a collection.
     * @summary Update state of Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {'READY' | 'PAUSED'} state new state of this collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setCollectionState(
      workspace: string,
      collection: string,
      state: 'READY' | 'PAUSED',
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<GetCollectionResponse> {
      const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).setCollectionState(
        workspace,
        collection,
        state,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Upload a file to a collection in Rockset.
     * @summary Upload a file
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {InputStream} body file input stream
     * @param {FormDataContentDisposition} body2 file metadata
     * @param {FormDataBodyPart} [body3] file format params
     * @param {string} [body4] file size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile(
      workspace: string,
      collection: string,
      body: InputStream,
      body2: FormDataContentDisposition,
      body3?: FormDataBodyPart,
      body4?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UploadFileResponse> {
      const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).uploadFile(
        workspace,
        collection,
        body,
        body2,
        body3,
        body4,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Upload a file to a preview source that can be used to generate preview docs
     * @summary Upload File to Preview Source
     * @param {string} preview_source_id preview source identifier
     * @param {InputStream} body file input stream
     * @param {FormDataContentDisposition} body2 file metadata
     * @param {string} [body3] file size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFilePreviewSource(
      preview_source_id: string,
      body: InputStream,
      body2: FormDataContentDisposition,
      body3?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UploadFileResponse> {
      const localVarFetchArgs = CollectionsApiFetchParamCreator(
        configuration,
      ).uploadFilePreviewSource(preview_source_id, body, body2, body3, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieve all collections in a workspace.
     * @summary List Collections for Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspaceCollections(
      workspace: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ListCollectionsResponse> {
      const localVarFetchArgs = CollectionsApiFetchParamCreator(configuration).workspaceCollections(
        workspace,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * CollectionsApi - factory interface
 * @export
 */
export const CollectionsApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Create new collection in a workspace.
     * @summary Create Collection
     * @param {string} workspace name of the workspace
     * @param {CreateCollectionRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCollection(workspace: string, body: CreateCollectionRequest, options?: any) {
      return CollectionsApiFp(configuration).createCollection(workspace, body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Create an ephemeral source (expires after 24h) to perform preview on.
     * @summary Create Preview Source
     * @param {CreatePreviewSourceRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPreviewSource(body: CreatePreviewSourceRequest, options?: any) {
      return CollectionsApiFp(configuration).createPreviewSource(body, options)(fetch, basePath);
    },
    /**
     * Delete a collection and all its documents from Rockset.
     * @summary Delete Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCollection(workspace: string, collection: string, options?: any) {
      return CollectionsApiFp(configuration).deleteCollection(workspace, collection, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Get details about a collection.
     * @summary Get Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollection(workspace: string, collection: string, options?: any) {
      return CollectionsApiFp(configuration).getCollection(workspace, collection, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Get samples for a collection in Rockset.
     * @summary Get Collection Samples
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSamples(workspace: string, collection: string, options?: any) {
      return CollectionsApiFp(configuration).getSamples(workspace, collection, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Get schema for a collection in Rockset.
     * @summary Get Collection Schema
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {number} [depth] max nested depth level to search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSchema(workspace: string, collection: string, depth?: number, options?: any) {
      return CollectionsApiFp(configuration).getSchema(workspace, collection, depth, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Retrieve information about source.
     * @summary Get Source config
     * @param {SourceConfigRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSourceConfigs(body: SourceConfigRequest, options?: any) {
      return CollectionsApiFp(configuration).getSourceConfigs(body, options)(fetch, basePath);
    },
    /**
     * Get all Aliases for a specific Rockset Collection.
     * @summary Get Aliases for Collection
     * @param {string} workspace
     * @param {string} collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAliasesForCollection(workspace: string, collection: string, options?: any) {
      return CollectionsApiFp(configuration).listAliasesForCollection(
        workspace,
        collection,
        options,
      )(fetch, basePath);
    },
    /**
     * Retrieve all collections in an organization.
     * @summary List Collections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCollections(options?: any) {
      return CollectionsApiFp(configuration).listCollections(options)(fetch, basePath);
    },
    /**
     * Get all Query Lambdas that hit a specific Rockset Collection.
     * @summary Get Query Lambdas for Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listQueryLambdasInCollection(workspace: string, collection: string, options?: any) {
      return CollectionsApiFp(configuration).listQueryLambdasInCollection(
        workspace,
        collection,
        options,
      )(fetch, basePath);
    },
    /**
     * Get sample documents given collection configuration.
     * @summary Preview Collection
     * @param {PreviewCollectionRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    previewCollection(body: PreviewCollectionRequest, options?: any) {
      return CollectionsApiFp(configuration).previewCollection(body, options)(fetch, basePath);
    },
    /**
     * Update state of a collection.
     * @summary Update state of Collection
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {'READY' | 'PAUSED'} state new state of this collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setCollectionState(
      workspace: string,
      collection: string,
      state: 'READY' | 'PAUSED',
      options?: any,
    ) {
      return CollectionsApiFp(configuration).setCollectionState(
        workspace,
        collection,
        state,
        options,
      )(fetch, basePath);
    },
    /**
     * Upload a file to a collection in Rockset.
     * @summary Upload a file
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {InputStream} body file input stream
     * @param {FormDataContentDisposition} body2 file metadata
     * @param {FormDataBodyPart} [body3] file format params
     * @param {string} [body4] file size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFile(
      workspace: string,
      collection: string,
      body: InputStream,
      body2: FormDataContentDisposition,
      body3?: FormDataBodyPart,
      body4?: string,
      options?: any,
    ) {
      return CollectionsApiFp(configuration).uploadFile(
        workspace,
        collection,
        body,
        body2,
        body3,
        body4,
        options,
      )(fetch, basePath);
    },
    /**
     * Upload a file to a preview source that can be used to generate preview docs
     * @summary Upload File to Preview Source
     * @param {string} preview_source_id preview source identifier
     * @param {InputStream} body file input stream
     * @param {FormDataContentDisposition} body2 file metadata
     * @param {string} [body3] file size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadFilePreviewSource(
      preview_source_id: string,
      body: InputStream,
      body2: FormDataContentDisposition,
      body3?: string,
      options?: any,
    ) {
      return CollectionsApiFp(configuration).uploadFilePreviewSource(
        preview_source_id,
        body,
        body2,
        body3,
        options,
      )(fetch, basePath);
    },
    /**
     * Retrieve all collections in a workspace.
     * @summary List Collections for Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspaceCollections(workspace: string, options?: any) {
      return CollectionsApiFp(configuration).workspaceCollections(workspace, options)(
        fetch,
        basePath,
      );
    },
  };
};

/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
export class CollectionsApi extends BaseAPI {
  /**
   * Create new collection in a workspace.
   * @summary Create Collection
   * @param {string} workspace name of the workspace
   * @param {CreateCollectionRequest} body JSON object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollectionsApi
   */
  public createCollection(workspace: string, body: CreateCollectionRequest, options?: any) {
    return CollectionsApiFp(this.configuration).createCollection(workspace, body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Create an ephemeral source (expires after 24h) to perform preview on.
   * @summary Create Preview Source
   * @param {CreatePreviewSourceRequest} body JSON object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollectionsApi
   */
  public createPreviewSource(body: CreatePreviewSourceRequest, options?: any) {
    return CollectionsApiFp(this.configuration).createPreviewSource(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Delete a collection and all its documents from Rockset.
   * @summary Delete Collection
   * @param {string} workspace name of the workspace
   * @param {string} collection name of the collection
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollectionsApi
   */
  public deleteCollection(workspace: string, collection: string, options?: any) {
    return CollectionsApiFp(this.configuration).deleteCollection(workspace, collection, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Get details about a collection.
   * @summary Get Collection
   * @param {string} workspace name of the workspace
   * @param {string} collection name of the collection
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollectionsApi
   */
  public getCollection(workspace: string, collection: string, options?: any) {
    return CollectionsApiFp(this.configuration).getCollection(workspace, collection, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Get samples for a collection in Rockset.
   * @summary Get Collection Samples
   * @param {string} workspace name of the workspace
   * @param {string} collection name of the collection
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollectionsApi
   */
  public getSamples(workspace: string, collection: string, options?: any) {
    return CollectionsApiFp(this.configuration).getSamples(workspace, collection, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Get schema for a collection in Rockset.
   * @summary Get Collection Schema
   * @param {string} workspace name of the workspace
   * @param {string} collection name of the collection
   * @param {number} [depth] max nested depth level to search
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollectionsApi
   */
  public getSchema(workspace: string, collection: string, depth?: number, options?: any) {
    return CollectionsApiFp(this.configuration).getSchema(workspace, collection, depth, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Retrieve information about source.
   * @summary Get Source config
   * @param {SourceConfigRequest} body JSON object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollectionsApi
   */
  public getSourceConfigs(body: SourceConfigRequest, options?: any) {
    return CollectionsApiFp(this.configuration).getSourceConfigs(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Get all Aliases for a specific Rockset Collection.
   * @summary Get Aliases for Collection
   * @param {string} workspace
   * @param {string} collection
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollectionsApi
   */
  public listAliasesForCollection(workspace: string, collection: string, options?: any) {
    return CollectionsApiFp(this.configuration).listAliasesForCollection(
      workspace,
      collection,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Retrieve all collections in an organization.
   * @summary List Collections
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollectionsApi
   */
  public listCollections(options?: any) {
    return CollectionsApiFp(this.configuration).listCollections(options)(this.fetch, this.basePath);
  }

  /**
   * Get all Query Lambdas that hit a specific Rockset Collection.
   * @summary Get Query Lambdas for Collection
   * @param {string} workspace name of the workspace
   * @param {string} collection name of the collection
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollectionsApi
   */
  public listQueryLambdasInCollection(workspace: string, collection: string, options?: any) {
    return CollectionsApiFp(this.configuration).listQueryLambdasInCollection(
      workspace,
      collection,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Get sample documents given collection configuration.
   * @summary Preview Collection
   * @param {PreviewCollectionRequest} body JSON object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollectionsApi
   */
  public previewCollection(body: PreviewCollectionRequest, options?: any) {
    return CollectionsApiFp(this.configuration).previewCollection(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Update state of a collection.
   * @summary Update state of Collection
   * @param {string} workspace name of the workspace
   * @param {string} collection name of the collection
   * @param {'READY' | 'PAUSED'} state new state of this collection
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollectionsApi
   */
  public setCollectionState(
    workspace: string,
    collection: string,
    state: 'READY' | 'PAUSED',
    options?: any,
  ) {
    return CollectionsApiFp(this.configuration).setCollectionState(
      workspace,
      collection,
      state,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Upload a file to a collection in Rockset.
   * @summary Upload a file
   * @param {string} workspace name of the workspace
   * @param {string} collection name of the collection
   * @param {InputStream} body file input stream
   * @param {FormDataContentDisposition} body2 file metadata
   * @param {FormDataBodyPart} [body3] file format params
   * @param {string} [body4] file size
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollectionsApi
   */
  public uploadFile(
    workspace: string,
    collection: string,
    body: InputStream,
    body2: FormDataContentDisposition,
    body3?: FormDataBodyPart,
    body4?: string,
    options?: any,
  ) {
    return CollectionsApiFp(this.configuration).uploadFile(
      workspace,
      collection,
      body,
      body2,
      body3,
      body4,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Upload a file to a preview source that can be used to generate preview docs
   * @summary Upload File to Preview Source
   * @param {string} preview_source_id preview source identifier
   * @param {InputStream} body file input stream
   * @param {FormDataContentDisposition} body2 file metadata
   * @param {string} [body3] file size
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollectionsApi
   */
  public uploadFilePreviewSource(
    preview_source_id: string,
    body: InputStream,
    body2: FormDataContentDisposition,
    body3?: string,
    options?: any,
  ) {
    return CollectionsApiFp(this.configuration).uploadFilePreviewSource(
      preview_source_id,
      body,
      body2,
      body3,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Retrieve all collections in a workspace.
   * @summary List Collections for Workspace
   * @param {string} workspace name of the workspace
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CollectionsApi
   */
  public workspaceCollections(workspace: string, options?: any) {
    return CollectionsApiFp(this.configuration).workspaceCollections(workspace, options)(
      this.fetch,
      this.basePath,
    );
  }
}

/**
 * ConsoleApi - fetch parameter creator
 * @export
 */
export const ConsoleApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     * Send confirmation email to user, send email internally, and notify internally
     * @summary Contact Sales
     * @param {ContactSalesRequest} body contact sales information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contactSales(body: ContactSalesRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling contactSales.',
        );
      }
      const localVarPath = `/v1/console/sales`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'ContactSalesRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get list of all activity for user
     * @summary Get Activities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivity(options: any = {}): FetchArgs {
      const localVarPath = `/v1/console/activity`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Record an activity item from console.
     * @summary Record Activity
     * @param {RecordActivityRequest} body the activity item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recordActivity(body: RecordActivityRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling recordActivity.',
        );
      }
      const localVarPath = `/v1/console/activity`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'RecordActivityRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ConsoleApi - functional programming interface
 * @export
 */
export const ConsoleApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Send confirmation email to user, send email internally, and notify internally
     * @summary Contact Sales
     * @param {ContactSalesRequest} body contact sales information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contactSales(
      body: ContactSalesRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<StatusResponse> {
      const localVarFetchArgs = ConsoleApiFetchParamCreator(configuration).contactSales(
        body,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get list of all activity for user
     * @summary Get Activities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivity(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<GetActivityResponse> {
      const localVarFetchArgs = ConsoleApiFetchParamCreator(configuration).getActivity(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Record an activity item from console.
     * @summary Record Activity
     * @param {RecordActivityRequest} body the activity item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recordActivity(
      body: RecordActivityRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<StatusResponse> {
      const localVarFetchArgs = ConsoleApiFetchParamCreator(configuration).recordActivity(
        body,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * ConsoleApi - factory interface
 * @export
 */
export const ConsoleApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Send confirmation email to user, send email internally, and notify internally
     * @summary Contact Sales
     * @param {ContactSalesRequest} body contact sales information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contactSales(body: ContactSalesRequest, options?: any) {
      return ConsoleApiFp(configuration).contactSales(body, options)(fetch, basePath);
    },
    /**
     * Get list of all activity for user
     * @summary Get Activities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivity(options?: any) {
      return ConsoleApiFp(configuration).getActivity(options)(fetch, basePath);
    },
    /**
     * Record an activity item from console.
     * @summary Record Activity
     * @param {RecordActivityRequest} body the activity item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recordActivity(body: RecordActivityRequest, options?: any) {
      return ConsoleApiFp(configuration).recordActivity(body, options)(fetch, basePath);
    },
  };
};

/**
 * ConsoleApi - object-oriented interface
 * @export
 * @class ConsoleApi
 * @extends {BaseAPI}
 */
export class ConsoleApi extends BaseAPI {
  /**
   * Send confirmation email to user, send email internally, and notify internally
   * @summary Contact Sales
   * @param {ContactSalesRequest} body contact sales information
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConsoleApi
   */
  public contactSales(body: ContactSalesRequest, options?: any) {
    return ConsoleApiFp(this.configuration).contactSales(body, options)(this.fetch, this.basePath);
  }

  /**
   * Get list of all activity for user
   * @summary Get Activities
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConsoleApi
   */
  public getActivity(options?: any) {
    return ConsoleApiFp(this.configuration).getActivity(options)(this.fetch, this.basePath);
  }

  /**
   * Record an activity item from console.
   * @summary Record Activity
   * @param {RecordActivityRequest} body the activity item
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConsoleApi
   */
  public recordActivity(body: RecordActivityRequest, options?: any) {
    return ConsoleApiFp(this.configuration).recordActivity(body, options)(
      this.fetch,
      this.basePath,
    );
  }
}

/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    receiveKafkaEvent(options: any = {}): FetchArgs {
      const localVarPath = `/v1/receivers/kafka`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    receiveSegmentEvent(options: any = {}): FetchArgs {
      const localVarPath = `/v1/receivers/segment`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    receiveKafkaEvent(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).receiveKafkaEvent(
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    receiveSegmentEvent(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).receiveSegmentEvent(
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    receiveKafkaEvent(options?: any) {
      return DefaultApiFp(configuration).receiveKafkaEvent(options)(fetch, basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    receiveSegmentEvent(options?: any) {
      return DefaultApiFp(configuration).receiveSegmentEvent(options)(fetch, basePath);
    },
  };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public receiveKafkaEvent(options?: any) {
    return DefaultApiFp(this.configuration).receiveKafkaEvent(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public receiveSegmentEvent(options?: any) {
    return DefaultApiFp(this.configuration).receiveSegmentEvent(options)(this.fetch, this.basePath);
  }
}

/**
 * DocumentsApi - fetch parameter creator
 * @export
 */
export const DocumentsApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     * Add documents to a collection.
     * @summary Add Documents
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {AddDocumentsRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addDocuments(
      workspace: string,
      collection: string,
      body: AddDocumentsRequest,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling addDocuments.',
        );
      }
      // verify required parameter 'collection' is not null or undefined
      if (collection === null || collection === undefined) {
        throw new RequiredError(
          'collection',
          'Required parameter collection was null or undefined when calling addDocuments.',
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling addDocuments.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/docs`
        .replace(`{${'workspace'}}`, encodeURIComponent(String(workspace)))
        .replace(`{${'collection'}}`, encodeURIComponent(String(collection)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'AddDocumentsRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete documents from a collection.
     * @summary Delete Documents
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {DeleteDocumentsRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDocuments(
      workspace: string,
      collection: string,
      body: DeleteDocumentsRequest,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling deleteDocuments.',
        );
      }
      // verify required parameter 'collection' is not null or undefined
      if (collection === null || collection === undefined) {
        throw new RequiredError(
          'collection',
          'Required parameter collection was null or undefined when calling deleteDocuments.',
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling deleteDocuments.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/docs`
        .replace(`{${'workspace'}}`, encodeURIComponent(String(workspace)))
        .replace(`{${'collection'}}`, encodeURIComponent(String(collection)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'DeleteDocumentsRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update existing documents in a collection.
     * @summary Patch Documents
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {PatchDocumentsRequest} body JSON Patch objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchDocuments(
      workspace: string,
      collection: string,
      body: PatchDocumentsRequest,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling patchDocuments.',
        );
      }
      // verify required parameter 'collection' is not null or undefined
      if (collection === null || collection === undefined) {
        throw new RequiredError(
          'collection',
          'Required parameter collection was null or undefined when calling patchDocuments.',
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling patchDocuments.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/collections/{collection}/docs`
        .replace(`{${'workspace'}}`, encodeURIComponent(String(workspace)))
        .replace(`{${'collection'}}`, encodeURIComponent(String(collection)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'PatchDocumentsRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DocumentsApi - functional programming interface
 * @export
 */
export const DocumentsApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Add documents to a collection.
     * @summary Add Documents
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {AddDocumentsRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addDocuments(
      workspace: string,
      collection: string,
      body: AddDocumentsRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AddDocumentsResponse> {
      const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).addDocuments(
        workspace,
        collection,
        body,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Delete documents from a collection.
     * @summary Delete Documents
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {DeleteDocumentsRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDocuments(
      workspace: string,
      collection: string,
      body: DeleteDocumentsRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteDocumentsResponse> {
      const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).deleteDocuments(
        workspace,
        collection,
        body,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Update existing documents in a collection.
     * @summary Patch Documents
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {PatchDocumentsRequest} body JSON Patch objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchDocuments(
      workspace: string,
      collection: string,
      body: PatchDocumentsRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<PatchDocumentsResponse> {
      const localVarFetchArgs = DocumentsApiFetchParamCreator(configuration).patchDocuments(
        workspace,
        collection,
        body,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * DocumentsApi - factory interface
 * @export
 */
export const DocumentsApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Add documents to a collection.
     * @summary Add Documents
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {AddDocumentsRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addDocuments(workspace: string, collection: string, body: AddDocumentsRequest, options?: any) {
      return DocumentsApiFp(configuration).addDocuments(workspace, collection, body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Delete documents from a collection.
     * @summary Delete Documents
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {DeleteDocumentsRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDocuments(
      workspace: string,
      collection: string,
      body: DeleteDocumentsRequest,
      options?: any,
    ) {
      return DocumentsApiFp(configuration).deleteDocuments(workspace, collection, body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Update existing documents in a collection.
     * @summary Patch Documents
     * @param {string} workspace name of the workspace
     * @param {string} collection name of the collection
     * @param {PatchDocumentsRequest} body JSON Patch objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchDocuments(
      workspace: string,
      collection: string,
      body: PatchDocumentsRequest,
      options?: any,
    ) {
      return DocumentsApiFp(configuration).patchDocuments(workspace, collection, body, options)(
        fetch,
        basePath,
      );
    },
  };
};

/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export class DocumentsApi extends BaseAPI {
  /**
   * Add documents to a collection.
   * @summary Add Documents
   * @param {string} workspace name of the workspace
   * @param {string} collection name of the collection
   * @param {AddDocumentsRequest} body JSON object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentsApi
   */
  public addDocuments(
    workspace: string,
    collection: string,
    body: AddDocumentsRequest,
    options?: any,
  ) {
    return DocumentsApiFp(this.configuration).addDocuments(workspace, collection, body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Delete documents from a collection.
   * @summary Delete Documents
   * @param {string} workspace name of the workspace
   * @param {string} collection name of the collection
   * @param {DeleteDocumentsRequest} body JSON object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentsApi
   */
  public deleteDocuments(
    workspace: string,
    collection: string,
    body: DeleteDocumentsRequest,
    options?: any,
  ) {
    return DocumentsApiFp(this.configuration).deleteDocuments(workspace, collection, body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Update existing documents in a collection.
   * @summary Patch Documents
   * @param {string} workspace name of the workspace
   * @param {string} collection name of the collection
   * @param {PatchDocumentsRequest} body JSON Patch objects
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentsApi
   */
  public patchDocuments(
    workspace: string,
    collection: string,
    body: PatchDocumentsRequest,
    options?: any,
  ) {
    return DocumentsApiFp(this.configuration).patchDocuments(workspace, collection, body, options)(
      this.fetch,
      this.basePath,
    );
  }
}

/**
 * IntegrationsApi - fetch parameter creator
 * @export
 */
export const IntegrationsApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     * Create a new integration.
     * @summary Create Integration
     * @param {CreateIntegrationRequest} body integration credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createIntegration(body: CreateIntegrationRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createIntegration.',
        );
      }
      const localVarPath = `/v1/orgs/self/integrations`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'CreateIntegrationRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Remove an integration.
     * @summary Delete Integration
     * @param {string} integration name of the integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteIntegration(integration: string, options: any = {}): FetchArgs {
      // verify required parameter 'integration' is not null or undefined
      if (integration === null || integration === undefined) {
        throw new RequiredError(
          'integration',
          'Required parameter integration was null or undefined when calling deleteIntegration.',
        );
      }
      const localVarPath = `/v1/orgs/self/integrations/{integration}`.replace(
        `{${'integration'}}`,
        encodeURIComponent(String(integration)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get information about a single integration.
     * @summary Get Integration
     * @param {string} integration name of the integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIntegration(integration: string, options: any = {}): FetchArgs {
      // verify required parameter 'integration' is not null or undefined
      if (integration === null || integration === undefined) {
        throw new RequiredError(
          'integration',
          'Required parameter integration was null or undefined when calling getIntegration.',
        );
      }
      const localVarPath = `/v1/orgs/self/integrations/{integration}`.replace(
        `{${'integration'}}`,
        encodeURIComponent(String(integration)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List all integrations in an organization.
     * @summary List Integrations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listIntegrations(options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self/integrations`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Verify that an integration is healthy.
     * @summary Verify Integration
     * @param {string} integration name of the integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyIntegration(integration: string, options: any = {}): FetchArgs {
      // verify required parameter 'integration' is not null or undefined
      if (integration === null || integration === undefined) {
        throw new RequiredError(
          'integration',
          'Required parameter integration was null or undefined when calling verifyIntegration.',
        );
      }
      const localVarPath = `/v1/orgs/self/integrations/{integration}/verifications`.replace(
        `{${'integration'}}`,
        encodeURIComponent(String(integration)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * IntegrationsApi - functional programming interface
 * @export
 */
export const IntegrationsApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Create a new integration.
     * @summary Create Integration
     * @param {CreateIntegrationRequest} body integration credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createIntegration(
      body: CreateIntegrationRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CreateIntegrationResponse> {
      const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).createIntegration(
        body,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Remove an integration.
     * @summary Delete Integration
     * @param {string} integration name of the integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteIntegration(
      integration: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteIntegrationResponse> {
      const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).deleteIntegration(
        integration,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get information about a single integration.
     * @summary Get Integration
     * @param {string} integration name of the integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIntegration(
      integration: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<GetIntegrationResponse> {
      const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).getIntegration(
        integration,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * List all integrations in an organization.
     * @summary List Integrations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listIntegrations(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ListIntegrationsResponse> {
      const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).listIntegrations(
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Verify that an integration is healthy.
     * @summary Verify Integration
     * @param {string} integration name of the integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyIntegration(
      integration: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<StatusResponse> {
      const localVarFetchArgs = IntegrationsApiFetchParamCreator(configuration).verifyIntegration(
        integration,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * IntegrationsApi - factory interface
 * @export
 */
export const IntegrationsApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Create a new integration.
     * @summary Create Integration
     * @param {CreateIntegrationRequest} body integration credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createIntegration(body: CreateIntegrationRequest, options?: any) {
      return IntegrationsApiFp(configuration).createIntegration(body, options)(fetch, basePath);
    },
    /**
     * Remove an integration.
     * @summary Delete Integration
     * @param {string} integration name of the integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteIntegration(integration: string, options?: any) {
      return IntegrationsApiFp(configuration).deleteIntegration(integration, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Get information about a single integration.
     * @summary Get Integration
     * @param {string} integration name of the integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIntegration(integration: string, options?: any) {
      return IntegrationsApiFp(configuration).getIntegration(integration, options)(fetch, basePath);
    },
    /**
     * List all integrations in an organization.
     * @summary List Integrations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listIntegrations(options?: any) {
      return IntegrationsApiFp(configuration).listIntegrations(options)(fetch, basePath);
    },
    /**
     * Verify that an integration is healthy.
     * @summary Verify Integration
     * @param {string} integration name of the integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyIntegration(integration: string, options?: any) {
      return IntegrationsApiFp(configuration).verifyIntegration(integration, options)(
        fetch,
        basePath,
      );
    },
  };
};

/**
 * IntegrationsApi - object-oriented interface
 * @export
 * @class IntegrationsApi
 * @extends {BaseAPI}
 */
export class IntegrationsApi extends BaseAPI {
  /**
   * Create a new integration.
   * @summary Create Integration
   * @param {CreateIntegrationRequest} body integration credentials
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IntegrationsApi
   */
  public createIntegration(body: CreateIntegrationRequest, options?: any) {
    return IntegrationsApiFp(this.configuration).createIntegration(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Remove an integration.
   * @summary Delete Integration
   * @param {string} integration name of the integration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IntegrationsApi
   */
  public deleteIntegration(integration: string, options?: any) {
    return IntegrationsApiFp(this.configuration).deleteIntegration(integration, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Get information about a single integration.
   * @summary Get Integration
   * @param {string} integration name of the integration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IntegrationsApi
   */
  public getIntegration(integration: string, options?: any) {
    return IntegrationsApiFp(this.configuration).getIntegration(integration, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * List all integrations in an organization.
   * @summary List Integrations
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IntegrationsApi
   */
  public listIntegrations(options?: any) {
    return IntegrationsApiFp(this.configuration).listIntegrations(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Verify that an integration is healthy.
   * @summary Verify Integration
   * @param {string} integration name of the integration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IntegrationsApi
   */
  public verifyIntegration(integration: string, options?: any) {
    return IntegrationsApiFp(this.configuration).verifyIntegration(integration, options)(
      this.fetch,
      this.basePath,
    );
  }
}

/**
 * OrganizationsApi - fetch parameter creator
 * @export
 */
export const OrganizationsApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     * Retrieve information about current organization.
     * @summary Get Organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganization(options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve usage levels for current organization.
     * @summary Get Organization Compute Time-Series data
     * @param {string} [month]
     * @param {string} [year]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationCompute(month?: string, year?: string, options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self/usage/compute`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (month !== undefined) {
        localVarQueryParameter['month'] = month;
      }

      if (year !== undefined) {
        localVarQueryParameter['year'] = year;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve usage levels for current organization.
     * @summary Get Organization ingest usage data
     * @param {string} [month]
     * @param {string} [year]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationIngest(month?: string, year?: string, options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self/usage/ingest`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (month !== undefined) {
        localVarQueryParameter['month'] = month;
      }

      if (year !== undefined) {
        localVarQueryParameter['year'] = year;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get information about organization's recent activity.
     * @summary Get Organization Recent Activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationRecentActivity(options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self/activity`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve settings for current organization.
     * @summary Get Organization Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationSettings(options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self/settings`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve usage levels for current organization.
     * @summary Get Organization Storage Time-Series data
     * @param {string} [month]
     * @param {string} [year]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationStorage(month?: string, year?: string, options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self/usage/storage`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (month !== undefined) {
        localVarQueryParameter['month'] = month;
      }

      if (year !== undefined) {
        localVarQueryParameter['year'] = year;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve usage levels for current organization.
     * @summary Get Organization trial credit usage data
     * @param {string} [month]
     * @param {string} [year]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationTrialCredit(month?: string, year?: string, options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self/usage/trial`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (month !== undefined) {
        localVarQueryParameter['month'] = month;
      }

      if (year !== undefined) {
        localVarQueryParameter['year'] = year;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve usage levels for current organization.
     * @summary Get Organization Usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationUsage(options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self/usage`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the payment information for your organization.
     * @summary Retrieve payment information about payment method
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentMethod(options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self/payment/method`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get stored payment information for your organization.
     * @summary Retrieve payment information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentSource(options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self/payment/invoices`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get stored sso information for your organization.
     * @summary Retrieve sso settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSsoSettings(options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self/sso`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update payment settings with new Stripe Source id.
     * @summary Update Payment Information
     * @param {UpdateOrgPaymentMethodRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePaymentSource(body: UpdateOrgPaymentMethodRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updatePaymentSource.',
        );
      }
      const localVarPath = `/v1/orgs/self/payment/method`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'UpdateOrgPaymentMethodRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update SSO settings with certificates and redirect links.
     * @summary Update SSO settings
     * @param {UpdateSsoRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSsoSettings(body: UpdateSsoRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateSsoSettings.',
        );
      }
      const localVarPath = `/v1/orgs/self/sso`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'UpdateSsoRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Retrieve information about current organization.
     * @summary Get Organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganization(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<OrganizationResponse> {
      const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getOrganization(
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieve usage levels for current organization.
     * @summary Get Organization Compute Time-Series data
     * @param {string} [month]
     * @param {string} [year]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationCompute(
      month?: string,
      year?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<OrgComputeResponse> {
      const localVarFetchArgs = OrganizationsApiFetchParamCreator(
        configuration,
      ).getOrganizationCompute(month, year, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieve usage levels for current organization.
     * @summary Get Organization ingest usage data
     * @param {string} [month]
     * @param {string} [year]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationIngest(
      month?: string,
      year?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<OrgIngestResponse> {
      const localVarFetchArgs = OrganizationsApiFetchParamCreator(
        configuration,
      ).getOrganizationIngest(month, year, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get information about organization's recent activity.
     * @summary Get Organization Recent Activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationRecentActivity(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<OrgRecentActivityResponse> {
      const localVarFetchArgs = OrganizationsApiFetchParamCreator(
        configuration,
      ).getOrganizationRecentActivity(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieve settings for current organization.
     * @summary Get Organization Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationSettings(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<OrgSettingsResponse> {
      const localVarFetchArgs = OrganizationsApiFetchParamCreator(
        configuration,
      ).getOrganizationSettings(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieve usage levels for current organization.
     * @summary Get Organization Storage Time-Series data
     * @param {string} [month]
     * @param {string} [year]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationStorage(
      month?: string,
      year?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<OrgStorageResponse> {
      const localVarFetchArgs = OrganizationsApiFetchParamCreator(
        configuration,
      ).getOrganizationStorage(month, year, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieve usage levels for current organization.
     * @summary Get Organization trial credit usage data
     * @param {string} [month]
     * @param {string} [year]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationTrialCredit(
      month?: string,
      year?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<OrgTrialUsageResponse> {
      const localVarFetchArgs = OrganizationsApiFetchParamCreator(
        configuration,
      ).getOrganizationTrialCredit(month, year, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieve usage levels for current organization.
     * @summary Get Organization Usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationUsage(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<OrgUsageResponse> {
      const localVarFetchArgs = OrganizationsApiFetchParamCreator(
        configuration,
      ).getOrganizationUsage(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get the payment information for your organization.
     * @summary Retrieve payment information about payment method
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentMethod(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<OrgPaymentMethodResponse> {
      const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getPaymentMethod(
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get stored payment information for your organization.
     * @summary Retrieve payment information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentSource(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<OrgInvoicesResponse> {
      const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getPaymentSource(
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get stored sso information for your organization.
     * @summary Retrieve sso settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSsoSettings(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<OrgSettingsResponse> {
      const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).getSsoSettings(
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Update payment settings with new Stripe Source id.
     * @summary Update Payment Information
     * @param {UpdateOrgPaymentMethodRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePaymentSource(
      body: UpdateOrgPaymentMethodRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<OrgPaymentMethodResponse> {
      const localVarFetchArgs = OrganizationsApiFetchParamCreator(
        configuration,
      ).updatePaymentSource(body, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Update SSO settings with certificates and redirect links.
     * @summary Update SSO settings
     * @param {UpdateSsoRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSsoSettings(
      body: UpdateSsoRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<OrgSettingsResponse> {
      const localVarFetchArgs = OrganizationsApiFetchParamCreator(configuration).updateSsoSettings(
        body,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Retrieve information about current organization.
     * @summary Get Organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganization(options?: any) {
      return OrganizationsApiFp(configuration).getOrganization(options)(fetch, basePath);
    },
    /**
     * Retrieve usage levels for current organization.
     * @summary Get Organization Compute Time-Series data
     * @param {string} [month]
     * @param {string} [year]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationCompute(month?: string, year?: string, options?: any) {
      return OrganizationsApiFp(configuration).getOrganizationCompute(month, year, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Retrieve usage levels for current organization.
     * @summary Get Organization ingest usage data
     * @param {string} [month]
     * @param {string} [year]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationIngest(month?: string, year?: string, options?: any) {
      return OrganizationsApiFp(configuration).getOrganizationIngest(month, year, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Get information about organization's recent activity.
     * @summary Get Organization Recent Activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationRecentActivity(options?: any) {
      return OrganizationsApiFp(configuration).getOrganizationRecentActivity(options)(
        fetch,
        basePath,
      );
    },
    /**
     * Retrieve settings for current organization.
     * @summary Get Organization Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationSettings(options?: any) {
      return OrganizationsApiFp(configuration).getOrganizationSettings(options)(fetch, basePath);
    },
    /**
     * Retrieve usage levels for current organization.
     * @summary Get Organization Storage Time-Series data
     * @param {string} [month]
     * @param {string} [year]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationStorage(month?: string, year?: string, options?: any) {
      return OrganizationsApiFp(configuration).getOrganizationStorage(month, year, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Retrieve usage levels for current organization.
     * @summary Get Organization trial credit usage data
     * @param {string} [month]
     * @param {string} [year]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationTrialCredit(month?: string, year?: string, options?: any) {
      return OrganizationsApiFp(configuration).getOrganizationTrialCredit(month, year, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Retrieve usage levels for current organization.
     * @summary Get Organization Usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationUsage(options?: any) {
      return OrganizationsApiFp(configuration).getOrganizationUsage(options)(fetch, basePath);
    },
    /**
     * Get the payment information for your organization.
     * @summary Retrieve payment information about payment method
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentMethod(options?: any) {
      return OrganizationsApiFp(configuration).getPaymentMethod(options)(fetch, basePath);
    },
    /**
     * Get stored payment information for your organization.
     * @summary Retrieve payment information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentSource(options?: any) {
      return OrganizationsApiFp(configuration).getPaymentSource(options)(fetch, basePath);
    },
    /**
     * Get stored sso information for your organization.
     * @summary Retrieve sso settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSsoSettings(options?: any) {
      return OrganizationsApiFp(configuration).getSsoSettings(options)(fetch, basePath);
    },
    /**
     * Update payment settings with new Stripe Source id.
     * @summary Update Payment Information
     * @param {UpdateOrgPaymentMethodRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePaymentSource(body: UpdateOrgPaymentMethodRequest, options?: any) {
      return OrganizationsApiFp(configuration).updatePaymentSource(body, options)(fetch, basePath);
    },
    /**
     * Update SSO settings with certificates and redirect links.
     * @summary Update SSO settings
     * @param {UpdateSsoRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSsoSettings(body: UpdateSsoRequest, options?: any) {
      return OrganizationsApiFp(configuration).updateSsoSettings(body, options)(fetch, basePath);
    },
  };
};

/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI {
  /**
   * Retrieve information about current organization.
   * @summary Get Organization
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrganizationsApi
   */
  public getOrganization(options?: any) {
    return OrganizationsApiFp(this.configuration).getOrganization(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Retrieve usage levels for current organization.
   * @summary Get Organization Compute Time-Series data
   * @param {string} [month]
   * @param {string} [year]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrganizationsApi
   */
  public getOrganizationCompute(month?: string, year?: string, options?: any) {
    return OrganizationsApiFp(this.configuration).getOrganizationCompute(month, year, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Retrieve usage levels for current organization.
   * @summary Get Organization ingest usage data
   * @param {string} [month]
   * @param {string} [year]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrganizationsApi
   */
  public getOrganizationIngest(month?: string, year?: string, options?: any) {
    return OrganizationsApiFp(this.configuration).getOrganizationIngest(month, year, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Get information about organization's recent activity.
   * @summary Get Organization Recent Activity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrganizationsApi
   */
  public getOrganizationRecentActivity(options?: any) {
    return OrganizationsApiFp(this.configuration).getOrganizationRecentActivity(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Retrieve settings for current organization.
   * @summary Get Organization Settings
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrganizationsApi
   */
  public getOrganizationSettings(options?: any) {
    return OrganizationsApiFp(this.configuration).getOrganizationSettings(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Retrieve usage levels for current organization.
   * @summary Get Organization Storage Time-Series data
   * @param {string} [month]
   * @param {string} [year]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrganizationsApi
   */
  public getOrganizationStorage(month?: string, year?: string, options?: any) {
    return OrganizationsApiFp(this.configuration).getOrganizationStorage(month, year, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Retrieve usage levels for current organization.
   * @summary Get Organization trial credit usage data
   * @param {string} [month]
   * @param {string} [year]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrganizationsApi
   */
  public getOrganizationTrialCredit(month?: string, year?: string, options?: any) {
    return OrganizationsApiFp(this.configuration).getOrganizationTrialCredit(month, year, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Retrieve usage levels for current organization.
   * @summary Get Organization Usage
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrganizationsApi
   */
  public getOrganizationUsage(options?: any) {
    return OrganizationsApiFp(this.configuration).getOrganizationUsage(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Get the payment information for your organization.
   * @summary Retrieve payment information about payment method
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrganizationsApi
   */
  public getPaymentMethod(options?: any) {
    return OrganizationsApiFp(this.configuration).getPaymentMethod(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Get stored payment information for your organization.
   * @summary Retrieve payment information
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrganizationsApi
   */
  public getPaymentSource(options?: any) {
    return OrganizationsApiFp(this.configuration).getPaymentSource(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Get stored sso information for your organization.
   * @summary Retrieve sso settings
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrganizationsApi
   */
  public getSsoSettings(options?: any) {
    return OrganizationsApiFp(this.configuration).getSsoSettings(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Update payment settings with new Stripe Source id.
   * @summary Update Payment Information
   * @param {UpdateOrgPaymentMethodRequest} body JSON object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrganizationsApi
   */
  public updatePaymentSource(body: UpdateOrgPaymentMethodRequest, options?: any) {
    return OrganizationsApiFp(this.configuration).updatePaymentSource(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Update SSO settings with certificates and redirect links.
   * @summary Update SSO settings
   * @param {UpdateSsoRequest} body JSON object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrganizationsApi
   */
  public updateSsoSettings(body: UpdateSsoRequest, options?: any) {
    return OrganizationsApiFp(this.configuration).updateSsoSettings(body, options)(
      this.fetch,
      this.basePath,
    );
  }
}

/**
 * ProvisionApi - fetch parameter creator
 * @export
 */
export const ProvisionApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Provision an organization
     * @param {CreateOrganizationRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    provisionOrganization(body: CreateOrganizationRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling provisionOrganization.',
        );
      }
      const localVarPath = `/v1/provision/orgs`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'CreateOrganizationRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Provision a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    provisionUser(options: any = {}): FetchArgs {
      const localVarPath = `/v1/provision/orgs/self/users`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Resend verification email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyEmail(options: any = {}): FetchArgs {
      const localVarPath = `/v1/provision/orgs/self/verification/email`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProvisionApi - functional programming interface
 * @export
 */
export const ProvisionApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Provision an organization
     * @param {CreateOrganizationRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    provisionOrganization(
      body: CreateOrganizationRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ProvisionApiFetchParamCreator(configuration).provisionOrganization(
        body,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Provision a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    provisionUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ProvisionApiFetchParamCreator(configuration).provisionUser(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Resend verification email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyEmail(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ProvisionApiFetchParamCreator(configuration).verifyEmail(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * ProvisionApi - factory interface
 * @export
 */
export const ProvisionApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     *
     * @summary Provision an organization
     * @param {CreateOrganizationRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    provisionOrganization(body: CreateOrganizationRequest, options?: any) {
      return ProvisionApiFp(configuration).provisionOrganization(body, options)(fetch, basePath);
    },
    /**
     *
     * @summary Provision a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    provisionUser(options?: any) {
      return ProvisionApiFp(configuration).provisionUser(options)(fetch, basePath);
    },
    /**
     *
     * @summary Resend verification email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyEmail(options?: any) {
      return ProvisionApiFp(configuration).verifyEmail(options)(fetch, basePath);
    },
  };
};

/**
 * ProvisionApi - object-oriented interface
 * @export
 * @class ProvisionApi
 * @extends {BaseAPI}
 */
export class ProvisionApi extends BaseAPI {
  /**
   *
   * @summary Provision an organization
   * @param {CreateOrganizationRequest} body JSON object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProvisionApi
   */
  public provisionOrganization(body: CreateOrganizationRequest, options?: any) {
    return ProvisionApiFp(this.configuration).provisionOrganization(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Provision a user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProvisionApi
   */
  public provisionUser(options?: any) {
    return ProvisionApiFp(this.configuration).provisionUser(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Resend verification email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProvisionApi
   */
  public verifyEmail(options?: any) {
    return ProvisionApiFp(this.configuration).verifyEmail(options)(this.fetch, this.basePath);
  }
}

/**
 * QueriesApi - fetch parameter creator
 * @export
 */
export const QueriesApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     * Fetch a query plan from Rockset's planner for a given SQL query.
     * @summary Plan Query
     * @param {QueryRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueryPlan(body: QueryRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling getQueryPlan.',
        );
      }
      const localVarPath = `/v1/orgs/self/queries/plans`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'QueryRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch execution statistics for a particular query.
     * @summary Fetch Query Stats
     * @param {string} queryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueryStats(queryId: string, options: any = {}): FetchArgs {
      // verify required parameter 'queryId' is not null or undefined
      if (queryId === null || queryId === undefined) {
        throw new RequiredError(
          'queryId',
          'Required parameter queryId was null or undefined when calling getQueryStats.',
        );
      }
      const localVarPath = `/v1/orgs/self/queries/{queryId}/stats`.replace(
        `{${'queryId'}}`,
        encodeURIComponent(String(queryId)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Make a SQL query to Rockset.
     * @summary Query
     * @param {QueryRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    query(body: QueryRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling query.',
        );
      }
      const localVarPath = `/v1/orgs/self/queries`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'QueryRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Validate a SQL query with Rockset's parser and planner.
     * @summary Validate Query
     * @param {QueryRequest} body JSON object
     * @param {boolean} [parameters]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validate(body: QueryRequest, parameters?: boolean, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling validate.',
        );
      }
      const localVarPath = `/v1/orgs/self/queries/validations`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (parameters !== undefined) {
        localVarQueryParameter['parameters'] = parameters;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'QueryRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Validate a SQL Expression with Rockset's parser and planner.
     * @summary Validate Expression
     * @param {ValidateExpressionRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateExpression(body: ValidateExpressionRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling validateExpression.',
        );
      }
      const localVarPath = `/v1/orgs/self/queries/validateExpression`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'ValidateExpressionRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * QueriesApi - functional programming interface
 * @export
 */
export const QueriesApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Fetch a query plan from Rockset's planner for a given SQL query.
     * @summary Plan Query
     * @param {QueryRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueryPlan(
      body: QueryRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<QueryResponse> {
      const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).getQueryPlan(
        body,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Fetch execution statistics for a particular query.
     * @summary Fetch Query Stats
     * @param {string} queryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueryStats(
      queryId: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<QueryStatsResponse> {
      const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).getQueryStats(
        queryId,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Make a SQL query to Rockset.
     * @summary Query
     * @param {QueryRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    query(
      body: QueryRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<QueryResponse> {
      const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).query(body, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Validate a SQL query with Rockset's parser and planner.
     * @summary Validate Query
     * @param {QueryRequest} body JSON object
     * @param {boolean} [parameters]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validate(
      body: QueryRequest,
      parameters?: boolean,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ValidateQueryResponse> {
      const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).validate(
        body,
        parameters,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Validate a SQL Expression with Rockset's parser and planner.
     * @summary Validate Expression
     * @param {ValidateExpressionRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateExpression(
      body: ValidateExpressionRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ValidateExpressionResponse> {
      const localVarFetchArgs = QueriesApiFetchParamCreator(configuration).validateExpression(
        body,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * QueriesApi - factory interface
 * @export
 */
export const QueriesApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Fetch a query plan from Rockset's planner for a given SQL query.
     * @summary Plan Query
     * @param {QueryRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueryPlan(body: QueryRequest, options?: any) {
      return QueriesApiFp(configuration).getQueryPlan(body, options)(fetch, basePath);
    },
    /**
     * Fetch execution statistics for a particular query.
     * @summary Fetch Query Stats
     * @param {string} queryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueryStats(queryId: string, options?: any) {
      return QueriesApiFp(configuration).getQueryStats(queryId, options)(fetch, basePath);
    },
    /**
     * Make a SQL query to Rockset.
     * @summary Query
     * @param {QueryRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    query(body: QueryRequest, options?: any) {
      return QueriesApiFp(configuration).query(body, options)(fetch, basePath);
    },
    /**
     * Validate a SQL query with Rockset's parser and planner.
     * @summary Validate Query
     * @param {QueryRequest} body JSON object
     * @param {boolean} [parameters]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validate(body: QueryRequest, parameters?: boolean, options?: any) {
      return QueriesApiFp(configuration).validate(body, parameters, options)(fetch, basePath);
    },
    /**
     * Validate a SQL Expression with Rockset's parser and planner.
     * @summary Validate Expression
     * @param {ValidateExpressionRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateExpression(body: ValidateExpressionRequest, options?: any) {
      return QueriesApiFp(configuration).validateExpression(body, options)(fetch, basePath);
    },
  };
};

/**
 * QueriesApi - object-oriented interface
 * @export
 * @class QueriesApi
 * @extends {BaseAPI}
 */
export class QueriesApi extends BaseAPI {
  /**
   * Fetch a query plan from Rockset's planner for a given SQL query.
   * @summary Plan Query
   * @param {QueryRequest} body JSON object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueriesApi
   */
  public getQueryPlan(body: QueryRequest, options?: any) {
    return QueriesApiFp(this.configuration).getQueryPlan(body, options)(this.fetch, this.basePath);
  }

  /**
   * Fetch execution statistics for a particular query.
   * @summary Fetch Query Stats
   * @param {string} queryId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueriesApi
   */
  public getQueryStats(queryId: string, options?: any) {
    return QueriesApiFp(this.configuration).getQueryStats(queryId, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Make a SQL query to Rockset.
   * @summary Query
   * @param {QueryRequest} body JSON object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueriesApi
   */
  public query(body: QueryRequest, options?: any) {
    return QueriesApiFp(this.configuration).query(body, options)(this.fetch, this.basePath);
  }

  /**
   * Validate a SQL query with Rockset's parser and planner.
   * @summary Validate Query
   * @param {QueryRequest} body JSON object
   * @param {boolean} [parameters]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueriesApi
   */
  public validate(body: QueryRequest, parameters?: boolean, options?: any) {
    return QueriesApiFp(this.configuration).validate(body, parameters, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Validate a SQL Expression with Rockset's parser and planner.
   * @summary Validate Expression
   * @param {ValidateExpressionRequest} body JSON object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueriesApi
   */
  public validateExpression(body: ValidateExpressionRequest, options?: any) {
    return QueriesApiFp(this.configuration).validateExpression(body, options)(
      this.fetch,
      this.basePath,
    );
  }
}

/**
 * QueryLambdasApi - fetch parameter creator
 * @export
 */
export const QueryLambdasApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     * Create a Query Lambda in given workspace.
     * @summary Create Query Lambda
     * @param {string} workspace name of the workspace
     * @param {CreateQueryLambdaRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createQueryLambda(
      workspace: string,
      body: CreateQueryLambdaRequest,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling createQueryLambda.',
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createQueryLambda.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas`.replace(
        `{${'workspace'}}`,
        encodeURIComponent(String(workspace)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'CreateQueryLambdaRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a tag for a specific Query Lambda version, or update that tag if it already exists.
     * @summary Create Query Lambda Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {CreateQueryLambdaTagRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createQueryLambdaTag(
      workspace: string,
      queryLambda: string,
      body: CreateQueryLambdaTagRequest,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling createQueryLambdaTag.',
        );
      }
      // verify required parameter 'queryLambda' is not null or undefined
      if (queryLambda === null || queryLambda === undefined) {
        throw new RequiredError(
          'queryLambda',
          'Required parameter queryLambda was null or undefined when calling createQueryLambdaTag.',
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createQueryLambdaTag.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/tags`
        .replace(`{${'workspace'}}`, encodeURIComponent(String(workspace)))
        .replace(`{${'queryLambda'}}`, encodeURIComponent(String(queryLambda)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'CreateQueryLambdaTagRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a Query Lambda.
     * @summary Delete Query Lambda
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueryLambda(workspace: string, queryLambda: string, options: any = {}): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling deleteQueryLambda.',
        );
      }
      // verify required parameter 'queryLambda' is not null or undefined
      if (queryLambda === null || queryLambda === undefined) {
        throw new RequiredError(
          'queryLambda',
          'Required parameter queryLambda was null or undefined when calling deleteQueryLambda.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}`
        .replace(`{${'workspace'}}`, encodeURIComponent(String(workspace)))
        .replace(`{${'queryLambda'}}`, encodeURIComponent(String(queryLambda)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a tag for a specific Query Lambda
     * @summary Delete Query Lambda Tag Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag name of the tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueryLambdaTag(
      workspace: string,
      queryLambda: string,
      tag: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling deleteQueryLambdaTag.',
        );
      }
      // verify required parameter 'queryLambda' is not null or undefined
      if (queryLambda === null || queryLambda === undefined) {
        throw new RequiredError(
          'queryLambda',
          'Required parameter queryLambda was null or undefined when calling deleteQueryLambdaTag.',
        );
      }
      // verify required parameter 'tag' is not null or undefined
      if (tag === null || tag === undefined) {
        throw new RequiredError(
          'tag',
          'Required parameter tag was null or undefined when calling deleteQueryLambdaTag.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/tags/{tag}`
        .replace(`{${'workspace'}}`, encodeURIComponent(String(workspace)))
        .replace(`{${'queryLambda'}}`, encodeURIComponent(String(queryLambda)))
        .replace(`{${'tag'}}`, encodeURIComponent(String(tag)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a Query Lambda version.
     * @summary Delete Query Lambda Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueryLambdaVersion(
      workspace: string,
      queryLambda: string,
      version: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling deleteQueryLambdaVersion.',
        );
      }
      // verify required parameter 'queryLambda' is not null or undefined
      if (queryLambda === null || queryLambda === undefined) {
        throw new RequiredError(
          'queryLambda',
          'Required parameter queryLambda was null or undefined when calling deleteQueryLambdaVersion.',
        );
      }
      // verify required parameter 'version' is not null or undefined
      if (version === null || version === undefined) {
        throw new RequiredError(
          'version',
          'Required parameter version was null or undefined when calling deleteQueryLambdaVersion.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/version/{version}`
        .replace(`{${'workspace'}}`, encodeURIComponent(String(workspace)))
        .replace(`{${'queryLambda'}}`, encodeURIComponent(String(queryLambda)))
        .replace(`{${'version'}}`, encodeURIComponent(String(version)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Execute a particular version of a Query Lambda.
     * @summary Execute Query Lambda
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {ExecuteQueryLambdaRequest} [body] JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeQueryLambda(
      workspace: string,
      queryLambda: string,
      version: string,
      body?: ExecuteQueryLambdaRequest,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling executeQueryLambda.',
        );
      }
      // verify required parameter 'queryLambda' is not null or undefined
      if (queryLambda === null || queryLambda === undefined) {
        throw new RequiredError(
          'queryLambda',
          'Required parameter queryLambda was null or undefined when calling executeQueryLambda.',
        );
      }
      // verify required parameter 'version' is not null or undefined
      if (version === null || version === undefined) {
        throw new RequiredError(
          'version',
          'Required parameter version was null or undefined when calling executeQueryLambda.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/versions/{version}`
        .replace(`{${'workspace'}}`, encodeURIComponent(String(workspace)))
        .replace(`{${'queryLambda'}}`, encodeURIComponent(String(queryLambda)))
        .replace(`{${'version'}}`, encodeURIComponent(String(version)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'ExecuteQueryLambdaRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Execute the Query Lambda version associated with a given tag.
     * @summary Execute Query Lambda By Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag tag
     * @param {ExecuteQueryLambdaRequest} [body] JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeQueryLambdaByTag(
      workspace: string,
      queryLambda: string,
      tag: string,
      body?: ExecuteQueryLambdaRequest,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling executeQueryLambdaByTag.',
        );
      }
      // verify required parameter 'queryLambda' is not null or undefined
      if (queryLambda === null || queryLambda === undefined) {
        throw new RequiredError(
          'queryLambda',
          'Required parameter queryLambda was null or undefined when calling executeQueryLambdaByTag.',
        );
      }
      // verify required parameter 'tag' is not null or undefined
      if (tag === null || tag === undefined) {
        throw new RequiredError(
          'tag',
          'Required parameter tag was null or undefined when calling executeQueryLambdaByTag.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/tags/{tag}`
        .replace(`{${'workspace'}}`, encodeURIComponent(String(workspace)))
        .replace(`{${'queryLambda'}}`, encodeURIComponent(String(queryLambda)))
        .replace(`{${'tag'}}`, encodeURIComponent(String(tag)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'ExecuteQueryLambdaRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get aggregate Query Lambda usage data for a time window, at requested intervals.
     * @summary Get Query Lambda Stats
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {number} start start time (ms)
     * @param {number} end end time (ms)
     * @param {number} [interval] interval size (s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAggregateQueryLambdaStats(
      workspace: string,
      queryLambda: string,
      version: string,
      start: number,
      end: number,
      interval?: number,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling getAggregateQueryLambdaStats.',
        );
      }
      // verify required parameter 'queryLambda' is not null or undefined
      if (queryLambda === null || queryLambda === undefined) {
        throw new RequiredError(
          'queryLambda',
          'Required parameter queryLambda was null or undefined when calling getAggregateQueryLambdaStats.',
        );
      }
      // verify required parameter 'version' is not null or undefined
      if (version === null || version === undefined) {
        throw new RequiredError(
          'version',
          'Required parameter version was null or undefined when calling getAggregateQueryLambdaStats.',
        );
      }
      // verify required parameter 'start' is not null or undefined
      if (start === null || start === undefined) {
        throw new RequiredError(
          'start',
          'Required parameter start was null or undefined when calling getAggregateQueryLambdaStats.',
        );
      }
      // verify required parameter 'end' is not null or undefined
      if (end === null || end === undefined) {
        throw new RequiredError(
          'end',
          'Required parameter end was null or undefined when calling getAggregateQueryLambdaStats.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/versions/{version}/stats`
        .replace(`{${'workspace'}}`, encodeURIComponent(String(workspace)))
        .replace(`{${'queryLambda'}}`, encodeURIComponent(String(queryLambda)))
        .replace(`{${'version'}}`, encodeURIComponent(String(version)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter['start'] = start;
      }

      if (end !== undefined) {
        localVarQueryParameter['end'] = end;
      }

      if (interval !== undefined) {
        localVarQueryParameter['interval'] = interval;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the Query Lambda version associated with a given tag.
     * @summary Get Query Lambda Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag name of the tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueryLambdaTagVersion(
      workspace: string,
      queryLambda: string,
      tag: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling getQueryLambdaTagVersion.',
        );
      }
      // verify required parameter 'queryLambda' is not null or undefined
      if (queryLambda === null || queryLambda === undefined) {
        throw new RequiredError(
          'queryLambda',
          'Required parameter queryLambda was null or undefined when calling getQueryLambdaTagVersion.',
        );
      }
      // verify required parameter 'tag' is not null or undefined
      if (tag === null || tag === undefined) {
        throw new RequiredError(
          'tag',
          'Required parameter tag was null or undefined when calling getQueryLambdaTagVersion.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/tags/{tag}`
        .replace(`{${'workspace'}}`, encodeURIComponent(String(workspace)))
        .replace(`{${'queryLambda'}}`, encodeURIComponent(String(queryLambda)))
        .replace(`{${'tag'}}`, encodeURIComponent(String(tag)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get details for a specified version of a Query Lambda.
     * @summary Get Query Lambda Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueryLambdaVersion(
      workspace: string,
      queryLambda: string,
      version: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling getQueryLambdaVersion.',
        );
      }
      // verify required parameter 'queryLambda' is not null or undefined
      if (queryLambda === null || queryLambda === undefined) {
        throw new RequiredError(
          'queryLambda',
          'Required parameter queryLambda was null or undefined when calling getQueryLambdaVersion.',
        );
      }
      // verify required parameter 'version' is not null or undefined
      if (version === null || version === undefined) {
        throw new RequiredError(
          'version',
          'Required parameter version was null or undefined when calling getQueryLambdaVersion.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/versions/{version}`
        .replace(`{${'workspace'}}`, encodeURIComponent(String(workspace)))
        .replace(`{${'queryLambda'}}`, encodeURIComponent(String(queryLambda)))
        .replace(`{${'version'}}`, encodeURIComponent(String(version)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List all Query Lambdas in an organization.
     * @summary List Query Lambdas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAllQueryLambdas(options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self/lambdas`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List all distinct Query Lambda tags in an organization.
     * @summary List All Query Lambda Tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOrganizationTags(options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self/lambdas/tags`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List all Query Lambda versions associated with a given tag.
     * @summary List Query Lambda Tag Versions
     * @param {string} tag name of the tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listQueryLambdaTagVersions(tag: string, options: any = {}): FetchArgs {
      // verify required parameter 'tag' is not null or undefined
      if (tag === null || tag === undefined) {
        throw new RequiredError(
          'tag',
          'Required parameter tag was null or undefined when calling listQueryLambdaTagVersions.',
        );
      }
      const localVarPath = `/v1/orgs/self/lambdas/tags/{tag}`.replace(
        `{${'tag'}}`,
        encodeURIComponent(String(tag)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List all tags associated with a Query Lambda
     * @summary List Query Lambda Tags
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listQueryLambdaTags(workspace: string, queryLambda: string, options: any = {}): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling listQueryLambdaTags.',
        );
      }
      // verify required parameter 'queryLambda' is not null or undefined
      if (queryLambda === null || queryLambda === undefined) {
        throw new RequiredError(
          'queryLambda',
          'Required parameter queryLambda was null or undefined when calling listQueryLambdaTags.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/tags`
        .replace(`{${'workspace'}}`, encodeURIComponent(String(workspace)))
        .replace(`{${'queryLambda'}}`, encodeURIComponent(String(queryLambda)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List all versions of a Query Lambda.
     * @summary List Query Lambda Versions
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listQueryLambdaVersions(workspace: string, queryLambda: string, options: any = {}): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling listQueryLambdaVersions.',
        );
      }
      // verify required parameter 'queryLambda' is not null or undefined
      if (queryLambda === null || queryLambda === undefined) {
        throw new RequiredError(
          'queryLambda',
          'Required parameter queryLambda was null or undefined when calling listQueryLambdaVersions.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/versions`
        .replace(`{${'workspace'}}`, encodeURIComponent(String(workspace)))
        .replace(`{${'queryLambda'}}`, encodeURIComponent(String(queryLambda)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List all Query Lambdas under given workspace.
     * @summary List Query Lambdas in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listQueryLambdasInWorkspace(workspace: string, options: any = {}): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling listQueryLambdasInWorkspace.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas`.replace(
        `{${'workspace'}}`,
        encodeURIComponent(String(workspace)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new version of a Query Lambda in given workspace.
     * @summary Update Query Lambda
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {UpdateQueryLambdaRequest} body JSON object
     * @param {boolean} [create]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateQueryLambda(
      workspace: string,
      queryLambda: string,
      body: UpdateQueryLambdaRequest,
      create?: boolean,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling updateQueryLambda.',
        );
      }
      // verify required parameter 'queryLambda' is not null or undefined
      if (queryLambda === null || queryLambda === undefined) {
        throw new RequiredError(
          'queryLambda',
          'Required parameter queryLambda was null or undefined when calling updateQueryLambda.',
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateQueryLambda.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/lambdas/{queryLambda}/versions`
        .replace(`{${'workspace'}}`, encodeURIComponent(String(workspace)))
        .replace(`{${'queryLambda'}}`, encodeURIComponent(String(queryLambda)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (create !== undefined) {
        localVarQueryParameter['create'] = create;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'UpdateQueryLambdaRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * QueryLambdasApi - functional programming interface
 * @export
 */
export const QueryLambdasApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Create a Query Lambda in given workspace.
     * @summary Create Query Lambda
     * @param {string} workspace name of the workspace
     * @param {CreateQueryLambdaRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createQueryLambda(
      workspace: string,
      body: CreateQueryLambdaRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<QueryLambdaVersionResponse> {
      const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).createQueryLambda(
        workspace,
        body,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Create a tag for a specific Query Lambda version, or update that tag if it already exists.
     * @summary Create Query Lambda Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {CreateQueryLambdaTagRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createQueryLambdaTag(
      workspace: string,
      queryLambda: string,
      body: CreateQueryLambdaTagRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<QueryLambdaTagResponse> {
      const localVarFetchArgs = QueryLambdasApiFetchParamCreator(
        configuration,
      ).createQueryLambdaTag(workspace, queryLambda, body, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Delete a Query Lambda.
     * @summary Delete Query Lambda
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueryLambda(
      workspace: string,
      queryLambda: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteQueryLambdaResponse> {
      const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).deleteQueryLambda(
        workspace,
        queryLambda,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Delete a tag for a specific Query Lambda
     * @summary Delete Query Lambda Tag Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag name of the tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueryLambdaTag(
      workspace: string,
      queryLambda: string,
      tag: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<QueryLambdaTagResponse> {
      const localVarFetchArgs = QueryLambdasApiFetchParamCreator(
        configuration,
      ).deleteQueryLambdaTag(workspace, queryLambda, tag, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Delete a Query Lambda version.
     * @summary Delete Query Lambda Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueryLambdaVersion(
      workspace: string,
      queryLambda: string,
      version: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<QueryLambdaVersionResponse> {
      const localVarFetchArgs = QueryLambdasApiFetchParamCreator(
        configuration,
      ).deleteQueryLambdaVersion(workspace, queryLambda, version, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Execute a particular version of a Query Lambda.
     * @summary Execute Query Lambda
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {ExecuteQueryLambdaRequest} [body] JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeQueryLambda(
      workspace: string,
      queryLambda: string,
      version: string,
      body?: ExecuteQueryLambdaRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<QueryResponse> {
      const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).executeQueryLambda(
        workspace,
        queryLambda,
        version,
        body,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Execute the Query Lambda version associated with a given tag.
     * @summary Execute Query Lambda By Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag tag
     * @param {ExecuteQueryLambdaRequest} [body] JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeQueryLambdaByTag(
      workspace: string,
      queryLambda: string,
      tag: string,
      body?: ExecuteQueryLambdaRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<QueryResponse> {
      const localVarFetchArgs = QueryLambdasApiFetchParamCreator(
        configuration,
      ).executeQueryLambdaByTag(workspace, queryLambda, tag, body, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get aggregate Query Lambda usage data for a time window, at requested intervals.
     * @summary Get Query Lambda Stats
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {number} start start time (ms)
     * @param {number} end end time (ms)
     * @param {number} [interval] interval size (s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAggregateQueryLambdaStats(
      workspace: string,
      queryLambda: string,
      version: string,
      start: number,
      end: number,
      interval?: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AggregateQueryLambdaStatsResponse> {
      const localVarFetchArgs = QueryLambdasApiFetchParamCreator(
        configuration,
      ).getAggregateQueryLambdaStats(
        workspace,
        queryLambda,
        version,
        start,
        end,
        interval,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get the Query Lambda version associated with a given tag.
     * @summary Get Query Lambda Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag name of the tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueryLambdaTagVersion(
      workspace: string,
      queryLambda: string,
      tag: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<QueryLambdaTagResponse> {
      const localVarFetchArgs = QueryLambdasApiFetchParamCreator(
        configuration,
      ).getQueryLambdaTagVersion(workspace, queryLambda, tag, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get details for a specified version of a Query Lambda.
     * @summary Get Query Lambda Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueryLambdaVersion(
      workspace: string,
      queryLambda: string,
      version: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<QueryLambdaVersionResponse> {
      const localVarFetchArgs = QueryLambdasApiFetchParamCreator(
        configuration,
      ).getQueryLambdaVersion(workspace, queryLambda, version, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * List all Query Lambdas in an organization.
     * @summary List Query Lambdas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAllQueryLambdas(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueryLambdasResponse> {
      const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).listAllQueryLambdas(
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * List all distinct Query Lambda tags in an organization.
     * @summary List All Query Lambda Tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOrganizationTags(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueryLambdaTagsResponse> {
      const localVarFetchArgs = QueryLambdasApiFetchParamCreator(
        configuration,
      ).listOrganizationTags(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * List all Query Lambda versions associated with a given tag.
     * @summary List Query Lambda Tag Versions
     * @param {string} tag name of the tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listQueryLambdaTagVersions(
      tag: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueryLambdaVersionsResponse> {
      const localVarFetchArgs = QueryLambdasApiFetchParamCreator(
        configuration,
      ).listQueryLambdaTagVersions(tag, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * List all tags associated with a Query Lambda
     * @summary List Query Lambda Tags
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listQueryLambdaTags(
      workspace: string,
      queryLambda: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueryLambdaTagsResponse> {
      const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).listQueryLambdaTags(
        workspace,
        queryLambda,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * List all versions of a Query Lambda.
     * @summary List Query Lambda Versions
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listQueryLambdaVersions(
      workspace: string,
      queryLambda: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueryLambdaVersionsResponse> {
      const localVarFetchArgs = QueryLambdasApiFetchParamCreator(
        configuration,
      ).listQueryLambdaVersions(workspace, queryLambda, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * List all Query Lambdas under given workspace.
     * @summary List Query Lambdas in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listQueryLambdasInWorkspace(
      workspace: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ListQueryLambdasResponse> {
      const localVarFetchArgs = QueryLambdasApiFetchParamCreator(
        configuration,
      ).listQueryLambdasInWorkspace(workspace, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Create a new version of a Query Lambda in given workspace.
     * @summary Update Query Lambda
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {UpdateQueryLambdaRequest} body JSON object
     * @param {boolean} [create]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateQueryLambda(
      workspace: string,
      queryLambda: string,
      body: UpdateQueryLambdaRequest,
      create?: boolean,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<QueryLambdaVersionResponse> {
      const localVarFetchArgs = QueryLambdasApiFetchParamCreator(configuration).updateQueryLambda(
        workspace,
        queryLambda,
        body,
        create,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * QueryLambdasApi - factory interface
 * @export
 */
export const QueryLambdasApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Create a Query Lambda in given workspace.
     * @summary Create Query Lambda
     * @param {string} workspace name of the workspace
     * @param {CreateQueryLambdaRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createQueryLambda(workspace: string, body: CreateQueryLambdaRequest, options?: any) {
      return QueryLambdasApiFp(configuration).createQueryLambda(workspace, body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Create a tag for a specific Query Lambda version, or update that tag if it already exists.
     * @summary Create Query Lambda Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {CreateQueryLambdaTagRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createQueryLambdaTag(
      workspace: string,
      queryLambda: string,
      body: CreateQueryLambdaTagRequest,
      options?: any,
    ) {
      return QueryLambdasApiFp(configuration).createQueryLambdaTag(
        workspace,
        queryLambda,
        body,
        options,
      )(fetch, basePath);
    },
    /**
     * Delete a Query Lambda.
     * @summary Delete Query Lambda
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueryLambda(workspace: string, queryLambda: string, options?: any) {
      return QueryLambdasApiFp(configuration).deleteQueryLambda(workspace, queryLambda, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Delete a tag for a specific Query Lambda
     * @summary Delete Query Lambda Tag Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag name of the tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueryLambdaTag(workspace: string, queryLambda: string, tag: string, options?: any) {
      return QueryLambdasApiFp(configuration).deleteQueryLambdaTag(
        workspace,
        queryLambda,
        tag,
        options,
      )(fetch, basePath);
    },
    /**
     * Delete a Query Lambda version.
     * @summary Delete Query Lambda Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueryLambdaVersion(
      workspace: string,
      queryLambda: string,
      version: string,
      options?: any,
    ) {
      return QueryLambdasApiFp(configuration).deleteQueryLambdaVersion(
        workspace,
        queryLambda,
        version,
        options,
      )(fetch, basePath);
    },
    /**
     * Execute a particular version of a Query Lambda.
     * @summary Execute Query Lambda
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {ExecuteQueryLambdaRequest} [body] JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeQueryLambda(
      workspace: string,
      queryLambda: string,
      version: string,
      body?: ExecuteQueryLambdaRequest,
      options?: any,
    ) {
      return QueryLambdasApiFp(configuration).executeQueryLambda(
        workspace,
        queryLambda,
        version,
        body,
        options,
      )(fetch, basePath);
    },
    /**
     * Execute the Query Lambda version associated with a given tag.
     * @summary Execute Query Lambda By Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag tag
     * @param {ExecuteQueryLambdaRequest} [body] JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeQueryLambdaByTag(
      workspace: string,
      queryLambda: string,
      tag: string,
      body?: ExecuteQueryLambdaRequest,
      options?: any,
    ) {
      return QueryLambdasApiFp(configuration).executeQueryLambdaByTag(
        workspace,
        queryLambda,
        tag,
        body,
        options,
      )(fetch, basePath);
    },
    /**
     * Get aggregate Query Lambda usage data for a time window, at requested intervals.
     * @summary Get Query Lambda Stats
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {number} start start time (ms)
     * @param {number} end end time (ms)
     * @param {number} [interval] interval size (s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAggregateQueryLambdaStats(
      workspace: string,
      queryLambda: string,
      version: string,
      start: number,
      end: number,
      interval?: number,
      options?: any,
    ) {
      return QueryLambdasApiFp(configuration).getAggregateQueryLambdaStats(
        workspace,
        queryLambda,
        version,
        start,
        end,
        interval,
        options,
      )(fetch, basePath);
    },
    /**
     * Get the Query Lambda version associated with a given tag.
     * @summary Get Query Lambda Tag
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} tag name of the tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueryLambdaTagVersion(workspace: string, queryLambda: string, tag: string, options?: any) {
      return QueryLambdasApiFp(configuration).getQueryLambdaTagVersion(
        workspace,
        queryLambda,
        tag,
        options,
      )(fetch, basePath);
    },
    /**
     * Get details for a specified version of a Query Lambda.
     * @summary Get Query Lambda Version
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {string} version version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueryLambdaVersion(workspace: string, queryLambda: string, version: string, options?: any) {
      return QueryLambdasApiFp(configuration).getQueryLambdaVersion(
        workspace,
        queryLambda,
        version,
        options,
      )(fetch, basePath);
    },
    /**
     * List all Query Lambdas in an organization.
     * @summary List Query Lambdas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAllQueryLambdas(options?: any) {
      return QueryLambdasApiFp(configuration).listAllQueryLambdas(options)(fetch, basePath);
    },
    /**
     * List all distinct Query Lambda tags in an organization.
     * @summary List All Query Lambda Tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOrganizationTags(options?: any) {
      return QueryLambdasApiFp(configuration).listOrganizationTags(options)(fetch, basePath);
    },
    /**
     * List all Query Lambda versions associated with a given tag.
     * @summary List Query Lambda Tag Versions
     * @param {string} tag name of the tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listQueryLambdaTagVersions(tag: string, options?: any) {
      return QueryLambdasApiFp(configuration).listQueryLambdaTagVersions(tag, options)(
        fetch,
        basePath,
      );
    },
    /**
     * List all tags associated with a Query Lambda
     * @summary List Query Lambda Tags
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listQueryLambdaTags(workspace: string, queryLambda: string, options?: any) {
      return QueryLambdasApiFp(configuration).listQueryLambdaTags(workspace, queryLambda, options)(
        fetch,
        basePath,
      );
    },
    /**
     * List all versions of a Query Lambda.
     * @summary List Query Lambda Versions
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listQueryLambdaVersions(workspace: string, queryLambda: string, options?: any) {
      return QueryLambdasApiFp(configuration).listQueryLambdaVersions(
        workspace,
        queryLambda,
        options,
      )(fetch, basePath);
    },
    /**
     * List all Query Lambdas under given workspace.
     * @summary List Query Lambdas in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listQueryLambdasInWorkspace(workspace: string, options?: any) {
      return QueryLambdasApiFp(configuration).listQueryLambdasInWorkspace(workspace, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Create a new version of a Query Lambda in given workspace.
     * @summary Update Query Lambda
     * @param {string} workspace name of the workspace
     * @param {string} queryLambda name of the Query Lambda
     * @param {UpdateQueryLambdaRequest} body JSON object
     * @param {boolean} [create]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateQueryLambda(
      workspace: string,
      queryLambda: string,
      body: UpdateQueryLambdaRequest,
      create?: boolean,
      options?: any,
    ) {
      return QueryLambdasApiFp(configuration).updateQueryLambda(
        workspace,
        queryLambda,
        body,
        create,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * QueryLambdasApi - object-oriented interface
 * @export
 * @class QueryLambdasApi
 * @extends {BaseAPI}
 */
export class QueryLambdasApi extends BaseAPI {
  /**
   * Create a Query Lambda in given workspace.
   * @summary Create Query Lambda
   * @param {string} workspace name of the workspace
   * @param {CreateQueryLambdaRequest} body JSON object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryLambdasApi
   */
  public createQueryLambda(workspace: string, body: CreateQueryLambdaRequest, options?: any) {
    return QueryLambdasApiFp(this.configuration).createQueryLambda(workspace, body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Create a tag for a specific Query Lambda version, or update that tag if it already exists.
   * @summary Create Query Lambda Tag
   * @param {string} workspace name of the workspace
   * @param {string} queryLambda name of the Query Lambda
   * @param {CreateQueryLambdaTagRequest} body JSON object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryLambdasApi
   */
  public createQueryLambdaTag(
    workspace: string,
    queryLambda: string,
    body: CreateQueryLambdaTagRequest,
    options?: any,
  ) {
    return QueryLambdasApiFp(this.configuration).createQueryLambdaTag(
      workspace,
      queryLambda,
      body,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Delete a Query Lambda.
   * @summary Delete Query Lambda
   * @param {string} workspace name of the workspace
   * @param {string} queryLambda name of the Query Lambda
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryLambdasApi
   */
  public deleteQueryLambda(workspace: string, queryLambda: string, options?: any) {
    return QueryLambdasApiFp(this.configuration).deleteQueryLambda(workspace, queryLambda, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Delete a tag for a specific Query Lambda
   * @summary Delete Query Lambda Tag Version
   * @param {string} workspace name of the workspace
   * @param {string} queryLambda name of the Query Lambda
   * @param {string} tag name of the tag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryLambdasApi
   */
  public deleteQueryLambdaTag(workspace: string, queryLambda: string, tag: string, options?: any) {
    return QueryLambdasApiFp(this.configuration).deleteQueryLambdaTag(
      workspace,
      queryLambda,
      tag,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Delete a Query Lambda version.
   * @summary Delete Query Lambda Version
   * @param {string} workspace name of the workspace
   * @param {string} queryLambda name of the Query Lambda
   * @param {string} version version
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryLambdasApi
   */
  public deleteQueryLambdaVersion(
    workspace: string,
    queryLambda: string,
    version: string,
    options?: any,
  ) {
    return QueryLambdasApiFp(this.configuration).deleteQueryLambdaVersion(
      workspace,
      queryLambda,
      version,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Execute a particular version of a Query Lambda.
   * @summary Execute Query Lambda
   * @param {string} workspace name of the workspace
   * @param {string} queryLambda name of the Query Lambda
   * @param {string} version version
   * @param {ExecuteQueryLambdaRequest} [body] JSON object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryLambdasApi
   */
  public executeQueryLambda(
    workspace: string,
    queryLambda: string,
    version: string,
    body?: ExecuteQueryLambdaRequest,
    options?: any,
  ) {
    return QueryLambdasApiFp(this.configuration).executeQueryLambda(
      workspace,
      queryLambda,
      version,
      body,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Execute the Query Lambda version associated with a given tag.
   * @summary Execute Query Lambda By Tag
   * @param {string} workspace name of the workspace
   * @param {string} queryLambda name of the Query Lambda
   * @param {string} tag tag
   * @param {ExecuteQueryLambdaRequest} [body] JSON object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryLambdasApi
   */
  public executeQueryLambdaByTag(
    workspace: string,
    queryLambda: string,
    tag: string,
    body?: ExecuteQueryLambdaRequest,
    options?: any,
  ) {
    return QueryLambdasApiFp(this.configuration).executeQueryLambdaByTag(
      workspace,
      queryLambda,
      tag,
      body,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Get aggregate Query Lambda usage data for a time window, at requested intervals.
   * @summary Get Query Lambda Stats
   * @param {string} workspace name of the workspace
   * @param {string} queryLambda name of the Query Lambda
   * @param {string} version version
   * @param {number} start start time (ms)
   * @param {number} end end time (ms)
   * @param {number} [interval] interval size (s)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryLambdasApi
   */
  public getAggregateQueryLambdaStats(
    workspace: string,
    queryLambda: string,
    version: string,
    start: number,
    end: number,
    interval?: number,
    options?: any,
  ) {
    return QueryLambdasApiFp(this.configuration).getAggregateQueryLambdaStats(
      workspace,
      queryLambda,
      version,
      start,
      end,
      interval,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Get the Query Lambda version associated with a given tag.
   * @summary Get Query Lambda Tag
   * @param {string} workspace name of the workspace
   * @param {string} queryLambda name of the Query Lambda
   * @param {string} tag name of the tag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryLambdasApi
   */
  public getQueryLambdaTagVersion(
    workspace: string,
    queryLambda: string,
    tag: string,
    options?: any,
  ) {
    return QueryLambdasApiFp(this.configuration).getQueryLambdaTagVersion(
      workspace,
      queryLambda,
      tag,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Get details for a specified version of a Query Lambda.
   * @summary Get Query Lambda Version
   * @param {string} workspace name of the workspace
   * @param {string} queryLambda name of the Query Lambda
   * @param {string} version version
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryLambdasApi
   */
  public getQueryLambdaVersion(
    workspace: string,
    queryLambda: string,
    version: string,
    options?: any,
  ) {
    return QueryLambdasApiFp(this.configuration).getQueryLambdaVersion(
      workspace,
      queryLambda,
      version,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * List all Query Lambdas in an organization.
   * @summary List Query Lambdas
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryLambdasApi
   */
  public listAllQueryLambdas(options?: any) {
    return QueryLambdasApiFp(this.configuration).listAllQueryLambdas(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * List all distinct Query Lambda tags in an organization.
   * @summary List All Query Lambda Tags
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryLambdasApi
   */
  public listOrganizationTags(options?: any) {
    return QueryLambdasApiFp(this.configuration).listOrganizationTags(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * List all Query Lambda versions associated with a given tag.
   * @summary List Query Lambda Tag Versions
   * @param {string} tag name of the tag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryLambdasApi
   */
  public listQueryLambdaTagVersions(tag: string, options?: any) {
    return QueryLambdasApiFp(this.configuration).listQueryLambdaTagVersions(tag, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * List all tags associated with a Query Lambda
   * @summary List Query Lambda Tags
   * @param {string} workspace name of the workspace
   * @param {string} queryLambda name of the Query Lambda
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryLambdasApi
   */
  public listQueryLambdaTags(workspace: string, queryLambda: string, options?: any) {
    return QueryLambdasApiFp(this.configuration).listQueryLambdaTags(
      workspace,
      queryLambda,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * List all versions of a Query Lambda.
   * @summary List Query Lambda Versions
   * @param {string} workspace name of the workspace
   * @param {string} queryLambda name of the Query Lambda
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryLambdasApi
   */
  public listQueryLambdaVersions(workspace: string, queryLambda: string, options?: any) {
    return QueryLambdasApiFp(this.configuration).listQueryLambdaVersions(
      workspace,
      queryLambda,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * List all Query Lambdas under given workspace.
   * @summary List Query Lambdas in Workspace
   * @param {string} workspace name of the workspace
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryLambdasApi
   */
  public listQueryLambdasInWorkspace(workspace: string, options?: any) {
    return QueryLambdasApiFp(this.configuration).listQueryLambdasInWorkspace(workspace, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Create a new version of a Query Lambda in given workspace.
   * @summary Update Query Lambda
   * @param {string} workspace name of the workspace
   * @param {string} queryLambda name of the Query Lambda
   * @param {UpdateQueryLambdaRequest} body JSON object
   * @param {boolean} [create]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryLambdasApi
   */
  public updateQueryLambda(
    workspace: string,
    queryLambda: string,
    body: UpdateQueryLambdaRequest,
    create?: boolean,
    options?: any,
  ) {
    return QueryLambdasApiFp(this.configuration).updateQueryLambda(
      workspace,
      queryLambda,
      body,
      create,
      options,
    )(this.fetch, this.basePath);
  }
}

/**
 * StatusApi - fetch parameter creator
 * @export
 */
export const StatusApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     * Server responds with 200 if healthy.
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    health(options: any = {}): FetchArgs {
      const localVarPath = `/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Server responds with 200 if healthy.
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    health(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StatusResponse> {
      const localVarFetchArgs = StatusApiFetchParamCreator(configuration).health(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Server responds with 200 if healthy.
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    health(options?: any) {
      return StatusApiFp(configuration).health(options)(fetch, basePath);
    },
  };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
  /**
   * Server responds with 200 if healthy.
   * @summary Health Check
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatusApi
   */
  public health(options?: any) {
    return StatusApiFp(this.configuration).health(options)(this.fetch, this.basePath);
  }
}

/**
 * TelemetryApi - fetch parameter creator
 * @export
 */
export const TelemetryApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     * Record an item.
     * @summary Record Activity
     * @param {TelemetryRequest} body the activity item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recordActivity(body: TelemetryRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling recordActivity.',
        );
      }
      const localVarPath = `/v1/telemetry`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'TelemetryRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TelemetryApi - functional programming interface
 * @export
 */
export const TelemetryApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Record an item.
     * @summary Record Activity
     * @param {TelemetryRequest} body the activity item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recordActivity(
      body: TelemetryRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<StatusResponse> {
      const localVarFetchArgs = TelemetryApiFetchParamCreator(configuration).recordActivity(
        body,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * TelemetryApi - factory interface
 * @export
 */
export const TelemetryApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Record an item.
     * @summary Record Activity
     * @param {TelemetryRequest} body the activity item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recordActivity(body: TelemetryRequest, options?: any) {
      return TelemetryApiFp(configuration).recordActivity(body, options)(fetch, basePath);
    },
  };
};

/**
 * TelemetryApi - object-oriented interface
 * @export
 * @class TelemetryApi
 * @extends {BaseAPI}
 */
export class TelemetryApi extends BaseAPI {
  /**
   * Record an item.
   * @summary Record Activity
   * @param {TelemetryRequest} body the activity item
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TelemetryApi
   */
  public recordActivity(body: TelemetryRequest, options?: any) {
    return TelemetryApiFp(this.configuration).recordActivity(body, options)(
      this.fetch,
      this.basePath,
    );
  }
}

/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     * Create a new user for an organization.
     * @summary Create User
     * @param {CreateUserRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(body: CreateUserRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createUser.',
        );
      }
      const localVarPath = `/v1/orgs/self/users`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'CreateUserRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a user from an organization.
     * @summary Delete User
     * @param {string} user user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(user: string, options: any = {}): FetchArgs {
      // verify required parameter 'user' is not null or undefined
      if (user === null || user === undefined) {
        throw new RequiredError(
          'user',
          'Required parameter user was null or undefined when calling deleteUser.',
        );
      }
      const localVarPath = `/v1/orgs/self/users/{user}`.replace(
        `{${'user'}}`,
        encodeURIComponent(String(user)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve currently authenticated user.
     * @summary Get Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUser(options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self/users/self`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get invite_state for current user's org_membership.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserInviteState(options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self/users/self/inviteState`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve currently active user's nux values.
     * @summary Get Current User's Nux Values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserNux(options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self/users/self/nux`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get state value for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserState(options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self/users/self/state`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get accepted_ToS value for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserTos(options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self/users/self/tos`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Functional in public API server's only - used to bootstrap Console
     * @summary Get Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserUnchecked(options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self/users/self/public`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get query history for user.
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserQueryHistory(limit?: number, options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self/users/self/query-history`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve all users for an organization.
     * @summary List Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsers(options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self/users`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set invite_state for current user's org_membership.
     * @param {InviteState} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setCurrentUserInviteState(body: InviteState, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling setCurrentUserInviteState.',
        );
      }
      const localVarPath = `/v1/orgs/self/users/self/inviteState`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'InviteState' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update state value for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setCurrentUserState(options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self/users/self/state`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set accepted_ToS value to true for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setCurrentUserTos(options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self/users/self/tos`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update currently active user.
     * @summary Update Current User
     * @param {UpdateUserRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCurrentUser(body: UpdateUserRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateCurrentUser.',
        );
      }
      const localVarPath = `/v1/orgs/self/users/self`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'UpdateUserRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update nux info for user.
     * @summary Update Nux Info for User
     * @param {UpdateUserNuxRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCurrentUserNux(body: UpdateUserNuxRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateCurrentUserNux.',
        );
      }
      const localVarPath = `/v1/orgs/self/users/self/nux`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'UpdateUserNuxRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Create a new user for an organization.
     * @summary Create User
     * @param {CreateUserRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(
      body: CreateUserRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CreateUserResponse> {
      const localVarFetchArgs = UsersApiFetchParamCreator(configuration).createUser(body, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Delete a user from an organization.
     * @summary Delete User
     * @param {string} user user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(
      user: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteUserResponse> {
      const localVarFetchArgs = UsersApiFetchParamCreator(configuration).deleteUser(user, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieve currently authenticated user.
     * @summary Get Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
      const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getCurrentUser(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get invite_state for current user's org_membership.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserInviteState(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InviteState> {
      const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getCurrentUserInviteState(
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieve currently active user's nux values.
     * @summary Get Current User's Nux Values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserNux(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserNux> {
      const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getCurrentUserNux(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get state value for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserState(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UserState> {
      const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getCurrentUserState(
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get accepted_ToS value for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserTos(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<GetUserTosResponse> {
      const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getCurrentUserTos(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Functional in public API server's only - used to bootstrap Console
     * @summary Get Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserUnchecked(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
      const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getCurrentUserUnchecked(
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get query history for user.
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserQueryHistory(
      limit?: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UserQueryHistoryResponse> {
      const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUserQueryHistory(
        limit,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieve all users for an organization.
     * @summary List Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListUsersResponse> {
      const localVarFetchArgs = UsersApiFetchParamCreator(configuration).listUsers(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Set invite_state for current user's org_membership.
     * @param {InviteState} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setCurrentUserInviteState(
      body: InviteState,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InviteState> {
      const localVarFetchArgs = UsersApiFetchParamCreator(configuration).setCurrentUserInviteState(
        body,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Update state value for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setCurrentUserState(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UserState> {
      const localVarFetchArgs = UsersApiFetchParamCreator(configuration).setCurrentUserState(
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Set accepted_ToS value to true for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setCurrentUserTos(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = UsersApiFetchParamCreator(configuration).setCurrentUserTos(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Update currently active user.
     * @summary Update Current User
     * @param {UpdateUserRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCurrentUser(
      body: UpdateUserRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
      const localVarFetchArgs = UsersApiFetchParamCreator(configuration).updateCurrentUser(
        body,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Update nux info for user.
     * @summary Update Nux Info for User
     * @param {UpdateUserNuxRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCurrentUserNux(
      body: UpdateUserNuxRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UserNux> {
      const localVarFetchArgs = UsersApiFetchParamCreator(configuration).updateCurrentUserNux(
        body,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Create a new user for an organization.
     * @summary Create User
     * @param {CreateUserRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(body: CreateUserRequest, options?: any) {
      return UsersApiFp(configuration).createUser(body, options)(fetch, basePath);
    },
    /**
     * Delete a user from an organization.
     * @summary Delete User
     * @param {string} user user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(user: string, options?: any) {
      return UsersApiFp(configuration).deleteUser(user, options)(fetch, basePath);
    },
    /**
     * Retrieve currently authenticated user.
     * @summary Get Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUser(options?: any) {
      return UsersApiFp(configuration).getCurrentUser(options)(fetch, basePath);
    },
    /**
     *
     * @summary Get invite_state for current user's org_membership.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserInviteState(options?: any) {
      return UsersApiFp(configuration).getCurrentUserInviteState(options)(fetch, basePath);
    },
    /**
     * Retrieve currently active user's nux values.
     * @summary Get Current User's Nux Values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserNux(options?: any) {
      return UsersApiFp(configuration).getCurrentUserNux(options)(fetch, basePath);
    },
    /**
     *
     * @summary Get state value for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserState(options?: any) {
      return UsersApiFp(configuration).getCurrentUserState(options)(fetch, basePath);
    },
    /**
     *
     * @summary Get accepted_ToS value for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserTos(options?: any) {
      return UsersApiFp(configuration).getCurrentUserTos(options)(fetch, basePath);
    },
    /**
     * Functional in public API server's only - used to bootstrap Console
     * @summary Get Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserUnchecked(options?: any) {
      return UsersApiFp(configuration).getCurrentUserUnchecked(options)(fetch, basePath);
    },
    /**
     *
     * @summary Get query history for user.
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserQueryHistory(limit?: number, options?: any) {
      return UsersApiFp(configuration).getUserQueryHistory(limit, options)(fetch, basePath);
    },
    /**
     * Retrieve all users for an organization.
     * @summary List Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsers(options?: any) {
      return UsersApiFp(configuration).listUsers(options)(fetch, basePath);
    },
    /**
     *
     * @summary Set invite_state for current user's org_membership.
     * @param {InviteState} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setCurrentUserInviteState(body: InviteState, options?: any) {
      return UsersApiFp(configuration).setCurrentUserInviteState(body, options)(fetch, basePath);
    },
    /**
     *
     * @summary Update state value for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setCurrentUserState(options?: any) {
      return UsersApiFp(configuration).setCurrentUserState(options)(fetch, basePath);
    },
    /**
     *
     * @summary Set accepted_ToS value to true for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setCurrentUserTos(options?: any) {
      return UsersApiFp(configuration).setCurrentUserTos(options)(fetch, basePath);
    },
    /**
     * Update currently active user.
     * @summary Update Current User
     * @param {UpdateUserRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCurrentUser(body: UpdateUserRequest, options?: any) {
      return UsersApiFp(configuration).updateCurrentUser(body, options)(fetch, basePath);
    },
    /**
     * Update nux info for user.
     * @summary Update Nux Info for User
     * @param {UpdateUserNuxRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCurrentUserNux(body: UpdateUserNuxRequest, options?: any) {
      return UsersApiFp(configuration).updateCurrentUserNux(body, options)(fetch, basePath);
    },
  };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   * Create a new user for an organization.
   * @summary Create User
   * @param {CreateUserRequest} body JSON object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public createUser(body: CreateUserRequest, options?: any) {
    return UsersApiFp(this.configuration).createUser(body, options)(this.fetch, this.basePath);
  }

  /**
   * Delete a user from an organization.
   * @summary Delete User
   * @param {string} user user email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public deleteUser(user: string, options?: any) {
    return UsersApiFp(this.configuration).deleteUser(user, options)(this.fetch, this.basePath);
  }

  /**
   * Retrieve currently authenticated user.
   * @summary Get Current User
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getCurrentUser(options?: any) {
    return UsersApiFp(this.configuration).getCurrentUser(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get invite_state for current user's org_membership.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getCurrentUserInviteState(options?: any) {
    return UsersApiFp(this.configuration).getCurrentUserInviteState(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Retrieve currently active user's nux values.
   * @summary Get Current User's Nux Values
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getCurrentUserNux(options?: any) {
    return UsersApiFp(this.configuration).getCurrentUserNux(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get state value for user.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getCurrentUserState(options?: any) {
    return UsersApiFp(this.configuration).getCurrentUserState(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get accepted_ToS value for user.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getCurrentUserTos(options?: any) {
    return UsersApiFp(this.configuration).getCurrentUserTos(options)(this.fetch, this.basePath);
  }

  /**
   * Functional in public API server's only - used to bootstrap Console
   * @summary Get Current User
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getCurrentUserUnchecked(options?: any) {
    return UsersApiFp(this.configuration).getCurrentUserUnchecked(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Get query history for user.
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUserQueryHistory(limit?: number, options?: any) {
    return UsersApiFp(this.configuration).getUserQueryHistory(limit, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Retrieve all users for an organization.
   * @summary List Users
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public listUsers(options?: any) {
    return UsersApiFp(this.configuration).listUsers(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Set invite_state for current user's org_membership.
   * @param {InviteState} body JSON object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public setCurrentUserInviteState(body: InviteState, options?: any) {
    return UsersApiFp(this.configuration).setCurrentUserInviteState(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary Update state value for user.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public setCurrentUserState(options?: any) {
    return UsersApiFp(this.configuration).setCurrentUserState(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Set accepted_ToS value to true for user.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public setCurrentUserTos(options?: any) {
    return UsersApiFp(this.configuration).setCurrentUserTos(options)(this.fetch, this.basePath);
  }

  /**
   * Update currently active user.
   * @summary Update Current User
   * @param {UpdateUserRequest} body JSON object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public updateCurrentUser(body: UpdateUserRequest, options?: any) {
    return UsersApiFp(this.configuration).updateCurrentUser(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Update nux info for user.
   * @summary Update Nux Info for User
   * @param {UpdateUserNuxRequest} body JSON object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public updateCurrentUserNux(body: UpdateUserNuxRequest, options?: any) {
    return UsersApiFp(this.configuration).updateCurrentUserNux(body, options)(
      this.fetch,
      this.basePath,
    );
  }
}

/**
 * VirtualInstancesApi - fetch parameter creator
 * @export
 */
export const VirtualInstancesApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     * Get details about a virtual instance.
     * @summary Get Virtual Instance
     * @param {string} virtualinstance uuid of the virtual instance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVirtualInstance(virtualinstance: string, options: any = {}): FetchArgs {
      // verify required parameter 'virtualinstance' is not null or undefined
      if (virtualinstance === null || virtualinstance === undefined) {
        throw new RequiredError(
          'virtualinstance',
          'Required parameter virtualinstance was null or undefined when calling getVirtualInstance.',
        );
      }
      const localVarPath = `/v1/orgs/self/virtualinstances/{virtualinstance}`.replace(
        `{${'virtualinstance'}}`,
        encodeURIComponent(String(virtualinstance)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get relevant metrics for a specific virtual instance
     * @summary Get Virtual Instance metrics
     * @param {string} virtualinstance uuid of the virtual instance
     * @param {number} start start time (ms)
     * @param {number} end end time (ms)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVirtualInstanceMetrics(
      virtualinstance: string,
      start: number,
      end: number,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'virtualinstance' is not null or undefined
      if (virtualinstance === null || virtualinstance === undefined) {
        throw new RequiredError(
          'virtualinstance',
          'Required parameter virtualinstance was null or undefined when calling getVirtualInstanceMetrics.',
        );
      }
      // verify required parameter 'start' is not null or undefined
      if (start === null || start === undefined) {
        throw new RequiredError(
          'start',
          'Required parameter start was null or undefined when calling getVirtualInstanceMetrics.',
        );
      }
      // verify required parameter 'end' is not null or undefined
      if (end === null || end === undefined) {
        throw new RequiredError(
          'end',
          'Required parameter end was null or undefined when calling getVirtualInstanceMetrics.',
        );
      }
      const localVarPath = `/v1/orgs/self/virtualinstances/{virtualinstance}/metrics`.replace(
        `{${'virtualinstance'}}`,
        encodeURIComponent(String(virtualinstance)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter['start'] = start;
      }

      if (end !== undefined) {
        localVarQueryParameter['end'] = end;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve all virtual instances in an organization.
     * @summary List Virtual Instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listVirtualInstances(options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self/virtualinstances`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Switch a virtual instance within an org with a new type
     * @summary Switch Virtual Instance Type
     * @param {string} virtualinstance uuid of the virtual instance
     * @param {SwitchVirtualInstanceTypeRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setVirtualInstanceType(
      virtualinstance: string,
      body: SwitchVirtualInstanceTypeRequest,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'virtualinstance' is not null or undefined
      if (virtualinstance === null || virtualinstance === undefined) {
        throw new RequiredError(
          'virtualinstance',
          'Required parameter virtualinstance was null or undefined when calling setVirtualInstanceType.',
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling setVirtualInstanceType.',
        );
      }
      const localVarPath = `/v1/orgs/self/virtualinstances/{virtualinstance}/type`.replace(
        `{${'virtualinstance'}}`,
        encodeURIComponent(String(virtualinstance)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'SwitchVirtualInstanceTypeRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * VirtualInstancesApi - functional programming interface
 * @export
 */
export const VirtualInstancesApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Get details about a virtual instance.
     * @summary Get Virtual Instance
     * @param {string} virtualinstance uuid of the virtual instance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVirtualInstance(
      virtualinstance: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<GetVirtualInstanceResponse> {
      const localVarFetchArgs = VirtualInstancesApiFetchParamCreator(
        configuration,
      ).getVirtualInstance(virtualinstance, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get relevant metrics for a specific virtual instance
     * @summary Get Virtual Instance metrics
     * @param {string} virtualinstance uuid of the virtual instance
     * @param {number} start start time (ms)
     * @param {number} end end time (ms)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVirtualInstanceMetrics(
      virtualinstance: string,
      start: number,
      end: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<GetVirtualInstanceMetricsResponse> {
      const localVarFetchArgs = VirtualInstancesApiFetchParamCreator(
        configuration,
      ).getVirtualInstanceMetrics(virtualinstance, start, end, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieve all virtual instances in an organization.
     * @summary List Virtual Instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listVirtualInstances(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ListVirtualInstancesResponse> {
      const localVarFetchArgs = VirtualInstancesApiFetchParamCreator(
        configuration,
      ).listVirtualInstances(options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Switch a virtual instance within an org with a new type
     * @summary Switch Virtual Instance Type
     * @param {string} virtualinstance uuid of the virtual instance
     * @param {SwitchVirtualInstanceTypeRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setVirtualInstanceType(
      virtualinstance: string,
      body: SwitchVirtualInstanceTypeRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<SwitchVirtualInstanceTypeResponse> {
      const localVarFetchArgs = VirtualInstancesApiFetchParamCreator(
        configuration,
      ).setVirtualInstanceType(virtualinstance, body, options);
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * VirtualInstancesApi - factory interface
 * @export
 */
export const VirtualInstancesApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Get details about a virtual instance.
     * @summary Get Virtual Instance
     * @param {string} virtualinstance uuid of the virtual instance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVirtualInstance(virtualinstance: string, options?: any) {
      return VirtualInstancesApiFp(configuration).getVirtualInstance(virtualinstance, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Get relevant metrics for a specific virtual instance
     * @summary Get Virtual Instance metrics
     * @param {string} virtualinstance uuid of the virtual instance
     * @param {number} start start time (ms)
     * @param {number} end end time (ms)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVirtualInstanceMetrics(virtualinstance: string, start: number, end: number, options?: any) {
      return VirtualInstancesApiFp(configuration).getVirtualInstanceMetrics(
        virtualinstance,
        start,
        end,
        options,
      )(fetch, basePath);
    },
    /**
     * Retrieve all virtual instances in an organization.
     * @summary List Virtual Instances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listVirtualInstances(options?: any) {
      return VirtualInstancesApiFp(configuration).listVirtualInstances(options)(fetch, basePath);
    },
    /**
     * Switch a virtual instance within an org with a new type
     * @summary Switch Virtual Instance Type
     * @param {string} virtualinstance uuid of the virtual instance
     * @param {SwitchVirtualInstanceTypeRequest} body JSON object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setVirtualInstanceType(
      virtualinstance: string,
      body: SwitchVirtualInstanceTypeRequest,
      options?: any,
    ) {
      return VirtualInstancesApiFp(configuration).setVirtualInstanceType(
        virtualinstance,
        body,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * VirtualInstancesApi - object-oriented interface
 * @export
 * @class VirtualInstancesApi
 * @extends {BaseAPI}
 */
export class VirtualInstancesApi extends BaseAPI {
  /**
   * Get details about a virtual instance.
   * @summary Get Virtual Instance
   * @param {string} virtualinstance uuid of the virtual instance
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VirtualInstancesApi
   */
  public getVirtualInstance(virtualinstance: string, options?: any) {
    return VirtualInstancesApiFp(this.configuration).getVirtualInstance(virtualinstance, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Get relevant metrics for a specific virtual instance
   * @summary Get Virtual Instance metrics
   * @param {string} virtualinstance uuid of the virtual instance
   * @param {number} start start time (ms)
   * @param {number} end end time (ms)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VirtualInstancesApi
   */
  public getVirtualInstanceMetrics(
    virtualinstance: string,
    start: number,
    end: number,
    options?: any,
  ) {
    return VirtualInstancesApiFp(this.configuration).getVirtualInstanceMetrics(
      virtualinstance,
      start,
      end,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Retrieve all virtual instances in an organization.
   * @summary List Virtual Instances
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VirtualInstancesApi
   */
  public listVirtualInstances(options?: any) {
    return VirtualInstancesApiFp(this.configuration).listVirtualInstances(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Switch a virtual instance within an org with a new type
   * @summary Switch Virtual Instance Type
   * @param {string} virtualinstance uuid of the virtual instance
   * @param {SwitchVirtualInstanceTypeRequest} body JSON object
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VirtualInstancesApi
   */
  public setVirtualInstanceType(
    virtualinstance: string,
    body: SwitchVirtualInstanceTypeRequest,
    options?: any,
  ) {
    return VirtualInstancesApiFp(this.configuration).setVirtualInstanceType(
      virtualinstance,
      body,
      options,
    )(this.fetch, this.basePath);
  }
}

/**
 * WorkspacesApi - fetch parameter creator
 * @export
 */
export const WorkspacesApiFetchParamCreator = function(configuration?: Configuration) {
  return {
    /**
     * List workspaces under given workspace.
     * @summary List Workspaces in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    childWorkspaces(workspace: string, options: any = {}): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling childWorkspaces.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}/ws`.replace(
        `{${'workspace'}}`,
        encodeURIComponent(String(workspace)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new workspace.
     * @summary Create Workspace
     * @param {CreateWorkspaceRequest} body workspace details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWorkspace(body: CreateWorkspaceRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createWorkspace.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
      const needsSerialization =
        <any>'CreateWorkspaceRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Remove a workspace.
     * @summary Delete Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWorkspace(workspace: string, options: any = {}): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling deleteWorkspace.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}`.replace(
        `{${'workspace'}}`,
        encodeURIComponent(String(workspace)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get information about a single workspace.
     * @summary Get Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorkspace(workspace: string, options: any = {}): FetchArgs {
      // verify required parameter 'workspace' is not null or undefined
      if (workspace === null || workspace === undefined) {
        throw new RequiredError(
          'workspace',
          'Required parameter workspace was null or undefined when calling getWorkspace.',
        );
      }
      const localVarPath = `/v1/orgs/self/ws/{workspace}`.replace(
        `{${'workspace'}}`,
        encodeURIComponent(String(workspace)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List all workspaces in an organization.
     * @summary List Workspaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWorkspaces(options: any = {}): FetchArgs {
      const localVarPath = `/v1/orgs/self/ws`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WorkspacesApi - functional programming interface
 * @export
 */
export const WorkspacesApiFp = function(configuration?: Configuration) {
  return {
    /**
     * List workspaces under given workspace.
     * @summary List Workspaces in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    childWorkspaces(
      workspace: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ListWorkspacesResponse> {
      const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).childWorkspaces(
        workspace,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Create a new workspace.
     * @summary Create Workspace
     * @param {CreateWorkspaceRequest} body workspace details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWorkspace(
      body: CreateWorkspaceRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CreateWorkspaceResponse> {
      const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).createWorkspace(
        body,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Remove a workspace.
     * @summary Delete Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWorkspace(
      workspace: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteWorkspaceResponse> {
      const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).deleteWorkspace(
        workspace,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get information about a single workspace.
     * @summary Get Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorkspace(
      workspace: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<GetWorkspaceResponse> {
      const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).getWorkspace(
        workspace,
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * List all workspaces in an organization.
     * @summary List Workspaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWorkspaces(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ListWorkspacesResponse> {
      const localVarFetchArgs = WorkspacesApiFetchParamCreator(configuration).listWorkspaces(
        options,
      );
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * WorkspacesApi - factory interface
 * @export
 */
export const WorkspacesApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * List workspaces under given workspace.
     * @summary List Workspaces in Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    childWorkspaces(workspace: string, options?: any) {
      return WorkspacesApiFp(configuration).childWorkspaces(workspace, options)(fetch, basePath);
    },
    /**
     * Create a new workspace.
     * @summary Create Workspace
     * @param {CreateWorkspaceRequest} body workspace details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWorkspace(body: CreateWorkspaceRequest, options?: any) {
      return WorkspacesApiFp(configuration).createWorkspace(body, options)(fetch, basePath);
    },
    /**
     * Remove a workspace.
     * @summary Delete Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWorkspace(workspace: string, options?: any) {
      return WorkspacesApiFp(configuration).deleteWorkspace(workspace, options)(fetch, basePath);
    },
    /**
     * Get information about a single workspace.
     * @summary Get Workspace
     * @param {string} workspace name of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorkspace(workspace: string, options?: any) {
      return WorkspacesApiFp(configuration).getWorkspace(workspace, options)(fetch, basePath);
    },
    /**
     * List all workspaces in an organization.
     * @summary List Workspaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWorkspaces(options?: any) {
      return WorkspacesApiFp(configuration).listWorkspaces(options)(fetch, basePath);
    },
  };
};

/**
 * WorkspacesApi - object-oriented interface
 * @export
 * @class WorkspacesApi
 * @extends {BaseAPI}
 */
export class WorkspacesApi extends BaseAPI {
  /**
   * List workspaces under given workspace.
   * @summary List Workspaces in Workspace
   * @param {string} workspace name of the workspace
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WorkspacesApi
   */
  public childWorkspaces(workspace: string, options?: any) {
    return WorkspacesApiFp(this.configuration).childWorkspaces(workspace, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Create a new workspace.
   * @summary Create Workspace
   * @param {CreateWorkspaceRequest} body workspace details
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WorkspacesApi
   */
  public createWorkspace(body: CreateWorkspaceRequest, options?: any) {
    return WorkspacesApiFp(this.configuration).createWorkspace(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Remove a workspace.
   * @summary Delete Workspace
   * @param {string} workspace name of the workspace
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WorkspacesApi
   */
  public deleteWorkspace(workspace: string, options?: any) {
    return WorkspacesApiFp(this.configuration).deleteWorkspace(workspace, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Get information about a single workspace.
   * @summary Get Workspace
   * @param {string} workspace name of the workspace
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WorkspacesApi
   */
  public getWorkspace(workspace: string, options?: any) {
    return WorkspacesApiFp(this.configuration).getWorkspace(workspace, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * List all workspaces in an organization.
   * @summary List Workspaces
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WorkspacesApi
   */
  public listWorkspaces(options?: any) {
    return WorkspacesApiFp(this.configuration).listWorkspaces(options)(this.fetch, this.basePath);
  }
}
